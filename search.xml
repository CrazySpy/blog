<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++中signed和unsigned的大小比较</title>
    <url>/2018/04/15/C++%E4%B8%ADsigned%E5%92%8Cunsigned%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>有这样的一段代码，请说出其运行结果：<D-r> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x80000000</span> &gt; a)</span><br><span class="line">        cout &gt;&gt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &gt;&gt; <span class="string">&quot;111111\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <span id="more"></span>
上面程序运行的结果是111111</p>
<p>对于十六进制的整数，如果字面量（即以unsigned int来看）超出了signed
int的范围，编译器则尝试以unsigned
int作为其类型。由于0x80000000转换成unsigned int在signed
int的范围外，而它在unsigned int的范围内，所以将其当作unsigned int。
当unsigned和signed进行大小比较时，signed会转换成unsigned，这样a就会变成0xFFFFFFFF的unsigned的整数，这是一个很大的数字（2^32
- 1，是unsigned int的最大值），所以b&gt;a。</p>
]]></content>
      <categories>
        <category>C/C++`</category>
      </categories>
  </entry>
  <entry>
    <title>C++如何查看自动推测类型的结果</title>
    <url>/2018/09/17/C++%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%B5%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<p>由于实际编程时的各种复杂情况，即使C++的自动类型推测有许多的规则，但是还是会出现编程人员无法正确推测类型，这时候有几种方法可以用于查看推测结果。
<span id="more"></span></p>
<h1 id="编译器推测">编译器推测</h1>
<p>这种方法是利用错误输出（一般是声明模板函数但不定义）来达到查看推测结果的目的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">auto</span> x = <span class="number">10</span>; </span><br><span class="line">	<span class="built_in">TD</span>&lt;<span class="keyword">decltype</span>(x)&gt;(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这样我们在TD类未定义的错误中，可以看到x的推测类型。</p>
<p>我这里使用的是Clang++编译器，它的错误提示是： error: implicit
instantiation of undefined template 'TD' 这样可以看到x的类型为int</p>
<h1 id="运行时的输出">运行时的输出</h1>
<p>上面的方法是类似于利用错误输出结果，下面介绍的方法可以运行时输出推测结果。</p>
<h2 id="c标准库自带">C++标准库自带</h2>
<p>这里利用std::typeid运算符和std::type_info::name方法。</p>
<p>typeid运算符返回const
type_info&amp;类型。通过type_info的成员方法name我们可以获得一个C风格字符串，这个字符串蕴含了运算对象类型。</p>
<p>使用例子： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T* param)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(param).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">auto</span> x = <span class="number">1</span>; </span><br><span class="line">	<span class="built_in">f</span>(&amp;x); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
如果使用的是Microsoft的编译器，这个字符串就很舒服，直接显示了运算对象的类型。上面的运行结果应该是：
T = int param = int const*
。如果和我一样使用的clang或者GNU的GCC编译器，那么就会显示 T = i param =
PKi 其中PK代表pointer to konst, i代表int。
但是这种使用C++标准库自带的typeid运算符的方法并不可靠，例如：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> T&amp; param)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(param).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">auto</span> x = <span class="number">1</span>; </span><br><span class="line">	<span class="built_in">f2</span>(x); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure> 返回显示T和param均为int，而实际上param为const
int&amp;类型。
这个是在typeid的运算符中定义能找到原因的。typeid的定义是返回运算对象使用通过传值的方式传给template函数推测出来的参数的值。上面的代码中就是相当于typeid(param)返回的是如下代码推测的结果：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">f3</span>(x);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所以使用typeid运算符并不能在大多数情况下返回你想要的结果</p>
<p>所以接下来使用的是一种利用C++的扩展库boost中的方法来完成运行时输出推测结果的任务。
## boost库完成 --------</p>
<p>我们可以利用boost库中的type_id_with_cvr来完成上面的任务：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T param)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;T = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>() &lt;&lt;endl;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;param = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">f</span>(x);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 结果是 T = int param = int const
非常漂亮，和使用Microsoft编译器的结果是一样的，可以直接显示出类型，而不是使用PK这类的缩写。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++的左移和右移</title>
    <url>/2018/04/12/C++%E7%9A%84%E5%B7%A6%E7%A7%BB%E5%92%8C%E5%8F%B3%E7%A7%BB/</url>
    <content><![CDATA[<p>今天在做《深入理解计算机系统》时有这样一道题</p>
<p>Problem 2.23 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">(<span class="type">unsigned</span> word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)((word &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun2</span><span class="params">(<span class="type">unsigned</span> word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="type">int</span>) word &lt;&lt; <span class="number">24</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>求w=0x000000C9时fun1(w)与fun2(w) <span id="more"></span></p>
<p>首先w先化成0000 0000 0000 0000 0000 0000 1100 1001
然后fun1(w)没什么问题，答案还是0x000000C9</p>
<p>fun2(w)的答案让我有一些意外。 (int)w &lt;&lt; 24 = 1100 1001 0000
0000 0000 0000 0000 0000(B)
然后再&gt;&gt;24，原本以为是和左移类似，将每一位向右移，补0，这样的话得到的是0000
0000 0000 0000 0000 0000 1100
1001，也就是0x000000C9。结果错的，答案是0xFFFFFFC9。</p>
<p>考虑了下，发生这种情况是因为C/C++中左移是逻辑左移，而右移不是逻辑右移，是算数右移。
这样算出来应该是1111 1111 1111 1111 1111 1111 1100
1001也就是0xFFFFFFC9</p>
<p>接下来简单说一下逻辑右移和算数右移的区别，逻辑右移就是单纯高位补0。而算数右移要看符号位，符号位是1则每次右移补1，符号位为0则每次右移补0，unsigned因为没有符号位（或者理解成符号位始终为0），所以unsigned类型的逻辑左移和逻辑右移始终补0。
那上面的例子，原来w是unsigned类型的，因为转换成了signed
int了，所以是有符号位，而且&lt;&lt;24操作使得符号位为1，所以每次右移补符号位的1。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Eratosthenes筛法</title>
    <url>/2018/06/01/Eratosthenes%E7%AD%9B%E6%B3%95/</url>
    <content><![CDATA[<p>HDU-1019：http://acm.hdu.edu.cn/showproblem.php?pid=1019</p>
<p>大意就是讲求几个数的最小公倍数，保证结果在long int范围内。</p>
<p>原来的思路是使用 <span class="math display">\[
\begin{align}
LCM(\ LCM(a, \ b), \ c) &amp;== \ LCM(\ a, \ b, \ c) \nonumber \\
LCM(a, b) &amp;== a * b / GCD(a, b) \nonumber
\end{align}
\]</span> 这两个公式求出。但是考虑到LCM(a,b)中，虽然a和b是在long int
范围内，但是LCM(a,b)不一定在。如果用long long
int，引入c，LCM(a,b,c)不一定在long long int内，所以这个方法放弃。
<span id="more"></span></p>
<p>想到之前看到过一个Eratosthenes筛法，思路就是构建素数表，然后根据
<span class="math display">\[
\begin{align}
a&amp;=p_{1}^{n_{a1}}p_{2}^{n_{a2}}p_{3}^{n_{a3}}...p_{m}^{n_{am}}
\nonumber \\
b&amp;=p_{1}^{n_{b1}}p_{2}^{n_{b2}}p_{3}^{n_{b3}}...p_{m}^{n_{bm}} \
\  (p_{1}，p_{2}...p_{m}均为素数) \nonumber \\
LCM(a,b)&amp;=p_{1}^{max(n_{a1},n_{b1})}p_{2}^{max(n_{a2},n_{b2})}...p_{m}^{max(n_{am},n_{bm})}
\nonumber
\end{align}
\]</span></p>
<p>素数表的最优实现可以参考这篇博客：<a
href="../素数表的最优实现">素数表的最优实现</a>
这个原理得出LCM(a,b)的素因数分解结果，从而得出最后的结论。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>Mac系统GUI应用程序不读取环境变量</title>
    <url>/2018/04/14/Mac%E7%B3%BB%E7%BB%9FGUI%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%AF%BB%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>前几天brew
upgrade指令把系统里的应用更新了一遍，其中包括python3。后来发现Macvim打不开，有闪退情况，用terminal看了下错误，我安装了YouCompleteMe插件，这个插件是基于python的，而python的encoding包找不到，根据网上的说法是brewhome里新的python3没有配置环境变量，于是把PYTHONPATH和PYTHONHOME环境变量在.zshrc（我用的是zsh）里面配了以下，结果发生了很诡异的事情，在terminal中可以打开Macvim，而我在finder中打开它就闪退，当时Google百度都没相关案例，只能先搁置。
<span id="more"></span>
今天想到了个方案，我先把youcompleteme禁用了，然后发现terminal和finder中都能打开，我觉得可能是finder中打开Macvim没有读取到上面设置的两个环境变量。然后分别在两种情况下打开的Macvim中用命令行echo
$PYTHONPATH，发现确实是如我上面的猜测，PYTHONPATH仅仅在terminal打开的情况下能读取到。知道问题就Google解决方案了。
然后我用的是macOS High Sierra，网上说的什么
/etc/launchd.conf在10.10的时候就没了，最后用了下面的命令解决的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl setenv 环境变量名 环境变量内容</span><br></pre></td></tr></table></figure>
<p>例如我的系统就设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl setenv PYTHONPATH /usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/bin</span><br></pre></td></tr></table></figure>
<p>#重启不失效的设置方法 自Mountain
Lion以来，之前原有的environment.plist的方法已经确定失效了。新的有效的方法是在/etc/launchd.conf中添加指令设置环境变量。
这个文件默认并不存在，可以自己建立。其内容则与launchctl执行的指令的格式相同。如上述设置可在/etc/launchd.conf中添加如下内容：
setenv JAVA_VERSION 1.6
需要注意的是，在launchd.conf中的命令有一些限制。首先是不能进行环境变量的引用。比如再设置JAVA_HOME环境变量的话，不能使用类似/System/Library/Frameworks/JavaVM.Framework/$JAVA_VERSION/Home的方式来引用之前设置的JAVA_VERSION环境变量，必须明确写出1.6。同时环境变量的内容中也不允许出现空格。
launchd.conf仅在系统启动时被调用，因此修改完成后需要重启才能看到效果。
此方法转载自:http://zodiacg.net/2013/05/set-path-under-mac/</p>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
  </entry>
  <entry>
    <title>MySql中order表创建失败</title>
    <url>/2018/04/21/MySql%E4%B8%ADorder%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>今天在试图创建order表的时候出现了问题，怎么都创建不成功。不是语法问题。</p>
<p>order是sql关键字，创建它的表要`符号</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis的ziplist数据结构</title>
    <url>/2018/05/27/Redis%E7%9A%84ziplist%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>ziplist主要用于存储长度受到限制的字符串和大小受到限制的数字。
ziplist在源代码中没有直接的结构体定义，而是在ziplistNew函数中开辟了一组连续空间，并且对连续空间进行位级别的赋值，从而达到类似于结构体的功能。</p>
<p>ziplist数据结构： <img
src="/images/Redis的ziplist数据结构/ziplist.png" /> <span id="more"></span>
各个数据的含义： + ZIPLIST_BYTES：一个4字节数据，用于存放压缩表字节数。
+ ZIPLIST_TAIL：最后一个entry距离表头的位置。如上图：head + ZIPLIST_TAIL
= entry_tail +
ZIPLIST_LENGTH：entry个数。因为只有2字节，当数值小于等于UINT16_MAX则代表真是的entry个数，否则需要遍历得出真实个数。
+ ZIP_END：表的尾，定值是255，用来遍历压缩表时作为结束标记。</p>
<p>ziplist在源代码中也没有直接的结构体定义存储在压缩表中的entry结构(zlentry不是的)。而是在插入数据的时候进行开辟的相关操作。</p>
<p>根据ziplistInsert的定义，分析的出entry由以下的数据组成： +
prevlen：这个是前一个节点的长度，用于寻找某个节点的前节点。 +
encoding：编码，表示了数据类型。具体格式如下： <img
src="/images/Redis的ziplist数据结构/ziplist_encoding.png" /></p>
<p>可以看到当entry存放字符串（字节数组）时，encoding可以反映出字符串的长度；entry存放整数时，可以反映整数的大小范围。
+ content：存放了具体的数据。</p>
]]></content>
      <categories>
        <category>Redis源码分析</category>
        <category>ziplist</category>
      </categories>
  </entry>
  <entry>
    <title>auto类型的推测准则</title>
    <url>/2018/09/15/auto%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A8%E6%B5%8B%E5%87%86%E5%88%99/</url>
    <content><![CDATA[<p>auto是C++11标准新引入的一个关键字，用于类型推测。</p>
<p>例如： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>编译器则会在编译时自动将x调整为int类型。</p>
<p>关于auto类型的调整类型的规则，它还是遵循C++11中template的规则来进行的，稍有不同。关于C++11中template的类型推测可以参见:<a
href="/2018/09/14/C++11标准的模板类型推测">C++11标准的模板类型推测</a>
<span id="more"></span> # auto对于变量的类型推测</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> cx = x;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; rx = x;</span><br></pre></td></tr></table></figure>
<p>上面的代码的类型推测和下面代码的推测过程类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_x</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_cx</span><span class="params">(<span class="type">const</span> T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_for_rx</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> x = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func_for_x</span>(<span class="number">27</span>); <span class="comment">// 推导得出的param类型就是auto x = 27中x的类型</span></span><br><span class="line">	<span class="built_in">func_for_cx</span>(x); <span class="comment">// 推导得出的param类型就是const auto cx = x中cx的类型，也就是const auto类型</span></span><br><span class="line">	<span class="built_in">func_for_rx</span>(x); <span class="comment">// 同上类比</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的实际类型就是上面代码中param的实际类型。</p>
<p>我们首先规定如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);</span><br><span class="line"></span><br><span class="line">ArgType x = expr;</span><br></pre></td></tr></table></figure>
<p>上面的代码中ArgType是一个带有auto的类型，最终ArgType和ParamType是等价的，而auto代表的类型其实就是T的类型。</p>
<p>所以在一般情况下，对于变量的类型推测，auto和C++11中template的类型推测方法是一样的，只要用如上的方式转化下就可以理解。</p>
<h1
id="auto对于函数数组类型参数的推测">auto对于函数、数组类型参数的推测</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;CrazySpy&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> arr1 = name; <span class="comment">// arr1&#x27;s type is const char*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; arr2 = name; <span class="comment">// arr2&#x27;s type is const char (&amp;)[13]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> func1 = foo; <span class="comment">// func1&#x27;s type is void (*)(int, double)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; func2 = foo; <span class="comment">// func2&#x27;s type is void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>
<p>使用auto对于变量类型推测时的理解方法来看，auto在对于函数、数组类型参数的推测还是遵循C++11中template的那一套来做的。</p>
<h1
id="auto推测与c11中template推测的不同点">auto推测与C++11中template推测的不同点</h1>
<p>auto与C++11中template推测不同的地方只有一个，那就是对于initializer_list对象的推测结果是不同的。</p>
<p>在C++11标准中，我们可以用如下的方法初始化一个变量:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x1 = &#123;<span class="number">27</span>&#125;;</span><br><span class="line"><span class="type">int</span> x2&#123;<span class="number">27</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这种初始化方式是使用了C++11的新特性之一--initializer_list。然而这种方式在使用auto进行类型推测时，却是和C++11中的template推测结果不一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(initializer_list&lt;T&gt; initList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x1 = &#123;<span class="number">11</span>,<span class="number">5</span>&#125;; <span class="comment">// x1 is initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(&#123;<span class="number">11</span>,<span class="number">5</span>&#125;); <span class="comment">//error, cannot deduce type!</span></span><br><span class="line"><span class="built_in">f2</span>(&#123;<span class="number">11</span>,<span class="number">5</span>&#125;); <span class="comment">// T is int, initList is initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看出对于initializer_list类型来说，auto是自动推测成initializer_list类型，而template推测时，如果形参不是initializer_list<T>，则推测失败，否则T就为initializer_list中元素的类型。</p>
<h1 id="其它杂项">其它杂项</h1>
<p>在C++11标准中： auto不可以直接作为函数的返回值类型。 例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在C++11标准中，这是不可以的</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在lambda表达式的参数表当中也不允许参数为auto。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在C++11标准中这是不可以的，c++14中可以</span></span><br><span class="line"><span class="keyword">auto</span> resetV = [&amp;v](<span class="type">const</span> <span class="keyword">auto</span>&amp; newVal) &#123;v = newVal;&#125;;</span><br></pre></td></tr></table></figure>
<p>五.总结</p>
<p>记住以下两点：</p>
<ul>
<li>auto的类型推测结果和template类型推测结果是一样的，但是auto类型会将initializer_list推测为initializer_list类型，而template不会。</li>
<li>在C++11标准中，auto不可作为lambda的参数类型以及函数的返回值类型。但在C++14中可以，后面会具体出博客讲到。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>const_iterator与iterator</title>
    <url>/2018/09/29/const_iterator%E4%B8%8Eiterator/</url>
    <content><![CDATA[<p>const_iterator是STL中用来指向const的一个迭代指示器，它指向的元素是不可以进行修改的。但是在C++98中，对const_iterator有些像半成品，不尽人意。不过在C++11中，const_iterator变得更好用了。
<span id="more"></span>
在C++98中，我们如果要是用const_iterator进行操作是有些奇怪的。例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::iterator IterT;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;<span class="type">int</span>&gt;::const_iterator ConstIterT;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; values;</span><br><span class="line"></span><br><span class="line">ConstIterT ci = std::<span class="built_in">find</span>( <span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">begin</span>()), <span class="built_in">static_cast</span>&lt;ConstIterT&gt;(values.<span class="built_in">end</span>()), <span class="number">1983</span>);</span><br><span class="line">values.<span class="built_in">insert</span>(<span class="built_in">static_cast</span>&lt;IterT&gt;(ci), <span class="number">1998</span>);</span><br></pre></td></tr></table></figure>
先不考虑static_cast是否可以转换成功。因为vector::insert只接受iterator作为第一个参数，而std::find参数因为为了ci的数据不可被修改，所以使用了ConstIterT。这样的写法实在太繁琐了。更何况将ConstIterT转换成IterT需要很多麻烦的步骤。</p>
<p>而C++11对const_iterator有了很大的改善。上述的代码可以这样写:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(values.<span class="built_in">cbegin</span>(), values.<span class="built_in">cend</span>(), <span class="number">1983</span>);</span><br><span class="line">values.<span class="built_in">insert</span>(it, <span class="number">1998</span>);</span><br></pre></td></tr></table></figure>
我们对于const_iterator的获取非常简单，可以直接使用cbegin、cend、rbegin等。</p>
<p>在C++14中，我们甚至可以使用如下的方法扩展到非STL的C++自带的数组。代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> V&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">findEle</span><span class="params">(C&amp; container, <span class="type">const</span> V&amp; targetVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> std::cbegin;</span><br><span class="line">	<span class="keyword">using</span> std::cend;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> it = std::<span class="built_in">find</span>(<span class="built_in">cbegin</span>(container), <span class="built_in">cend</span>(container), targetVal);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">2000</span>,<span class="number">1983</span>&#125;;</span><br><span class="line">	<span class="built_in">findEle</span>(arr, <span class="number">1983</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到这里使用的是C++14的新的非STL成员函数的cbegin和cend，这两个全局函数使得代码更简单。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>constexpr的使用</title>
    <url>/2018/09/30/constexpr%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>C++11中引入了新的关键字constexpr。当用在对象上时，它相当于const的进化。如果用它修饰函数，那么被修饰的函数可以在编译时确定所有值，那么它就在编译时就可以将返回值确定下来，并把返回值定为const类型。然后就可以将函数作为一个const常量使用了。<span id="more"></span>这个在数组的定义等情况有很多用处。例如下面的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::array&lt;<span class="type">int</span>, pow(3, 2)&gt; arr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果在pow函数中，确实可以在编译时推得函数内所有值，那么这个实例确实是可以实现的。</p>
<p>在C++11标准中，这个pow函数要实现有一些麻烦。因为<strong>在C++11标准中，constexpr函数只能拥有一句语句，这句语句也就是return。</strong>为了满足这个要求，只能使用如下代码定义pow函数:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> exp == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, exp - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这样才能将pow完美定义。</p>
<p>而<strong>在C++14标准中，对于constexpr函数的定义可以更加宽松，constexpr的定义可以是任意多的语句</strong>，但是对于返回值类型还做了要求。例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; exp; ++i)</span><br><span class="line">		result *= base;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于返回值，可以返回字面类型(literal
type)，字面类型就是指在编译时可以确定具体指的类型，它是<strong>除了void外的所有内建类型以及部分用户定义的类型也可能是字面类型。</strong>例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> : x(xVal), y(yVal)&#123;</span>&#125;;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123;x = newX;&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123;y = newY;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> : </span><br><span class="line">		<span class="type">double</span> x;</span><br><span class="line">		<span class="type">double</span> y; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
因为Point的所有成员变量都可以在对象构造的时候进行初始化，所以，这个Point类是一个字面类型。可以在编译的时候的确定，因此就可以作为C++14标准中constexpr函数的返回值。如果一个如实的类型Point的对象被声明为constexpr，那么这个对象就相当于存在于一段只读内存中。
在C++11使用了两种限制来确保对象的成员变量不可变，声明为constexpr的对象隐式拥有const的属性，所以setX这类的setter函数是没法执行的，并且成员变量也是没有办法修改的；另外setter函数的void返回类型不是字面类型，所以没有办法执行这一类setter函数。不过在C++14标准中，返回值为void的函数是可以声明为constexpr的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> : </span><br><span class="line">		<span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> : x(xVal), y(yVal)&#123;</span>&#125;;</span><br><span class="line">		<span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123;x = newX;&#125; <span class="comment">// C++14通过。C++11报错cannot assign to non-static data member within const member function &#x27;setX&#x27;</span></span><br><span class="line">		<span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123;y = newY;&#125; <span class="comment">// C++14通过。C++11报错</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> : </span><br><span class="line">		<span class="type">double</span> x;</span><br><span class="line">		<span class="type">double</span> y;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Point <span class="title">result</span><span class="params">(p)</span></span>;</span><br><span class="line">	result.<span class="built_in">setX</span>(<span class="number">10.2</span>);</span><br><span class="line">	result.<span class="built_in">setY</span>(<span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>; </span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> p2 = <span class="built_in">reflection</span>(p1);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>decltype的运用</title>
    <url>/2018/09/16/decltype%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>之前我们讲到过，在C++11标准中，auto不可以直接用于函数的返回值以及lambda表达式的参数类型。而在C++14标准中，对这一规定进行了变更。</p>
<p>C++11中不是不可以使用auto返回类型的模板函数，而是需要使用decltype的方式进行尾置类型定义。具体的形式如下：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(T param)</span> -&gt; <span class="title">decltype</span><span class="params">(param)</span> </span>&#123; <span class="keyword">return</span> param; &#125;</span><br></pre></td></tr></table></figure>
它使用了“-&gt;decltype(param)”的形式对使用auto返回类型的函数定义了返回值的类型--返回的是param的类型。但是这种写法可能是因为其不像C++的语法，在C++14中使用了decltype(auto)的写法进行代替。下面就来介绍decltype在C++中的使用。
<span id="more"></span> # 基本语法 decltype的用法很简单： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>; <span class="comment">//decltype(x) is int</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Widget&amp; w)</span></span>; <span class="comment">//decltype(f) is bool(const Widget&amp;), decltype(w) is const Widget&amp; </span></span><br></pre></td></tr></table></figure>
<strong>decltype几乎可以正确返回变量或者表达式的正确数据类型。</strong>
但是存在一个例外：
decltype对于不是使用名字的参数，并且这个参数是左值的情况是返回引用类型。
例如：如果decltype中的参数使用的名字，并且这个名字被括号包围（不是decltype的括号），则认定参数为左值，且为不是使用名字的参数，所以返回引用类型。下面的代码可以得出这样的结论：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TD</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>; </span><br><span class="line">	TD&lt;<span class="keyword">decltype</span>((x))&gt; td; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
这里编译器返回的错误告知我们td推测的T的类型是int&amp;，也就是引用类型。</p>
<h1 id="decltypeauto的使用">decltype(auto)的使用</h1>
<p>在C++11中，如果函数返回类型要使用auto是，则必须使用尾置返回类型。这种语法非常不像C++的语法，所以在C++14中，使用了新的东西对其进行替代--decltype(auto)</p>
<p>在对函数的返回类型进行推测时，用法如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) </span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(T param)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> param; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line">	cout&lt;&lt;<span class="built_in">f</span>(x)&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
它和作用和使用尾置返回类型是一样的。</p>
<p>而在对于变量的类型推测时，也是可以使用decltype(auto)的。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="type">const</span> Widget&amp; cw = w; </span><br><span class="line"><span class="keyword">auto</span> myWidget1 = cw; <span class="comment">// myWidget1&#x27;s type is Widget </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) myWidget2 = cw; <span class="comment">// myWidget2&#x27;s type is const Widget&amp; </span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<ol type="1">
<li>decltype几乎可以返回所有类型的正确类型。</li>
<li>decltype在参数为左值类型、没有使用名称时，会返回引用类型，例如：decltype((x));</li>
<li>C++14支持decltype(auto)的使用，用法和auto很像，但是它的推测规则是使用decltype的规则。</li>
</ol>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>delete关键字的使用</title>
    <url>/2018/09/28/delete%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在C++98标准中，我们对于会默认产生的方法，例如：默认构造函数等，如果想让它不是默认产生，那么只要把它们的声明放在private，无需定义。
例如在istream和ostream不可拷贝，它们的父类basic_ios这样定义:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt;&gt; </span><br><span class="line"><span class="keyword">class</span> basic_ios:<span class="keyword">public</span> ios_base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>: ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">			<span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp;); <span class="comment">// not definded</span></span><br><span class="line">			basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;); <span class="comment">// not definded</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
在C++11中，我们引入了delete关键字，所以上述代码的C++11形式如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios:<span class="keyword">public</span> ios_base &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">		basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然两者写法都不复杂，但是还是推荐使用delete关键字。 <span id="more"></span>
两者的区别主要在于以下几点： *
友元函数如果声明在private中，这个友元函数仍然是有效的。但是如果使用delete，则可以将这个友元函数删除。
*
另外对于重载函数，如果实参和形参的数据类型可以隐式转换，我们又不想使用这个隐式转换时，就可以使用delete关键字。例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>: <span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Operation op;</span><br><span class="line">	op.<span class="built_in">isLucky</span>(<span class="number">10</span>); <span class="comment">// error! 参数不可以是一个int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
如果不声明定义参数为int的isLucky函数，那么参数10会隐式转换成double，然后执行bool
isLucky(double)。如果某个成员方法是模板类型的，而我们要对类型推测的某个结果做不编译处理，那么使用private则不能达到目的。只能使用C++11的新特性。例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">isLucky</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="type">void</span> Operation::<span class="built_in">isLucky</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>; <span class="comment">// 不可以生成参数为void*的模板函数，而且这句话只能在命名空间内声明，不可以在类空间中声明。</span></span><br></pre></td></tr></table></figure>
要注意，<strong>上面代码的delete只能在命名空间内声明，而不可以在类空间内声明。</strong>对于使用delete的函数，建议是定义在public中。因为编译器在调用一个函数之前，编译器通常是先检查这个函数是在什么访问空间中，如果是private空间中，那么就不管它是不是delete，返回的是private不可直接访问的错误，而不是说这个函数是delete的。这样不利于查错。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>dictScan函数分析</title>
    <url>/2018/04/08/dictScan%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>dictScan的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">dictScan</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		dict *d,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">unsigned</span> <span class="type">long</span> v,</span></span></span><br><span class="line"><span class="params"><span class="function">		dictScanFunction *fn,</span></span></span><br><span class="line"><span class="params"><span class="function">		dictScanBucketFunction* bucketfn,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">void</span> *privdata)</span></span></span><br></pre></td></tr></table></figure>
<p>这里的扫描分为两个步骤，第一步对桶执行用户自定义函数(bucketfn)，再对桶内每个节点执行用户自定义函数(fn)。</p>
<p>当进行dictScan时没有进行rehash，那么只要先对0号表的需要scan的桶进行用户自定义的操作，然后对于桶内节点进行遍历执行自定义函数即可。</p>
<p>如果正在进行rehash，这时候会比较复杂。 <span id="more"></span>
正在rehash时的scan代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></span><br><span class="line"><span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123; <span class="comment">//这样可以把哈希表扩大和缩小统一看成扩大</span></span><br><span class="line">	t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">	t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m0 = t0-&gt;sizemask;</span><br><span class="line">m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Emit entries at cursor */</span></span><br><span class="line"><span class="keyword">if</span> (bucketfn) <span class="built_in">bucketfn</span>(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">de = t0-&gt;table[v &amp; m0];</span><br><span class="line"><span class="keyword">while</span> (de) &#123;</span><br><span class="line">	next = de-&gt;next;</span><br><span class="line">	<span class="built_in">fn</span>(privdata, de);</span><br><span class="line">	de = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment"> * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">	<span class="keyword">if</span> (bucketfn) <span class="built_in">bucketfn</span>(privdata, &amp;t1-&gt;table[v &amp; m1]);</span><br><span class="line">	de = t1-&gt;table[v &amp; m1];</span><br><span class="line">	<span class="keyword">while</span> (de) &#123;</span><br><span class="line">		next = de-&gt;next;</span><br><span class="line">		<span class="built_in">fn</span>(privdata, de);</span><br><span class="line">		de = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Increment bits not covered by the smaller mask */</span></span><br><span class="line">	v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br></pre></td></tr></table></figure></p>
<p>t0、t1指针指向0号和1号哈希表，但是t0指向0号和1号表里的大小较小的那个，t1执行另一个，具体原因下面分析。m0、m1指向t0、t1指向的哈希表的大小掩码(sizemask)。大小掩码根据分析dictht(dictHashTable)的数据结构可以知道，是哈希表可以存放的桶的数量-1。</p>
<p>dictht的数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictht</span> &#123;</span><br><span class="line">	dictEntry **table; <span class="comment">//指向表的第一个哈希桶，指向第一个桶的第一个节点</span></span><br><span class="line">	<span class="comment">/* 哈希表的情况 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">//桶的数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">//桶数量的掩码，掩码用于hashFunction(key)结果如果超过size，则将结果与sizemask做一个&amp;运算，这样将哈希结果框定到size内</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> used; <span class="comment">//节点的数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>首先还是和没有rehash的操作一样，对t0指向的表(注意不一定是0号表。下面简称t0，t1类似)的指定桶(v号)执行用户自定义的桶操作，并且对桶内哈希节点进行用户自定义操作。</p>
<p>但是由于在rehash时有一部分数据可能在t1的相应的桶中，所以要对t1的相应的桶中的数据进行扫描，这样才能扫描完整。</p>
<p>t1表的扫描代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment"> * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">	<span class="keyword">if</span> (bucketfn) <span class="built_in">bucketfn</span>(privdata, &amp;t1-&gt;table[v &amp; m1]);</span><br><span class="line">	de = t1-&gt;table[v &amp; m1];</span><br><span class="line">	<span class="keyword">while</span> (de) &#123;</span><br><span class="line">		next = de-&gt;next;</span><br><span class="line">		<span class="built_in">fn</span>(privdata, de);</span><br><span class="line">		de = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Increment bits not covered by the smaller mask */</span></span><br><span class="line">	v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br></pre></td></tr></table></figure>
<p>和之前一样，每次都要执行一个桶的自定义函数和并且对桶内节点扫描一遍，重点在于：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</span><br></pre></td></tr></table></figure></p>
<p>在尝试理解这套算法之前，先明确以下的事实：</p>
<p>1.一个哈希节点的索引是由hashFunction(val) &amp;
sizemask计算得出的，sizemask是为2^n-1。</p>
<p>2.hashFunction(val)&amp;m0 和 hashFunction(val)&amp;m1
的差别在高位，在m0的位数的范围内是一样的。 举个例子: hashFunction(val) =
9(D) = 1001(B) m0 = 3(D) = 11(B) m1 = 15(D) = 1111(B) hashFunction(val)
&amp; m0 = 1001 &amp; 0011 = 0001(B) 即在t0表内索引是1(D)
hashFunction(val) &amp; m1 = 1001 &amp; 1111 = 1001(B)
即在t1表内索引是9(D) 它们在m0的位数(m0是2位)范围内是一样的，都是01。
由2可推得对于t0到t1是扩展的情况时，只要考虑m0位数+1~m1位数这个扩展位数的部分，枚举这段空间的0或1情况即可。
例如:
还是上述的条件，只要再考虑第3位(m0位数+1，m0两位)~第4位(m1位数)的枚举，即0001、0101、1001、1101在t1中的位置。</p>
<p>明确了上面的内容之后，这个算法的精妙之处就逐渐显现出来了。</p>
<p>上面算法的思路就是在v的[m0的位数+1,m1的位数]位枚举情况，而v的低m0的位不变。例如上面的例子，v初值为0001(B),低两位(m0的位数)不变，剩下的高两位进行枚举，根据上面的算法，v就得到0001(v初始值)、1001、0101、1101。
再由 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (v &amp; (m0 ^ m1))</span><br></pre></td></tr></table></figure>
这行代码判断，v的[m0的位数+1,m1的位数]位的每一位是否都是0，如果是，那么就相当于t1表已经扫描完了。还是上面的例子，当v枚举到了原点：0001的时候退出枚举。</p>
<p>接下来就要把下一个枚举的v计算出来，这时候就是v的[m0的位数+1,m1的位数]位不变，都置0，v的低m0的位数的几位执行倒转+1倒转回去的操作。这也是最后一部分代码所要表达的就是在m0的位数的范围内将当前的v倒转+1再倒转，找到下一个要在t0和t1都进行扫描的索引号。代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></span><br><span class="line"><span class="comment"> * operates on the masked bits of the smaller table */</span></span><br><span class="line">v |= ~m0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">v = <span class="built_in">rev</span>(v);</span><br><span class="line">v++;</span><br><span class="line">v = <span class="built_in">rev</span>(v);</span><br></pre></td></tr></table></figure> 这里的rev函数就是上面所说的高低位互相调换的操作。</p>
<p>它的具体实现也贴出来： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">rev</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s = <span class="number">8</span> * <span class="built_in">sizeof</span>(v); <span class="comment">// bit size; must be power of 2</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mask = ~<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((s &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		mask ^= (mask &lt;&lt; s); v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过该算法，最后当v的位数大于m1的位数，相当于把0号表、1号表都扫描完了。这时v
&amp; m1 == 0。</p>
<p>这个算法可以保证每个节点都被扫描到，有可能会有节点重复被访问，但是节点重复访问存在于rehash到更小的表时，这种情况在这套算法里是不存在的，因为这里手动将t0指向较小的表，这样始终就是rehash扩大的情况，不会存在重复访问的问题，这也是为什么上面要进行t0指向较小的表的原因。</p>
<p>rehash到小表会导致重复访问的例子： sizemask(0号表) = 1111(B)
sizemask(1号表) = 111(B) 0号表有桶0000 1000
1号表的000桶至少会在扫描如上两个桶的时候都被访问到。</p>
]]></content>
      <categories>
        <category>Redis源码分析</category>
        <category>dict</category>
      </categories>
  </entry>
  <entry>
    <title>dict的rehash机制</title>
    <url>/2018/04/08/dict%E7%9A%84rehash%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>dict的rehash是用于将数据分布在更大或更小的哈希表内。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br></pre></td></tr></table></figure>
框定了这一次rehash的桶的数量，为用户自定义的n的10倍。这样做是防止单次rehash消耗太多时间，影响其他的操作，分次操作可以提高并发效率。
节点被rehash之后就会从0号表移除，并且添加到1号表相应的桶中。所以当0号表变成空的时候，所有数据都已经rehash到了1号表中，这样本轮rehash完成，返回0。否则就返回1，还需要下次rehash以完成本轮rehash。</p>
<span id="more"></span>
<p>rehash的条件：
在添加元素的dictAddRaw函数中调用的_dictKeyIndex函数中，会对是否满足rehash条件进行判断，并在如果需要rehash时进行rehash(调用_dictExpandIfNeeded函数)。
_dictExpandIfNeeded代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">dictIsRehashing</span>(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">	<span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">dictExpand</span>(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">	 * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">	 * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">	 * the number of buckets. */</span></span><br><span class="line">	<span class="comment">//默认是即使dict_can_resize关闭，已使用桶的数量是桶数量的5倍进行强制rehash。如果没有关闭则是超过桶数量就进行rehash</span></span><br><span class="line">	<span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">			(dict_can_resize ||</span><br><span class="line">			 d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">dictExpand</span>(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>); <span class="comment">//扩展到已使用桶数量的两倍</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DICT_OK;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，正在rehash时则不进行是否需要rehash的判断。而如果0号哈希表数据为空，则将哈希表扩展成最小的尺寸（根据DICT_HT_INITIAL_SIZE的宏定义，最小尺寸为4）。如果开启了dict_can_resize，当0号表的平均桶内数据量为1时，就进行rehash。如果没有开启，则会根据dict_force_resize_ratio（默认为5）宏定义，进行强制哈希。
每次哈希将表容量*2，这样表的容量可以保证是2^n，对于dictScan有重要作用。关于这部分可以参考之前的文章。</p>
]]></content>
      <categories>
        <category>Redis源码分析</category>
        <category>dict</category>
      </categories>
  </entry>
  <entry>
    <title>golang中，调用包中函数总是出现cannot refer to unexported name xxx</title>
    <url>/2020/01/31/golang%E4%B8%AD%EF%BC%8C%E8%B0%83%E7%94%A8%E5%8C%85%E4%B8%AD%E5%87%BD%E6%95%B0%E6%80%BB%E6%98%AF%E5%87%BA%E7%8E%B0cannot%20refer%20to%20unexported%20name%20xxx/</url>
    <content><![CDATA[<p>今天学习了golang的package编写，但是在调用package中的函数时总是出现问题：
&gt; cannot refer to unexported name xxx &gt; undefined xxx</p>
<p>找了好久都没有发现问题，一直纠结于目录结构和import包的方式，结果发现问题在于<strong>golang中，导出函数名称必须首字母大写。</strong></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>golang数字运算的注意事项</title>
    <url>/2020/02/15/golang%E6%95%B0%E5%AD%97%E8%BF%90%E7%AE%97%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>在学习golang时，遇到了这样的问题： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">float64</span> = <span class="number">9.9</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">fmt.Println(a / (b * <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">invalid operation: a / (b * 9) (mismatched types float64 and int)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
出现这样的问题是因为golang在这方面和C++的不同。 <span id="more"></span>
golang中有两种基本的数字类型：整数型和浮点型。不光如此，如果一个数是常量或者是字面类型，那么它还要与定义过的变量加以区分。例如：
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这几种都是未定义的“字面型数字”</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100.1</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这几种都是定义过的“变量”</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> d <span class="type">float64</span> = <span class="number">10.1</span></span><br></pre></td></tr></table></figure></p>
<p>为什么要区分上面，这是因为它们在进行基本运算的时候是有区别的。</p>
<ol type="1">
<li><p>对于字面型数字和字面型数字的运算，规则和C++相同的：</p>
<ul>
<li>如果运算符左右两侧都是整数型或都是浮点型，那么运算结果就是原类型。例如：
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ = <span class="number">10</span> / <span class="number">3</span>	<span class="comment">// 结果是整数3</span></span><br><span class="line">_ = <span class="number">10.0</span> / <span class="number">3.0</span>	<span class="comment">// 结果是浮点数3.333333333...</span></span><br></pre></td></tr></table></figure></li>
<li>如果一个是整数型，一个是浮点型，那么运算结果就是浮点型。例如：
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ = <span class="number">10</span> / <span class="number">3.0</span>	<span class="comment">// 结果是浮点数3.333333333...</span></span><br></pre></td></tr></table></figure>
也就是说，如果运算符两侧有“字面”的浮点数，那么结果就是浮点数。</li>
</ul></li>
<li><p>对于字面型数字和变量的运算：
运算时会将字面型数字转换成变量的类型再进行运算。如果无法转换（字面浮点型转化成整数型），就编译错误。例如：
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">float64</span> = <span class="number">3.0</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">_ = <span class="number">10</span> / a	<span class="comment">// 结果是浮点数3.333333333...，运算过程是字面的10转化成浮点型，相当于10.0 / 3.0</span></span><br><span class="line">_ = b / <span class="number">3.3</span>	<span class="comment">// 会抛出错误“constant 3.3 truncated to integer”，因为字面的3.3无法转换成整数型</span></span><br></pre></td></tr></table></figure></p>
<p>这里注意一个特例，转换只是追求量相等，可以表示相等的量就可以转换。例如：
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">_ = a / <span class="number">3.0</span>	<span class="comment">// 字面3.0可以用整数型的3表示，所以可以转换，结果是整数型3</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>对于变量和变量的运算：
运算符两侧必须均为浮点型或者均为整数型。例如： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span> = <span class="number">11</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">float64</span> = <span class="number">3.2</span>, <span class="number">3.3</span></span><br><span class="line">_ = a / b <span class="comment">// 可以编译通过</span></span><br><span class="line">_ = c / d <span class="comment">// 可以编译通过</span></span><br><span class="line"></span><br><span class="line">_ = a / c <span class="comment">// 编译失败，因为运算符两侧一个是float64，一个是int。“invalid operation: a / c (mismatched types int and float64)”</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>noexcept关键字的使用</title>
    <url>/2018/09/30/noexcept%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在C++11中，引入了noexcept关键字，用来修饰可以保证不会发生异常的函数。
<span id="more"></span>
关于noexcept，它可以优化函数。优化器在函数执行结束时，不一定就释放运行栈和所有函数中的对象。因为已经确保了这个函数不会抛出异常，所以优化器认为释放运行栈和对象不会发生异常，也就不用立即释放。如果使用的是C++98的throw()作为函数没有异常的修饰符的话，就不会进行这样的优化。</p>
<p>在C++11中有一个很自然的优化方法，就是将vector的复制改成移动。例如:push_back函数。在C++98中，这个函数会将参数进行复制。而在C++11中，它会在移动时不会出错的情况下进行移动，如果移动可能会出现异常的情况下，它就会采用复制进行。也就是：如果可以移动就移动，不能移动就复制。这样做法的前提：移动不会出错，就是由noexcept来保证的。</p>
<p>如何做到有条件的noexcept呢？请看下面的一段示例: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapEle</span><span class="params">(T ele1, T ele2)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T (&amp;a)[N], T (&amp;b)[N])</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(swapEle(*a, *b)))</span></span>;</span><br></pre></td></tr></table></figure>
这是一段用于交换数组元素的代码。在这段代码使用了有条件的noexcept。
在swap函数中，当T为Widget时，如果要判断swap函数是不是noexcept，就要判断先swapEle这个函数当参数是两个指向Widget对象的指针时是不是noexcept来判断swap是不是noexcept。也就是用了这样一种方法，使得push_back等函数可以通过判断参数对象的move函数是不是noexcept来判断移动操作是否可能会导致异常，从而判断push_back使用移动还是复制。</p>
<p>另外还有一种叫做异常中性函数(exception-neutral
function)。这种函数它本身不产生异常，而是它要调用的函数可能产生异常，这种异常通过类似于链式的传递，使得调用异常中性函数的函数可能会收到异常。对于这种函数，是不建议使用noexcept的。因为当异常中性函数抛出了来自它正调用的函数的异常时，又根据它的noexcept，导致程序会发生未定义行为。</p>
<p>还有一种叫做宽合约函数(wide contract function)和窄合约函数(narrow
contract
function)。这两种函数的定义是根据它们的使用范围和参数来定义的。宽合约函数的使用是没有前提条件的，它对参数没有条件，并且永远不会出现未定义行为。这种函数如果不会发生异常，建议使用noexcept。而窄合约函数，则是有前提条件的。比如说，对于某个函数的std::string参数要求长度是1024个字符以下。如果string超过1024，最好的方法是抛出异常，告诉用户string超过了前提。但是如果你使用了noexcept，又不能抛出异常，这时就没有好方法告知用户非法使用了这个函数。所以对于窄合约函数，即使它在前提条件内是非常完美的，也不建议使用noexcept。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>override关键字的使用</title>
    <url>/2018/09/28/override%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在C++11中新引入了关键字override。这个关键字用来声明子类中的方法是重写(override)基类中的相应方法。
<span id="more"></span>在C++98中，发生重写的条件如下:</p>
<ul>
<li>基类的方法必须是virtual</li>
<li>基类函数名和子类函数名必须相同，析构函数除外</li>
<li>基类函数的参数和子类函数的参数必须相同</li>
<li>基类和子类函数的const必须一致</li>
<li>返回类型和异常指示必须相同</li>
</ul>
<p>在C++11中，我们还添加了一个条件： <strong>引用修饰词(reference
qualifiers)必须一致。</strong>引用修饰词是用来定义当前函数适用于当前对象是左引用还是右引用时，从而选择重写方式。下面举一个例子:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>; <span class="comment">// 当*this为左值时调用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>; <span class="comment">// 当*this为右值时调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>; <span class="comment">// 一个工厂方法用来生成右值的Widget对象</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">w.<span class="built_in">doWork</span>(); <span class="comment">// 调用Widget::doWork&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">makeWidget</span>().<span class="built_in">doWork</span>(); <span class="comment">// 调用Widget::doWork &amp;&amp;</span></span><br></pre></td></tr></table></figure>
接下来具体回到override的使用上。override的存在是为了防止不满足重写条件的函数被当成重写函数。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp; <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
如果Derived的成员方法不满足重写条件，但是编写者认为是重写，并且标注了override关键字，编译器则会进行检查，是否满足重写条件，以此防止意外发生。这也就是override的存在的理由。
另外，在C++98中是不存在override这个关键字的，如果某个地方使用了override关键字，例如:变量名、函数名等，但是又将代码改成了C++11风格，这个override是不会影响编译的。因为只有override在作为成员函数修饰词的时候才会被编译器认为是使用了C++11的新关键词，否则就当做一般字符串处理。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>sds数据结构分析</title>
    <url>/2018/04/10/sds%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>sds是redis中用来存储动态字符串的数据结构。<span id="more"></span>其利用了五种容量不一的数据结构存储字符串数据。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr5 &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">	<span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr8 &#123;</span><br><span class="line">	<span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">	<span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">	<span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr16 &#123;</span><br><span class="line">	<span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">	<span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">	<span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr32 &#123;</span><br><span class="line">	<span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">	<span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">	<span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) sdshdr64 &#123;</span><br><span class="line">	<span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">	<span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">	<span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
五种数据结构大同小异。除了sdshdr5以外都有len、alloc、flags以及一个buf数组。</p>
<p>除去sdshdr5的其余四种数据结构，每种数据结构的前三个成员变量包含了数据的信息，称之为header。
根据注释可以很容易明白：len是结构体中buf的已用长度；alloc是申请的buf的空间大小；flags的低三位存放了sds的类型，高五位则是未使用的空间，没有任何的意义。flags的低三位的数据与SDS_TYPE_MASK（值为7）的与运算可以得知当前sds的类型，具体什么类型参见下方宏定义：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4</span></span><br></pre></td></tr></table></figure></p>
<p>对于sdshdr5的数据结构，它的flags成员变量的低三位全为空，用来与SDS_TYPE_MASK（值为7）的与运算得到0来表示这是一个sdshdr5的数据结构，高五位却是有意义的，意义和其它数据结构的len是一样的，用来表示buf的已使用长度。</p>
]]></content>
      <categories>
        <category>Redis源码分析</category>
        <category>sds</category>
      </categories>
  </entry>
  <entry>
    <title>shared_ptr的使用</title>
    <url>/2018/10/09/shared_ptr%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>前面讲到过unique_ptr的使用，它对指向的对象是有拥有权的，也就是说，unique_ptr被销毁，那么指向的对象也销毁，并且指向的对象不可共享。但是有时候我们需要对指向的对象进行共享，这时候就要用到C++11中另外一个智能指针--shared_ptr了。
<span id="more"></span></p>
<h1 id="基本介绍">基本介绍</h1>
<p>shared_ptr的原则很简单，就是当指向的对象没有其它shared_ptr需要访问，就把指向的对象销毁。它的实现是依赖于一个引用计数器，记录了当前有多少没有销毁的shared_ptr指向这个对象。因此，shared_ptr的大小和unique_ptr不同，shared_ptr因为这个引用计数器而稍微大一些，准确地说是两倍于普通指针的大小，两个普通指针一个指向被指向的对象，一个指向引用计数器（准确的说应该是控制块Control
Block，后面会说）。对于这个引用计数器，当有新的shared_ptr指向了某个对象，则引用计数器就加一。如果某个shared_ptr销毁了，则引用计数器减一，并且检查，是否引用计数器为0，若为0，则代表没有其它的shared_ptr指向这个对象，因此就将这个对象销毁。
另外对于引用计数器的操作是原子的。这确保了在多线程中shared_ptr的线程安全。移动构造的shared_ptr不会引起对应的引用计数器加一，正也因为移动构造的shared_ptr因为不对引用计数器进行加减，所以往往这个操作要快于复制构造的shared_ptr。</p>
<h1 id="自定义销毁过程">自定义销毁过程</h1>
<p>和unique_ptr一样，shared_ptr可以自定义销毁过程。但是shared_ptr不需要将销毁过程的类型作为它自己类型的一部分，也就是不需要在模板参数中定义销毁过程的类型。代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteFunc</span><span class="params">(Widget *pw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">delete</span> pw;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Widget object deleted!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> customDeleter = [](Widget *pw) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> pw;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Widget object deleted!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw1</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter)</span></span>;</span><br><span class="line">	<span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(<span class="keyword">new</span> Widget, deleteFunc)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
和unique_ptr不同，不论销毁过程是是函数还是函数对象都不会使shared_ptr变大。这是因为shared_ptr通过两个指针，一个指向被指向的对象，另一个指向一个控制块，这个控制块中存放了引用计数器(reference
count)以记录被引用次数、弱计数器(weak
count)以及其它的额外数据，这个额外数据就包括了自定义的销毁过程以及空间分配器等。</p>
<h1 id="使用shared_ptr的建议">使用shared_ptr的建议</h1>
<p>shared_ptr不知道是否有其它的shared_ptr指向了和自己一样的对象，所以对于shared_ptr，要知道如下的规则:
*
使用std::make_share是会新建一个控制块。所以使用这个函数的对象一定是要第一次被shared_ptr指向。
*
从一个对对象有拥有权的指针(如unique_ptr或者auto_ptr)转换成shared_ptr时，是会新建控制块的。因为有拥有权的指针是没有控制块的(unique_ptr可以参见<a
href="/2018/10/07/unique_ptr的使用/">unique_ptr的使用</a>)。所以对于构造从这种指针转换来的shared_ptr时，是会新建一个控制块的。
*
从传统的指针转换来的shared_ptr是有控制块的。如果你想创建一个已经shard_ptr指向已经拥有控制块的对象时，你应该是使用shared_ptr或者weak_ptr来创建，而不是一个传统指针。使用shared_ptr或者weak_ptr构造shared_ptr时，是不会新建控制块的。</p>
<p><strong>用一个传统指针构造多个shared_ptr也是非常不好的。</strong>因为这样会构造多个控制块，当其中一个控制块的引用计数器为0时，就会销毁指向的对象，这样其它指向这个的shared_ptr就会成为野指针。这样会导致未定义行为。例如下面的代码，这样做是非常不好的：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> Widget;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw1</span><span class="params">(pw)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(pw)</span></span>;</span><br></pre></td></tr></table></figure>
这样做就会导致有一个Widget对象有两个控制块。所以你要避免使用传统的指针构造shared_ptr，使用std::make_shared是一种替代方式，但是使用std::make_shared在需要使用自定义的销毁过程时则没有办法自定义销毁过程。另外还可以使用new构造新的对象作为shared_ptr的构造函数的参数。对于复制shared_ptr也可以使用一个shared_ptr作为构造的参数。</p>
<p>不光传统指针构造shared_ptr可能会导致一个对象多个控制块，对this的不正确使用也可能导致一个对象多个控制块。下面代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			processedWidgets.<span class="built_in">emplace_back</span>(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> pw1 = <span class="keyword">new</span> Widget;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(pw1)</span></span>;</span><br><span class="line">	pw1-&gt;<span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
shared_ptr首先肯定不知道是不是有别的shared_ptr指向要指向的对象，所以每次构造shared_ptr的时候都要新建控制块。在Widget的成员函数process中，它想processedWidgets中插入了一个shared_ptr，指向pw1的对象。然后再main函数中的pw2又以pw1的对象为指向的对象，并且pw2不知道已经在processedWidget中有一个shared_ptr了，这样就导致两个shared_ptr都有各自的控制块，并且都指向同一个对象，所以造成了错误。
要解决这样的问题，可以使用std::enable_shared_from_this类，这个类中的shared_from_this方法可以使其继承类完成类似于上述的操作，并且不会造成一个对象多个控制块的问题。代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			processedWidgets.<span class="built_in">emplace_back</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> pw1 = <span class="keyword">new</span> Widget;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(pw1)</span></span>;</span><br><span class="line">	pw1-&gt;<span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个类中的shared_from_this方法会寻找this的控制块，如果当前对象的控制块还不存在，那么就会导致未定义行为。所以为了保证不发生这种未定义行为，上述代码我们还会进行改进:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">static</span> std::shared_ptr&lt;Widget&gt; <span class="title">create</span><span class="params">()</span> <span class="comment">// factory method</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">auto</span> pw = <span class="keyword">new</span> <span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(pw);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			processedWidgets.<span class="built_in">emplace_back</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br><span class="line">		<span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> pw = Widget::<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line">	pw-&gt;<span class="built_in">process</span>(); </span><br><span class="line">	<span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(pw)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用工厂方法，强制将新构造的对象在工厂方法中返回一个shared_ptr，使得Widget的对象从诞生起就有shared_ptr指向。这样就不会发生shared_from_this在执行时出现this对象没有控制块导致的未定义行为。</p>
<p>shared_ptr中使用了原子的引用计数器，而控制块比你想象的要复杂得多，例如使用了虚函数保证指向的对象能真正删除等。这些操作看上去都会导致shared_ptr比传统的指针慢很多，但是实际上不用担心，原子的引用计数器操作使用了特殊的机器指令，只要一条指令就能完成对其的操作，对于调用虚函数销毁被指向的对象，这个操作对于一个被指向的对象来说只会执行一次。</p>
<p>当你不知道指针和对象的关系时，使用unique_ptr通常是更好的，因为unique_ptr可以方便的转换成shared_ptr，并且它更像传统的指针。</p>
<p>shared_ptr和unique_ptr有一个很大的区别就是shared_ptr不支持数组操作，它没有[]操作，在默认的销毁过程中没有对数组的delete[]操作。所以建议的方法是使用std::array这类的内建数组代替传统数组。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>size_t类型导致的异常</title>
    <url>/2018/04/12/size_t%E7%B1%BB%E5%9E%8B%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>《深入理解计算机系统》有这样一道题: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strlonger</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(t) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这是一个用来判断s是否比t字符串长的一个函数。但是这个函数是有bug的。
<span id="more"></span></p>
<p>第一眼我是看不出bug在哪里，后来看了解释： strlen(char
*s)这个函数的返回值是size_t类型的，size_t是一种unsigned
int，所以当strlonger中的s小于t时，它们相减值也是unsigned，这样只有当两者长度相等时，strlonger函数才可能返回0。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>weak_ptr的使用</title>
    <url>/2018/10/12/weak_ptr%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>前面讲到，指针对对象如果拥有权，我们可以使用unique_ptr；如果指针指向的对象可以分享，那么我们使用shared_ptr。但是在实际上因为shared_ptr对于指向的对象是不知情的，因此就会造成对象已经销毁但是shared_ptr不知情的情况。为了规避这种情况，我们可以使用weak_ptr来判断指向的对象是否已经被销毁。
<span id="more"></span> # 使用方法</p>
<p>使用示例代码如下: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::<span class="built_in">make_shared</span>&lt;Widget&gt;(); <span class="comment">// make_shared的用法</span></span><br><span class="line"><span class="function">std::weak_ptr&lt;Widget&gt; <span class="title">wpw</span><span class="params">(spw)</span></span>; <span class="comment">// 初始化weak_ptr，使用shared_ptr作为参数</span></span><br><span class="line"></span><br><span class="line">spw = <span class="literal">nullptr</span>; <span class="comment">// spw指向空指针，那么原来的spw指向的对象就销毁了，也就是wpw现在指向了一个已经销毁的空间</span></span><br><span class="line"><span class="keyword">if</span>(wpw.<span class="built_in">expired</span>()) <span class="comment">// wpw是否指向了一个销毁的对象</span></span><br><span class="line">&#123; </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果想让检测是否存在并如果存在就访问指向的对象的操作拥有原子性，我们可以使用lock函数。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;Widget&gt; spw1 = wpw.<span class="built_in">lock</span>(); <span class="comment">// 如果wpw的对象应被销毁，那么就返回空指针(nullptr)。否则就返回wpw指向的对象</span></span><br></pre></td></tr></table></figure></p>
<h1 id="使用场景">使用场景</h1>
<p>在《Effective Modern
C++》这本书当中，给出了两个使用shared_ptr的例子。一个是缓存池，一个是观察者模式。</p>
<p>缓存池的应用如下: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetID id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> std::unordered_map&lt;WidgetID, std::weak_ptr&lt;<span class="type">const</span> Widget&gt;&gt; cache; <span class="comment">// 缓存池，静态类型</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> objPtr = cache[id].<span class="built_in">lock</span>(); <span class="comment">// 如果缓存存在，objPtr就是一个指向缓存的shared_ptr，否则就是指向nullptr</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!objPtr)</span><br><span class="line">	&#123;</span><br><span class="line">		objPtr = <span class="built_in">loadWidget</span>(id); <span class="comment">// 如果缓存不存在就获取Widget，并且存到缓存中</span></span><br><span class="line">		cache[id] = objPtr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中，我们cache中存储的是一个weak_ptr。因为考虑到调用者在获取到对缓存的访问后可能会销毁缓存，因此我们使用weak_ptr来判断缓存表中的指针是否指向可用对象。</p>
<p>另外观察者模式中，subject中存放了observer的指针，当subject的状态发生变化，它就会调用observer的相关通知函数，observer是通过指针存放在subject中。而subject对于observer的是否存在可以通过weak_ptr来判断。</p>
<p>对于如下的关系模型，我们也可以使用weak_ptr <img
src="/images/weak_ptr的使用/1.png" />
在上面模型中，A-&gt;B和C-&gt;B都使用了shared_ptr，这时如果B-&gt;A也要一个指针，这个指针的类型改用什么类型呢？
我们来讨论： *
如果使用传统的指针:当A-&gt;B销毁了,这时B中存放的是一个指向A的野指针。 *
如果使用shared_ptr:当A-&gt;B销毁了，因为还存在C-&gt;B，所以B不会被自动销毁，所以B同样存在一个指向A的野指针。
*
如果使用weak_ptr:如上面所说，A-&gt;B销毁了，A已经不存在了，这时存在的是一个B-&gt;A的weak_ptr，它因为A不存在而成为了nullptr，所以weak_ptr合适。</p>
<h1 id="weak_ptr的控制块">weak_ptr的控制块</h1>
<p>weak_ptr拥有和shared_ptr一样的控制块，但是weak_ptr不会影响控制块的引用计数，并且还拥有一个弱计数器(weak
count)记录了有多少weak_ptr指向了这个对象。通过这两个计数器，我们可以做到判断指向的对象是否被销毁。
当一个shared_ptr被销毁，那么引用计数会减一，这时如果引用计数变为0，它就会检查弱计数器是否为0，如果为0，那么就销毁这个对象与控制块。如果不为0，就会不销毁控制块，至于对象是否销毁，我们会在<a
href="/智能指针中make_xxx函数和new的使用.html">智能指针中make_xxx函数和new的使用</a>进行讨论。
每次使用weak_ptr时，weak_ptr会检查是否引用计数为0，为0那么就会返回nullptr。如果不为0就返回对象。weak_ptr在销毁时会检查引用计数和弱计数器是否同时为0，如果同时为0，那么就销毁控制器（和对象）。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>unique_ptr的使用</title>
    <url>/2018/10/07/unique_ptr%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在C++11中，智能指针特性中有一个最方便使用的指针:unique_ptr。这个指针的作用就是用来表示指针对某个对象的拥有权。也就是这个智能指针对象的存亡是和指向对象的存亡是捆绑的。因为这个指针是拥有指向的对象的，当智能指针销毁了，那么它指向的对象也销毁。用户因此也不用考虑动态构造的对象的销毁问题，智能指针已经帮我们包办了。
又因为unique_ptr是对于一个对象有拥有权，所以它是没有办法复制的，只能通过移动的方式传递。当一个智能指针将指向的对象移动给另一个智能指针，那么原只能指针就指向了nullptr了。
另外，这个unique_ptr，它的大小和传统指针是一样的。它是传统指针的一个包装类(wrapper)，所以它很小巧的。
<span id="more"></span>
对于指针对象的销毁，unique_ptr拥有一个默认的销毁方法。但是如果用户想自定义销毁过程，例如在销毁的时候写到日志中一段话，那么就可以使用unique_ptr提供的自定义销毁过程，这个过程可以是函数、lambda表达式以及函数对象等：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDestoryLog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Something is destorying!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delWidgetFunc</span><span class="params">(Widget* w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printDestoryLog</span>();</span><br><span class="line">	<span class="keyword">delete</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> delWidget = [](Widget* w) &#123; </span><br><span class="line">		<span class="built_in">printDestoryLog</span>();</span><br><span class="line">		<span class="keyword">delete</span> w;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(delWidget)</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="literal">nullptr</span>, delWidget)</span></span>; <span class="comment">// 使用lambda表达式作为销毁过程</span></span><br><span class="line">	<span class="function">std::unique_ptr&lt;Widget, <span class="title">void</span><span class="params">(*)</span><span class="params">(Widget*)</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Widget, delWidgetFunc)</span></span>; <span class="comment">// 使用函数作为销毁过程</span></span><br><span class="line">	ptr1.<span class="built_in">reset</span>(<span class="keyword">new</span> Widget); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面使用了自定义的销毁过程，销毁过程的参数是一个普通的指针。销毁过程中要使用delete关键字销毁普通指针，也就是智能指针类中维护的普通指针。另外在unique_ptr中要说明销毁过程的类型（lambda表达式还是一个函数，函数用函数指针代替），然后在构造时指明销毁过程。
《Effective Modern
C++》书中的推荐使用lambda表达式作为销毁过程，并且是无捕获的lambda表达式，不光是精简的原因。使用了自定义销毁过程的unique_ptr，往往会比普通指针大一些，通常是1-2个字。对于函数作为销毁过程，unique_ptr的大小取决于这个函数对象中存储了多少状态（类的属性）。而没有捕获的lambda表达式中则没有任何状态，自然也就不会导致unique_ptr的变大。</p>
<p>对于unique_ptr，它还有一个很实用的特点，就是它可以很轻易的转化成shared_ptr，它们之间是可以隐式转换的。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">void</span><span class="params">(*)</span><span class="params">(Widget*)</span>&gt; <span class="title">widgetFactory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;Widget, <span class="built_in">void</span>(*)(Widget*)&gt;(<span class="keyword">new</span> <span class="built_in">Widget</span>(), delWidgetFunc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;Widget&gt; sharedPtr = <span class="built_in">widgetFactory</span>();</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>ziplist的联级更新（cascade update）</title>
    <url>/2018/05/27/ziplist%E7%9A%84%E8%81%94%E7%BA%A7%E6%9B%B4%E6%96%B0%EF%BC%88cascade%20update%EF%BC%89/</url>
    <content><![CDATA[<p>前面在讲ziplist中压缩节点时，提到过其中有一个数据量叫prevlen，这个是存储了前一个节点的大小，它的长度是根据前一个节点实际大小。如果前一个节点大小在254位以下，则prevlen为1字节；如果前一个节点大小大于等于254位，则prevlen为5字节，并且第1字节数据为254，第2-5字节数据为实际大小。</p>
<p>另外ziplist还支持任意位置插入节点，这个是通过ziplistInsert函数实现的，具体可以自行研究其实现。</p>
<p>这时考虑一个极端情况：有一个压缩表有entry1,entry2,entry3节点，大小分别为250位，250位,250位。然后我在entry1前插入一个节点entry0，大小为254位。此时entry1的prevlen就要更新，从1位变成了5位，此时entry1的大小变成了254位。因为entry1大小的改变，entry2的prevlen也要改变，变成5位...如此连锁更新下去。这就叫ziplist的联级更新(cascade
update)。
它的具体实现是在ziplistCascadeUpdate函数中，大概的流程就是判断当前节点的prevlen能不能放得下上一个节点的大小，能就退出联级更新，否则就进行扩大操作，直到最后一个节点。具体写法请自行查看相应代码。</p>
]]></content>
      <categories>
        <category>Redis源码分析</category>
        <category>ziplist</category>
      </categories>
  </entry>
  <entry>
    <title>使用初始化捕获将对象移动到lambda表达式中</title>
    <url>/2018/11/11/%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8D%95%E8%8E%B7%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8%E5%88%B0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD/</url>
    <content><![CDATA[<p>有时，你既不想使用按值捕获，也不想使用按址捕获。例如：你有一个只可以移动的对象（std::unique_ptr或者std::future等），你想把它移动进lambda表达式中，C++11中没有办法实现这些，而如果复制这些对象又需要大量的消耗，移动显然是最佳选择。虽然C++14中支持直接将对象移动到表达式中，可是C++11没有办法实现，这时应该怎么办？
<span id="more"></span>
缺少移动捕获一直被认为是C++11的短板。这个短板在C++14中得到了弥补，但是C++标准委员会选择了其它的方法。在C++14中，引入了一个新的、更灵活的捕获机制，这个新的机制不光只有移动捕获，它被被称为<strong>初始化捕获(init
capture)</strong>。除了默认捕获模式捕获，C++11中其它可以做的事情，初始化捕获都可以做到，而且还可以做更多。对于默认模式捕获在之前我们说过，我们应该尽量不使用默认捕获模式（请参看：<a
href="/2018/11/09/避免使用lambda的默认捕获模式/">避免使用lambda的默认捕获模式</a>）。</p>
<p>使用初始化捕获，你需要指定两个东西:</p>
<ul>
<li>在lambda中的数据成员的名称。</li>
<li>用于初始化lambda中数据成员的表达式。</li>
</ul>
<p>下面举例如何通过初始化捕获移动一个std::unique_ptr到一个lambda表达式中:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isValidated</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isProcessed</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">isArchived</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;(); <span class="comment">// 使用std::make_unique创建一个Widget</span></span><br><span class="line"></span><br><span class="line">… <span class="comment">// 配置pw指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">move</span>(pw)] <span class="comment">// 注意没有写参数的括号</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();</span><br><span class="line">&#125;;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">上面代码中“pw = std::<span class="built_in">move</span>(pw)”部分就是初始化捕获。等号左侧是表达式中数据成员的名称，这个是由你自由决定的。等号右侧是初始化表达式，用于初始化数据成员。等号左右两侧的作用域是不同的，左侧的作用域在lambda表达式中，而右侧的作用域在表达式定义的区域。在上面的例子中，等号左侧的pw指的是lambda中的数据成员，而右侧则是在lambda表达式上方定义的pw。因此“pw = std::<span class="built_in">move</span>(pw)”意味着在lambda中创建一个数据成员pw，并且用std::move一个本地变量的pw以初始化这个数据成员。</span><br><span class="line"></span><br><span class="line">在lambda代码块中使用的pw就是lambda的数据成员。注释中的“配置pw指针”的意思就是在Widget通过std::make\_unique创建之后，在std::unique\_ptr被lambda捕获之前，这个Widget对象可以用任意方式修改。如果不需要配置这个Widget对象，也就是这个Widget在被使用std::make\_unique创建之前的状态就已经是适合被lambda捕捉的的状态了，这个本地变量pw就没有必要存在了，表达式可以写成这样:  </span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;()]</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这个例子可以表明C++14的“捕获”是从C++11的“捕获”普遍化而来的，因为在C++11中，捕获一个表达式的结果是不可能的。因此，“初始化捕获”的另一个名字叫做普遍化的lambda捕获(generalized
lambda capture)。</p>
<p>但如果你的编译器缺乏对C++14的支持，这时该怎么实现初始化捕获的行为呢？你首先要记住，lambda表达式只是简单地生成了一个类和这个类的对象。没有什么是lambda能做而你不能用别的方式做到的。例如下面的一段C++14的代码:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IsValAndArch</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">using</span> DataType = std::unique_ptr&lt;Widget&gt;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">IsValAndArch</span><span class="params">(DataType&amp;&amp; ptr)</span></span></span><br><span class="line"><span class="function">			:pw(std::move(ptr)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		DataType pw;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">IsValAndArch</span>(std::<span class="built_in">make_unique</span>&lt;Widget&gt;());</span><br></pre></td></tr></table></figure></p>
<p>这明显不如lambda表达式来得简洁，但是这可以很好地在C++中实现移动初始化其中的数据成员。</p>
<p>如果你坚持想在C++11中使用lambda表达式，移动捕获可以使用下面的方式模拟：</p>
<ul>
<li>将要被移动捕获的对象通过std::bind变成函数对象以捕获<br />
</li>
<li>给lambda表达式一个指向要被捕获对象的引用</li>
</ul>
<p>如果你熟悉std::bind，代码就非常简单了。</p>
<p>假设你想要创建一个本地的std::vector，然后向其中放入合适的值，并将其移动到lambda表达式中。在C++14中，代码很简单:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data; <span class="comment">// 将要移动到lambda中的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [data = std::<span class="built_in">move</span>(data)] <span class="comment">// C++14的初始化捕获</span></span><br><span class="line">&#123; <span class="comment">/* 使用data */</span> &#125;;</span><br></pre></td></tr></table></figure> 等价的C++11代码（使用了std::bind）如下: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">double</span>&gt; data;</span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">	[](<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; data) <span class="comment">// C++11中模拟使用初始化捕获</span></span><br><span class="line">	&#123; <span class="comment">/* 对data的使用 */</span> &#125;,</span><br><span class="line">	std::<span class="built_in">move</span>(data)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
和lambda表达式一样，std::bind生成了函数对象。我们这个有std::bind返回来的函数对象为绑定对象(bind
object)。std::bind的第一个参数是一个可调用的对象，后面依次更正传给这个可调用对象的参数。</p>
<p>一个绑定对象包含了所有传进std::bind参数的副本。对于每一个左值参数，在绑定对象中的相关参数被复制构造；对于每一个右值参数，它们会被移动构造。在这个例子中，第二个参数是一个右值（std::move的结果），因此data是被移动构造到绑定对象中去的。因为上述代码移动一个右值到绑定对象中，这个移动构造是模拟移动捕获的关键点，解决了C++11的lambda无法将右值移动到lambda表达式。</p>
<p>当绑定对象是可调用的（例如定义了函数调用操作符），那么绑定对象存储的参数就被传给可调用对象。在上面的例子中，当func（绑定对象）被调用，func中移动构造的data的副本就作为一个参数传给了lambda。</p>
<p>由std::bind绑定完的绑定对象就和C++14中的lambda一样，因为参数已经被添加到了模拟的移动捕获对象中了，所以除了绑定对象不需要参数data外没有不同之处。参数在绑定对象中是一个左值引用，引用了data的副本（尽管这个表达式初始化data是用右值“std::move(data)”初始化的，但是data副本本身是一个左值），lambda内部的data其实是data的副本。</p>
<p>一般来说，由lambda生成的类的括号操作符（operator()）成员函数是const类型的，因此lambda的所有成员变量在lambda中均为const，是受到保护不可以被修改的。而在绑定对象中，移动构造的副本data不是const，std::bind返回的类型的括号操作符不是const的。如果lambda被定义成mutable，括号操作符（operator()）将不会被定义成const，这时就不会将lambda的成员变量定义成const了，因此在使用std::bind时使用mutable也是合理的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">	[](std::vector&lt;<span class="type">double</span>&gt;&amp; data) <span class="keyword">mutable</span></span><br><span class="line">	&#123; <span class="comment">/* 对data的使用 */</span> &#125;,</span><br><span class="line">	std::<span class="built_in">move</span>(data)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
因为绑定对象存储的是所有传递给std::bind的参数的副本。在我们的例子中，绑定对象包含了一个lambda表达式的副本，因此表达式的生命周期和绑定对象是一样的。这非常重要，因为这意味着只要表达式存在着，包含着模拟移动捕获的对象的绑定对象就也一定存在。</p>
<p>如果这是你第一次接触到std::bind，你可能要纠结于C++11的语法，但是有几点你需要明确：</p>
<ul>
<li>C++11中无法使用初始化捕获的lambda，但是可以通过std::bind将属于移动到lambda中。</li>
<li>在C++11中模仿移动捕获的步骤是：移动构造一个对象到绑定对象中，然后通过引用传递移动构造的对象到lambda表达式中。
因为绑定对象的生命周期和lambda表达式是一样的，所以可以把绑定对象的中的元素看成是在lambda中的。</li>
</ul>
<p>再举一个std::bind模拟移动捕获的例子。例如对于C++14的代码:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;()]</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 用C++11中模拟:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">	[](<span class="type">const</span> std::unique_ptr&lt;Widget&gt;&amp; pw)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> pw-&gt;<span class="built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="built_in">isArchived</span>();</span><br><span class="line">	&#125;,</span><br><span class="line">	std::<span class="built_in">make_unique</span>&lt;Widget&gt;()</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>当然上面的代码对于有经验的程序员是不会写出的，我这里只是展示在C++11lambda的限制下如何使用std::bind，因为之后我们说明，要使用lambda表达式替换std::bind。但是在C++11中std::bind还是非常有用的，不过在C++14中初始化捕获和auto类型参数已经淘汰了这些。</p>
<p><strong>总结</strong></p>
<ul>
<li>使用C++14的初始化捕获以移动对象到lambda表达式中。<br />
</li>
<li>在C++11中们可以通过std::bind来模拟初始化捕获</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>几个完美转发失败的条件</title>
    <url>/2018/11/06/%E5%87%A0%E4%B8%AA%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%9D%A1%E4%BB%B6/</url>
    <content><![CDATA[<p>C++11中最醒目的功能之一就是完美转发。“完美”转发，它是完美的，但只有正确运用它才是完美的。
<span id="more"></span></p>
<p>在介绍如何正确使用完美转发之前，我们先来复习完美转发的含义。“转发”意味着一个函数将它的参数传递给另一个函数，目的是为了被转发的函数能接收和转发函数一样的参数。首先因为他们是从原来的调用者那里复制进去的，我们希望被转发的函数和转发函数使用相同的对象，故不可以使用传值的方式转发参数。又因为我们不希望调用者强制使用指针进行调用，因此指针也不可以。最后我们使用了引用的方式进行转发。</p>
<p>完美转发意味着我们不只是转发对象，我们还转发重要的特性：类型、左右值以及是否为const和volatile。在我们先前对于引用参数的观察中可以得出这样的结论，我们要使用全体引用，因为全体引用才能反映出转发参数的左右值情况。</p>
<p>让我们先来看看一段代码，里面定义了一个函数f，f函数被另一个函数转发，代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
转发函数就是这么个普通函数。fwd模板函数接收了任意类型的参数，并且无论fwd接收到了什么参数，它都将参数转发给了f。扩展开来说，转发函数就是参数可变的模板（不一定只是模板），因此接收任意数量的参数。fwd的可变参数的形式如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(std::forward&lt;Ts&gt;(params)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
类似代码可以在STL中的emplace函数、智能指针的工厂函数、std::make_shared和std::make_unique等中看到。</p>
<h1 id="转发失败的情况">转发失败的情况</h1>
<p>如果转发函数调用的和我们预期想象的不一样，那么我们就称这种情况为完美转发失败。
有几种情况会导致完美转发的失败:</p>
<h2 id="使用初始化列表">使用初始化列表</h2>
<p>假设被转发函数f定义如下: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span>;</span><br></pre></td></tr></table></figure>
在这种情况下，如果我们使用一个初始化列表调用f: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// &#123;1, 2, 3&#125;被隐式转换成了std::vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
但是如果把初始化列表传递给fwd: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// 编译未通过</span></span><br></pre></td></tr></table></figure>
这是因为使用初始化列表是完美转发会失败的一种情况。在直接调用f时，编译器会看调用处传递的参数以及f中定义的参数类型。编译器会比较调用处的参数和f定义的参数是否兼容，并且在需要的时候它们会互相转化。在上面的例子中，它们从{1,
2,
3}生成了一个临时的std::vecotr，以至于f的参数v有一个绑定的std::vector。当使用fwd完美转发调用f，编译器先对fwd参数的类型进行推断，然后将推断的类型和f定义的参数比较。这里调用fwd编译失败的原因就是template不会推断成std::initializer_list，将fwd的参数若声明为std::initializer_list<T>则可以解决问题。完美转发会在一下情况下失败:
1.
编译器无法推断类型：如果编译器无法推断fwd参数的一个或多个参数类型，将会编译失败。
2.
编译器将类型推断成了“错误”的类型：如果编译器将fwd的一个或多个类型参数推断“错误”，编译器会编译失败。“错误”指代的是fwd的实例化模板无法通过推断的类型通过编译，也就是说f没有办法使用fwd参数已经推断好的类型进行编译调用。这个歧义的根本原因是f是一个重载函数，而“不正确”的推断类型使得在fwd调用的重载的f和直接调用f的是不一样的函数。</p>
<p>在之前的auto类型的推测准则中我们说过auto可以将花括号初始化参数推断成std::initializer_list类型。所以我们还可以这样调用:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">fwd</span>(il);</span><br></pre></td></tr></table></figure></p>
<h2 id="空指针用0和null">空指针用0和NULL</h2>
<p>在<a
href="/2018/09/25/尽量使用nullptr替代0和NULL/">尽量使用nullptr替代0和NULL</a>中我们讲到，如果你使用了0和NULL作为一个空指针，并且作用到模板上时，类型推断将会推断为一个整型（通常就是一个int），而不是一个指针。因此0和NULL都不可以在完美转发中作为空指针参数传递。解决方法很简单，就是使用nullptr作为替代。</p>
<h2
id="使用了只需要定义的整型的static-const和constexpr类型数据">使用了只需要定义的整型的static
const和constexpr类型数据</h2>
<p>通常我们没有必要在类中定义一个整型的static
const或者constexpr类型的成员数据，声明其即可满足需求。这是因为编译器的常量传播（const
propagation）的优化特性，因此减少了额外开销的内存。例如考虑这样的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">static</span> <span class="keyword">constexpr</span> std::<span class="type">size_t</span> MinVals = <span class="number">28</span>; <span class="comment">// MinVals的声明</span></span><br><span class="line">&#125;; <span class="comment">// MinVals只有声明，没有定义</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; widgetData;</span><br><span class="line">widgetData.<span class="built_in">reserve</span>(Widget::MinVals);</span><br></pre></td></tr></table></figure>
在上面的代码中，我们使用Widget::MinVals指定widgetData的初始值，尽管Minvals没有定义，只有声明。编译器在缺失定义时仍然可以编译成功，它将28填充入所有称为MinVals的地方，虽然MinVals没有被实际存储起来，但却不会导致问题。但如果需要使用MinVals的地址（例如创建了一个指针指向了MinVals），MinVals将会需要实际的存储空间，这时如果如果没有MinVals的定义代码，上面的代码会在链接时出现错误。</p>
<p>基于上述，想象f（接收fwd函数转发的参数的函数）和fwd有如下声明:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">size_t</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
以MinVals为参数调用f时（如下所示），程序运行是正常的，因为编译器只是简单地用值替换了MinVals:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(Widget::MinVals); <span class="comment">// 编译结果和f(28)等价</span></span><br></pre></td></tr></table></figure>
当以MinVals为参数调用fwd时（如下所示），运行这个程序就不是那么顺利了:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(Widget::MinVals); <span class="comment">// 链接过程出错</span></span><br></pre></td></tr></table></figure> 代码可以编译，但是会在链接的过程中发生错误。
尽管在源码中没有任何地方使用了MinVals的地址，但fwd的参数是一个全体引用。引用在编译器生成的代码中，通常被当做指针来对待。在程序的二进制代码中，指针和引用通常是一个东西。正基于此，我们可以把引用理解成可以自动解引用的指针。而通过引用传递MinVals也就是和传递指针一样，因此就需要内存地址用于指针指向。以引用的方式传递整型的static
const和constexpr成员需要这些成员有定义。如果没有定义，通常会导致使用完美转发失败，而未使用完美转发的代码成功运行。
不过在实际的使用中，也有例外。引用不是一直被看做指针，而通过引用传递整型的static
const和constexpr成员也不是一直需要定义后才能使用完美转发。这个不展开，因为根据标准，通过引用传递MinVals需要定义，可是不是所有的编译器都采用了这一要求。所以能否不定义就使用引用传递取决于你的编译器和链接器。如果你的编译器可以，那么恭喜你，但是不建议你这样做，而是定义整型的static
const和constexpr成员。例如对MinVals，定义如下: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> Widget::MinVals;</span><br></pre></td></tr></table></figure>
注意定义不是重复初始化，不过如果你不用担心，如果你忘记了什么是定义，而是在应该定义和初始化的两个地方都使用了初始化，编译器会提示你。</p>
<h2 id="使用了重载的函数和模板的名称">使用了重载的函数和模板的名称</h2>
<p>假设有函数f（用于通过fwd转发参数调用的函数）可以通过传递函数作为参数来实现自定义的行为（例如定义callback函数）。假设这个被传递的函数参数的返回值是int，f可以被声明成:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*pf)(<span class="type">int</span>))</span></span>; <span class="comment">// pf = processing function</span></span><br></pre></td></tr></table></figure>
当然f的参数也可以声明成非指针，这样f的声明看上去就会是这样的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> pf(<span class="type">int</span>))</span></span>;</span><br></pre></td></tr></table></figure>
无论使用哪种格式声明f，我们先假设有一个重载函数processVal:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processVal</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure> 然后这样调用f: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(processVal); <span class="comment">// 可以编译成功并执行</span></span><br></pre></td></tr></table></figure>
f要求的参数是一个指向函数的指针，但是processVal不是一个函数指针，甚至不是一个函数，这是两个不同函数的名字，但是编译器知道那个processVal是被需要的：符合f参数的那个。因此编译器选择了参数为int的那个processVal，然后把它的地址传递了过去。
上面成功的原因就是f的定义让编译器知道哪个版本的processVal是需要的。而当fwd使用函数模板时，编译器没有太多的关于需要的类型的信息，因此就会导致编译器无法决定调用哪个重载函数:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(processVal); <span class="comment">// 错误！编译器不知道调用哪个processVal</span></span><br></pre></td></tr></table></figure>
如果传递的参数是一个函数模板名，这也会导致同样的问题。函数模板不代表某一个函数，而是许多函数:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">workOnVal</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function"></span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(workOnVal); <span class="comment">// 错误！无法确定使用模板的哪一个实例</span></span><br></pre></td></tr></table></figure></p>
<p>让fwd这样的完美转发函数接收重载函数名和模板名称作为参数的方法，就是手动指定希望转发的重载函数和实例化模板。例如，你可以创建一个指向和f参数同类型的函数指针，用processVal和workOnVal初始化这个指针，然后传个fwd这个指针:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ProcessFuncType = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line">ProcessFuncType processValPtr = processVal;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(processValPtr);</span><br><span class="line"><span class="built_in">fwd</span>(<span class="built_in">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal));</span><br></pre></td></tr></table></figure>
当然这需要你知道fwd转发的参数的类型。不过在文档中应该会写明完美转发函数的参数类型，毕竟完美转发函数是可以接收任意类型的，所以如果没有文档，调用者怎么知道需要什么参数呢？</p>
<h2 id="使用了位段bitfield">使用了位段(bitfield)</h2>
<p>最后一个可能导致完美转发失败的情况是使用了位段作为完美转发函数的参数。我们使用一个IPv4的头来举例查看这个情况是什么意思:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IPv4Header</span> &#123;</span><br><span class="line">	std::<span class="type">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">		IHL:<span class="number">4</span>,</span><br><span class="line">		DSCP:<span class="number">6</span>,</span><br><span class="line">		ECN:<span class="number">2</span>,</span><br><span class="line">		totalLength:<span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
如果f函数(被fwd转发的函数)声明使用参数std::size_t，并且使用IPv4Header中的totalLength来作为参数调用它:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::<span class="type">size_t</span> sz)</span></span>;</span><br><span class="line"></span><br><span class="line">IPv4Header h;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(h.totalLength);</span><br></pre></td></tr></table></figure>
当我们尝试使用fwd来转发参数h.totalLength时，事情就变得不同了:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fwd</span>(h.totalLength);</span><br></pre></td></tr></table></figure>
问题是fwd的参数是一个引用，h.totalLength是一个非const类型的位段。这看上去没什么问题，但是在C++标准中规定：非const引用不可以绑定一个位段。位段可能由机器字的任意部分组成（例如32位int的3-5位），有时就没有办法直接用地址指向这些东西。之前说过，指针和引用在底层是同一个东西，因此指针也没有办法指向位段。</p>
<p>如果想使用位段作为参数进行完美转发，有一个简单的方法，只要你发现参数是一个位段，然后你只用使用它值的副本。没有函数可以绑定一个引用到位段上，也没有函数可以用指针指向位段，所以我们对于参数为位段的函数只能使用传值的方式传参，当然还有一种你意想不到的，可以使用对const类型的引用。
在使用传值方式时，对函数的调用其实就是绑定了位段的一个副本值，然后使用一个整型对象（例如int）存储存储位段的值。而使用对const的引用时，这个引用不是绑定到位段，而是绑定到了一个普通的对象上，这个对象存储了复制后的位段的值。</p>
<p>传递位段到完美转发函数的关键点，就是要记住完美转发函数一直使用的是位段值的副本。你可以因此自行复制位段然后将这个副本传递给完美转发函数。例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对位段的值进行复制</span></span><br><span class="line"><span class="keyword">auto</span> length = <span class="built_in">static_cast</span>&lt;std::<span class="type">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwd</span>(length);</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<ul>
<li>完美转发在两种情况下转发失败：模板的类型推测失败；模板的类型推测错误。</li>
<li>使用了初始化列表、使用了0或NULL替代空指针、使用了整型的只声明的const
static成员、使用模板和重载函数名以及位段会导致重载失败。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>区别全体引用和右值引用</title>
    <url>/2018/10/20/%E5%8C%BA%E5%88%AB%E5%85%A8%E4%BD%93%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>为了定义一个T类型的右值引用，我们通常使用T&amp;&amp;。但是通常使用了T&amp;&amp;，并不代表你使用了右值引用。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">// 右值引用</span></span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>(); <span class="comment">// 右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1; <span class="comment">// 非右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// 右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>; <span class="comment">// 非右值引用</span></span><br></pre></td></tr></table></figure>
事实上，T&amp;&amp;有两层意思。第一层就是普通的右值引用，它绑定了一个右值。另一种是既可能是右值引用，也有可能是左值引用。这种情况下，代码的形式和右值引用很像，都是T&amp;&amp;，但是实际上可能表现得和T&amp;一样。而且，它还可以绑定const和非const对象、volatile和非volatile对象，甚至const和volatile都有的对象。它们可以绑定任何对象。这样的灵活引用值得拥有它独有的名字，我们称之为全体引用(universal
reference)。因为它的使用通常伴随着std::forward，所以在部分C++社区中，还称它为forward
reference。 <span id="more"></span></p>
<p>全体引用一般两种情况中出现的比较多，一种是模板函数中形参的类型，还有一种是在auto中出现。这两种情况都是出现在类型推测当中。<strong>如果&amp;&amp;不是出现在类型推测当中，那么就不是全体引用，而是普通的右值引用</strong>:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>; <span class="comment">// 普通右值引用</span></span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>(); <span class="comment">// 普通右值引用</span></span><br></pre></td></tr></table></figure></p>
<p><strong>判断是否是全体引用，是否有类型推测是必须的，但不是充分的。引用的格式必须是严格的T&amp;&amp;的。</strong>在下面的代码中，就不是全体引用:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// 这是一个右值引用</span></span><br></pre></td></tr></table></figure>
因为上面的代码没有严格的拥有T&amp;&amp;这种形式，所以上面的代码不是全体引用。</p>
<p>const也会导致引用不是全体引用: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>; <span class="comment">// param 是一个右值引用</span></span><br></pre></td></tr></table></figure>
上面的代码，一是在模板中，二是有严格的T&amp;&amp;格式，你可能觉得它是一个全体引用，但事实上它是一个右值引用。<strong>根据C++11标准，只有非const的&amp;&amp;在模板类型推测时才遵守全体引用的规定。</strong><a
href="https://stackoverflow.com/questions/38814939/why-adding-const-makes-the-universal-reference-as-rvalue">stackoverflow相关解答</a></p>
<p>还有如下的代码: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在push_back中它有正确的全体引用的格式，但是它没有类型推测，因为推测的类型在vector初始化的时候就已经决定了。</p>
<p>而vector::emplace_back函数就是右值引用了: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">		<span class="type">void</span> <span class="built_in">emplace_back</span>(Args... args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这里没有使用T&amp;&amp;的格式，但是它还是全体引用。上面所说的T&amp;&amp;中的T代表的是类型推测的类名，不是一个定式T。</p>
<p>上面还说过auto也可以是全体引用。准确的说，auto&amp;&amp;类型的变量是一个全体引用，因为类型推测发生了并且拥有正确的格式。auto全体引用没有模板函数参数的全体引用使用的那么多，但是它们在C++11标准中相辅相成，在C++14中更是对于双方有重要的互补作用，因为C++14中lambda表达式中可以声明auto&amp;&amp;参数。例如，如果你想要写一个C++14lambda表达式来记录时间，你可以这样做:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> timeFuncInvocation = [](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params) </span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//start timer; </span></span><br><span class="line">	</span><br><span class="line">	std::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)( std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)... ); </span><br><span class="line"></span><br><span class="line">	<span class="comment">//stop timer and record elapsed time; </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
func是一个全体引用，它可以绑定任何可调用的左值或右值对象。params是零个或多个全体引用。因为auto的全体引用，使得timeFuncInvocation可以测量任意函数的执行时间。</p>
<p>最后要说的是，本章讲述的关于全体引用的基础都是抽象概念。隐含的定则被称为引用冲突(reference
collapsing)，这个会在后面讲到。当然这个定则不会影响抽象概念的的实用性。区分右值引用和全体引用将有有助于你准确阅读代码，并且避免你与你的合作伙伴写代码时产生二义性。</p>
<p><strong>总结</strong> *
如果一个函数的模板类型参数中是T&amp;&amp;这样的格式，或者一个对象被声明为auto&amp;&amp;，那么这个参数或者对象是一个全体引用。
*
如果类型声明不是严格的type&amp;&amp;格式的，或者不是类型推测的，type&amp;&amp;就是一个右值引用而已。
*
全体引用如果被一个右值初始化，那么它就类似于右值引用。如果被一个左值初始化，那么就类似于左值引用。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>在lambda中对auto&amp;&amp;参数使用decltype以转发它们</title>
    <url>/2018/11/12/%E5%9C%A8lambda%E4%B8%AD%E5%AF%B9auto&amp;&amp;%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8decltype%E4%BB%A5%E8%BD%AC%E5%8F%91%E5%AE%83%E4%BB%AC/</url>
    <content><![CDATA[<p>C++14中最令人兴奋的功能之一就是lambda中可以使用auto类型的参数。<span id="more"></span>这个功能的实现方式也非常直观：将lambda转变成带重载括号操作符（operator()）的模板类。例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">normalize</span>(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这个lambda转变成的模板类的调用操作符（括号操作符）的代码看上去大致是这样的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeCompilerGeneratedClassName</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">		<span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">normalize</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在这个例子中，lambda做的唯一的一件事情就是将参数x转发到normalize中。如果normalize函数对待左值参数和右值参数有不一样的行为时，lambda这样的写法就不是非常合适，因为上面的写法中一直传递给normalize左值，即使传递给lambda的实参是一个右值，也是传递左值。
为了达到上述目的，lambda应该完美转发x到normalize。实现完美转发需要在上面的lambda中做出两个改变。第一，x形参要变成全体引用。第二，传给normalize的参数应该是通过std::forward的。因此lambda最终应该是类似于这样的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">normalize</span>(std::forward&lt;???&gt;(x));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
我们现在出现了一个问题，传给std::forward应该是什么类型的数据？我们先使用了“???”来占位这种类型。</p>
<p>回忆之前使用std::forward时，转发类型是通过模板函数的类型参数T来决定的。而在lambda中，虽然生成类中的调用操作符重载函数有类似于T的存在，但是你无法直接使用这样的T。
根据引用折叠，如果传给全体引用一个左值参数，那么就全体引用就会变成左值引用；而传给全体引用右值参数，那么全体引用就变成右值引用。这意味着在lambda中，我们可以通过参数x的类型获知到实参是左值还是右值引用。decltype就为我们提供了这样的方法。</p>
<p>下面来讨论使用decltype(x)作为std::forward类型参数时，对左值引用和右值引用的转发的可行性。
首先，如果lambda传进来一个左值，那么decltype(x)就是一个左值引用；如果传进来一个右值，那么decltype(x)是一个右值引用。对于std::forward，如果类型参数T是一个左值引用，那么就是在参数为左值时转发；如果类型参数T是一个非引用，那么就是参数为右值时转发。
我们然后来看看std::forward的C++14实现: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果想完美转发右值类型的Widget，std::forward将会根据模板类型参数T，也就是此时的Widget进行实例化模板。因为Widget是一个非引用类型参数，所以std::forward就是对右值进行转发。实例化后的代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样转发是没有问题的，但是我们现在来考虑另一种情况。还是转发右值的Widget，但是这时T是一个右值引用Widget&amp;&amp;，而不是之前的非引用。在实例化完std::forward并且执行完std::remove_reference_t之后，并且在引用折叠之前，std::forward看上去是这样的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; &amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 经过引用折叠之后，代码就变成了这样: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
你会发现这和T为Widget时实例化的std::forward一模一样。这意味着用右值引用作为类型参数实例化std::forward的代码和使用非引用类型作为类型参数时一样，都会转发右值。这就很棒了，因为decltype(x)在传递给lambda一个右值时就是右值引用类型。
而当传递给lambda一个左值类型时，decltype(x)就是传递给std::forward的那个类型参数的类型。因此我们可以知道，无论传递给lambda的x是左值还是右值，使用decltype(x)作为std::forward的模板类型转发时，始终可以给你一个你期望的结果。因此我们的完美转发lambda代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">auto</span>&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">normalize</span>(std::forward&lt;<span class="keyword">decltype</span>(x)&gt;(x));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果完美转发lambda的参数是不定的，只需要添加6个点。具体的C++14代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp;... xs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">normalize</span>(std::forward&lt;<span class="keyword">decltype</span>(xs)&gt;(xs)...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>总结</strong></p>
<p>对auto&amp;&amp;类型的参数使用decltype作为std::forward的模板类型进行转发。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>关于auto的一些补充说明</title>
    <url>/2018/09/17/%E5%85%B3%E4%BA%8Eauto%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>之前讲过，auto的作用是能推导变量、函数的类型（可以参考:<a
href="/2018/09/15/auto类型的推测准则">auto类型的推测准则</a>）。然而在auto的实际使用中，有一个点是需要注意的<span id="more"></span>，我们先来看下面的一个例子：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">getPriorities</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; s; </span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	s.<span class="built_in">push_back</span>(<span class="literal">false</span>); </span><br><span class="line">	s.<span class="built_in">push_back</span>(<span class="literal">true</span>); </span><br><span class="line">	s.<span class="built_in">push_back</span>(<span class="literal">true</span>); </span><br><span class="line">	s.<span class="built_in">push_back</span>(<span class="literal">false</span>); </span><br><span class="line">	s.<span class="built_in">push_back</span>(<span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPriority</span><span class="params">(T priority)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(priority) </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">auto</span> priority1 = <span class="built_in">getPriorities</span>()[<span class="number">0</span>]; </span><br><span class="line">	<span class="type">bool</span> priority2 = <span class="built_in">getPriorities</span>()[<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">showPriority</span>(priority1); </span><br><span class="line">	<span class="built_in">showPriority</span>(priority2); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
上面的例子的运行结果是不稳定的，因为其中包含了未定义行为，也就是调用showPriority(priority)的行为是未定义行为。
这是为什么？</p>
<p>首先我们要知道vector的[]操作符的定义。
与其它的vector的[]操作符不同，其它的都会返回T&amp;，而对于T为bool类型，vector的[]操作符不会bool&amp;，而是返回vector::reference类型，这是个嵌套类，也就是reference是定义在vector中的一个类。我推测这样的做法是因为bool在C++中有效数据为仅1位，但是却需要1字节的空间，而bool在vector内部的存储是使用bit作为单位，reference的作用就是无缝对接1bit的bool和1byte的bool，使用户看上去两者一样，也就是对用户透明。还有很肯定的是这个reference可以自动和bool进行类型隐式转换（毕竟要做到对用户透明）。并且这个reference有一个成员指针，用来指向reference内部的表示bool结果的某一位数据。</p>
<p>上面的当priority为auto类型并在进行=操作时，因为自动推测类型，实际上赋值过来的是这个reference。当在showPriority中进行调用时，根据reference的类型隐式转换，这个reference内部的指针指向的某一位就是需要的结果。但是指向的位实际上已经销毁了，因为getPriorities()函数返回的vector数据的生命周期只在赋值的那句话里。
简单来说，导致这个未定义的原因实际上还是一个浅拷贝对象带来的问题。priority1存储的只是一个对象的浅拷贝副本，并且被拷贝对象在执行完赋值语句后就被销毁了，因此这个副本就存放了野指针，从而导致showPriority的实参其实是从一个野指针指向的位转化而来的bool型。
反观priority2，则在reference内部指针指向的空间没有被销毁前转化成了bool数据类型，从而没有导致未定义行为。
在《effective moderen
C++》这本书中还因此引申出了proxy类，因为proxy类都是利用了这种指针指向被代理数据，而当被指向的空间被不限于作用域的问题被销毁后，这个proxy类对象中的指针就成了野指针，从而造成了一系列问题。我认为上面的问题不是proxy和auto的水土不和，而是没有意识到浅拷贝。这是我对这本书这一章的一个加深理解。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>卡特兰数的应用</title>
    <url>/2019/09/10/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>2015年考研有一题：先序遍历为abcd的不同二叉树的个数是（）</p>
<p>对于这一题，先明确：先序遍历和中序遍历确定唯一的二叉树。所以这一题相当于求中序遍历结果有几种，也或者说四个节点的二叉树有几种形状。</p>
<p>这是很常见的一种卡特兰数的应用。一开始书后答案写的是用入栈出栈的方式解释，让我有些摸不着头脑。后来网上搜索了下资料，了解了一下卡特兰数。
<span id="more"></span></p>
<h1 id="定义">定义</h1>
<p>卡特兰数定义如下：</p>
<p><span class="math display">\[
H_{n} = \frac{C_{2n}^n}{n+1} \nonumber
\]</span></p>
<p>推导过程这里不去追究。</p>
<h1 id="性质">性质</h1>
<p><span class="math display">\[\begin{align}
H_{n}
&amp;=H_{1} \cdot H_{n-1}+H_{2} \cdot H_{n-2}+...+H_{n-1} \cdot H_{1}
=\sum_{i=1}^{n}H_{i} \cdot H_{n-i} \\


H_{n} &amp;= \frac{H_{n - 1}(4n-2)}{n + 1}\\


H_{n} &amp;= C_{2n}^{n} - C_{2n}^{n - 1}
\end{align}\]</span></p>
<h1 id="应用场景">应用场景</h1>
<ol type="1">
<li>给定进栈序列，求出栈序列的种数。</li>
<li>n个节点的二叉树形状种类。</li>
<li>有2n个人买一件5元的东西，有n人有5元纸币，另外n人只有10元纸币，老板没有准备零钱找零，并且互相不会商量一起购买。问买东西的序列有几类。</li>
<li>有多少种不相交对角线，可以将凸多边形划分三角形。 等等</li>
</ol>
]]></content>
      <categories>
        <category>组合数学</category>
      </categories>
  </entry>
  <entry>
    <title>大数乘法</title>
    <url>/2018/06/03/%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<p>先贴题目：http://acm.hdu.edu.cn/showproblem.php?pid=1042</p>
<p>题意比较简单，求N!，N可能达到10000。 <span id="more"></span>
大数和正常数的乘法，算法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> jin = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i)&#123;</span><br><span class="line">		<span class="type">int</span> a = result[i];</span><br><span class="line">		<span class="type">int</span> t = num * a + jin;</span><br><span class="line">		result[i] = t % <span class="number">10</span>;</span><br><span class="line">		jin = t / <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(jin)&#123;</span><br><span class="line">		result[w] = jin % <span class="number">10</span>;</span><br><span class="line">		jin /= <span class="number">10</span>;</span><br><span class="line">		++w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(result,<span class="number">0</span>,<span class="built_in">sizeof</span>(result));</span><br><span class="line">	result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	<span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N) != EOF)&#123;</span><br><span class="line">		<span class="built_in">multiply</span>(N,w);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = w - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面算法中，result中存放了一个大数乘数的倒序，main中的N(multiply中的num)是存放了另一个大数，w是result的长度。这样可以进行大数和一个int的乘法。</p>
<p>上述乘法的算法非常有意思，和一般的竖式乘法有一点不一样，请仔细揣摩。</p>
<p>如果两个数都是大数，那么算法如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">char</span> *current)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(current);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; ++i)&#123;</span><br><span class="line">		<span class="type">char</span> t = current[i];</span><br><span class="line">		current[i] = current[len - <span class="number">1</span> - i];</span><br><span class="line">		current[len - <span class="number">1</span> - i] = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> temp[<span class="number">100000</span>];<span class="comment">//累加器，临时变量</span></span><br><span class="line"><span class="type">char</span> result[<span class="number">100000</span>];<span class="comment">//一个乘数（上次的计算结果）</span></span><br><span class="line"><span class="type">char</span> input[<span class="number">100000</span>];<span class="comment">//另一个乘数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multiply</span><span class="params">(<span class="type">char</span> *num)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="built_in">sizeof</span>(temp));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)<span class="built_in">strlen</span>(result); ++i)&#123;</span><br><span class="line">		<span class="type">int</span> a = result[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="type">int</span> jin = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)<span class="built_in">strlen</span>(num); ++j)&#123;</span><br><span class="line">			<span class="type">int</span> b = num[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(temp[i + j] == <span class="string">&#x27;\0&#x27;</span>) temp[i + j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="type">int</span> mult = a * b + temp[i + j] - <span class="string">&#x27;0&#x27;</span> + jin;</span><br><span class="line"></span><br><span class="line">			temp[i + j] = mult % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			jin = mult / <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> p = <span class="built_in">strlen</span>(input) + i;</span><br><span class="line">		<span class="keyword">while</span>(jin)&#123;</span><br><span class="line">			temp[p++] = jin % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			jin /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(result,temp,<span class="built_in">sizeof</span>(temp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(result,<span class="number">0</span>,<span class="built_in">sizeof</span>(result));</span><br><span class="line">	result[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,input) != EOF)&#123;</span><br><span class="line">		<span class="built_in">rev</span>(input);</span><br><span class="line">		<span class="built_in">multiply</span>(input);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">strlen</span>(result) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,result[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个算法是完全模拟竖式计算的。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>如果任务必须执行，请指定使用std::launch::async启动策略</title>
    <url>/2018/11/21/%E5%A6%82%E6%9E%9C%E4%BB%BB%E5%8A%A1%E5%BF%85%E9%A1%BB%E6%89%A7%E8%A1%8C%EF%BC%8C%E8%AF%B7%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8std_launch_async%E5%90%AF%E5%8A%A8%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>当你调用std::async执行一个函数时，你通常意图异步执行这个函数。但是std::async的行为并不是你真正需要的，因为你可能仅仅需要的是在std::async启动策略下运行。C++中一共有两种策略，每一个都被std::launch中的一个enum所枚举。<span id="more"></span>假设把函数f传递给std::async运行，<strong>std::launch::async策略意味着f必须异步运行，也就是在不同线程下运行；std::launch::deferred策略意味着f只会在调用了std::async返回的future的get和wait方法时运行。这也就是说，f的运行是延迟的，直到需要使用其结果再执行。</strong>当get和wait方法执行时，f将同步执行，也就是说调用者将会被阻塞，直到f完成运行。如果get和wait都没有被调用过，那么f永远不会执行。
你可能会惊讶，std::async默认启动策略不是两种启动策略之一，而是两种启动策略都有。下面的代码将表达同一种意思:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut1 = std::<span class="built_in">async</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut2 = std::<span class="built_in">async</span>(std::launch::async | std::launch::deferred,</span><br><span class="line">	f</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
默认策略因此允许f在异步或同步中的一个下运行。std::async和标准库中的线程管理组件被允许灵活地负责线程的创建和销毁，并且避免超额认购以及负载均衡。这就让使用std::async的应用变得很方便了。这个灵活的机制会根据系统的负载情况决定是立刻创建新线程执行，还是延迟、在get或wait被调用时在当前线程上执行。</p>
<p>但是使用上面这种默认启动策略却有一些隐含意义。如下代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f); <span class="comment">// f使用默认的启动策略</span></span><br></pre></td></tr></table></figure> 它有如下的隐含意义： *
无法预测f是否立即运行，因为f可能被调度成延迟运行。 *
无法预测f是否在执行fut的get或者wait的线程上运行。如果在线程t上执行fut的get和wait，那么是否f运行在t上面是无法预测的。因为如果系统负荷低，调度器选择了立即创建新线程执行，也就是std::launch::async，那么f就会在新线程上执行。
* 无法预测f是否会运行，因为可能无法保证每个fut都会被调用get或wait。</p>
<p>默认的启动策略的调度机制和thread_local混合得不是很好，因为如果f要读或者写线程内本地存储（thread-local
storage，TLS，就是某个生命周期在线程内的变量），是无法预测哪个线程的thread_local变量被访问的，可能是独立线程的TLS，也有可能指的是调用了fut的get或wait的线程的TLS被访问。</p>
<p>默认的启动策略还影响基于wait设置超时的循环，因为<strong>调用延迟任务的wait_for或者wait_until会是future为std::future_status::defered状态</strong>。这也就是说下面的循环看上去应该是即时的，但是事实上却可能永远循环下去:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fut.<span class="built_in">wait_for</span>(<span class="number">100</span>ms) != std::future_status::ready)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果f线程以std::async策略调用，那么运行结果是没有问题的；而如果是以std::deferred策略调用，那么就会出现一直循环的情况，因为fut的状态一直都是std::future_status::deferred。
在开发和单元测试环节中这些问题都很有可能被忽视，因为只有在系统高负载时才会被发现。因为超额认购或者线程达到上限问题而推迟了线程的运行，这时就会出现上面的死循环。
而修复这个问题的方案也很简单，只要检查std::async构造的future是不是延迟的任务，如果是，避免使用超时的循环。不过遗憾的是没有办法直接询问future任务是不是延迟的。你可以通过使用一个基于超时的函数来检查future是不是延迟的，例如使用wait_for，时间设置成0。很明显这里使用wait_for不是为了真的等待什么，而是检查它的返回值是不是std::future_status::deferred:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::async | std::launch::deferred, f);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fut.<span class="built_in">wait_for</span>(<span class="number">0</span>s) == std::future_status::deferred)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(fut.<span class="built_in">wait_for</span>(<span class="number">100</span>ms) != std::future_status::ready)</span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上诸多考虑的结果就是，在以下几种情况下使用默认启动策略的std::async：</p>
<ul>
<li>该任务不需要与调用get或wait的线程同时运行。</li>
<li>对于读或写哪个线程的thread_local变量无所谓。</li>
<li>保证对于std::async返回的future有get或者wait中的一个被执行，或者接受线程没有被执行过。</li>
<li>使用wait_for或者wait_until等要注意延迟状态。</li>
</ul>
<p>如果你没有上面的条件，而可能希望保证std::async将任务调度成真正的异步，那么使用的方法就是将std::launch::async作为第一个参数，调用如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::async, f);</span><br></pre></td></tr></table></figure>
事实上，如果std::async的第一个参数默认就是std::launch::async，就会使std::async成为一个非常方便的工具，所以我们可以这样写:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">inline</span> std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Ts...)&gt;::type&gt;</span><br><span class="line"><span class="built_in">reallyAsync</span>(F&amp;&amp; f, Ts&amp;&amp;... params)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">		std::forward&lt;F&gt;(f),</span><br><span class="line">		std::forward&lt;Ts&gt;(params)...</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这就是一个普通的完美转发，对于返回的future的类型的推测也非常简单，直接使用std::result_of即可。</p>
<p>改写成C++14的风格的话，代码如下: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="keyword">auto</span></span></span><br><span class="line"><span class="function"><span class="title">reallyAsync</span><span class="params">(F&amp;&amp; f, Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">		std::forward&lt;F&gt;(f),</span><br><span class="line">		std::forward&lt;Ts&gt;(params)...</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>总结</strong></p>
<ul>
<li>std::async的默认启动策略是同步和异步混合的任务执行。</li>
<li>默认启动策略可能会使访问哪个线程的thread_local是不确定的。这也意味着，任务可能永远不执行，并且这也有可能在使用超时函数作为逻辑判断的条件时出问题。在延迟启动策略时，超时函数会使future状态为std::future_status::deferred。</li>
<li>如果任务必须异步执行，请指定std::async的参数为std::launch::async。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>如果可复制类型参数移动的代价低并且始终被复制，请考虑按值传参</title>
    <url>/2018/12/13/%E5%A6%82%E6%9E%9C%E5%8F%AF%E5%A4%8D%E5%88%B6%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%A7%BB%E5%8A%A8%E7%9A%84%E4%BB%A3%E4%BB%B7%E4%BD%8E%E5%B9%B6%E4%B8%94%E5%A7%8B%E7%BB%88%E8%A2%AB%E5%A4%8D%E5%88%B6%EF%BC%8C%E8%AF%B7%E8%80%83%E8%99%91%E6%8C%89%E5%80%BC%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<p>首先声明：下面的“复制”和“拷贝”词语是严格区分的。“复制”指的是传统意义上的复制，“对于对象的复制”就是指对某个对象进行复制构造或者复制赋值。而对于“拷贝”，指的是包括“复制”和“移动”在内的操作。例如将a拷贝到b，这只是强调b和之前的a一模一样，但不保证a还存在。这一点在《Effective
modern C++》英文版中的286页注释有说明。 <span id="more"></span>
有些函数的参数是可以拷贝的，例如addName成员函数可能就可以拷贝它的实参到私有的容器中去。为了效率，这样的函数应该左值复制其参数，而不是右值移动参数：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			names.<span class="built_in">push_back</span>(newName);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这样的写法是可以的，但即使这两个函数做的是一件事，却还不得不写两个。同时这就意味着：要声明两个函数、完成两个函数、写两个函数的文档并且维护两个函数。如果当这两个函数都是内联函数，那么可能对象还不是那么臃肿，但如果这两个函数不是内联函数，那么可能就真的有两个函数在对象的代码中。一个替代方法是使用模板addName，并且参数使用全体引用（universal
reference）： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			names.<span class="built_in">push_back</span>(std::forward&lt;T&gt;(newName)); <span class="comment">// std::forward复制左值，移动右值</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这就减少了代码量，但是这么做就带来了其它问题。但作为一个模板，addName函数通常必须在头文件中补全，而且它可能使用对象代码中的几个函数。因为这段代码不光对左值和右值区别实例化，而且还对std::string以及可以转化成std::string的类区别实例化（参看：<a
href="/2018/10/21/对于左值引用使用std_move，对于全体引用使用std_forward/">对于左值引用使用std::move，对于全体引用使用std::forward</a>）。如果实参的类型不能传递给全体引用（参看：<a
href="/2018/11/06/几个完美转发失败的条件/">几个完美转发失败的条件</a>），或者调用者传递了不合适的实参类型，编译错误可能会变得比较复杂。</p>
<p>有没有一种方法可以写出只有一个函数，却能复制左值、移动右值，而且还能避免全体引用错误说明不详细的问题的addName呢？有，但你<strong>需要抛弃你在学习C++时的一个观点：避免按值传递用户定义类型的对象</strong>。对于addName的newName参数，传值传参是一个合理的决策。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span> <span class="comment">// 获得左值或右值</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName)); <span class="comment">// 移动参数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这里唯一的是显而易见的部分是对参数newName使用std::move的部分。通常来说，std::move被用于右值引用，但是在这里，我们知道newName是独立于调用者传进来的参数的，所以改变newName不会影响调用者；另外这里是函数中最后使用newName的地方，所以从newName移动不会对函数剩下的部分有影响。这里的代码只是用一个addName函数，没有使用全体引用，因此这个方法也不会让头文件臃肿，也不会出现让人困惑的错误信息。但是效率如何呢？</p>
<p>在C++98中，无疑这样做的效率肯定是不高的。无论调用者传递进来什么参数都会被使用复制构造函数创造出来。在C++11中，newName只会在传进来左值时复制构造，对于右值将会使用移动构造的方式。假设有如下的调用函数：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">&quot;Bart&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">addName</span>(name);</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">addName</span>(name + <span class="string">&quot;Jenne&quot;</span>);</span><br></pre></td></tr></table></figure>
在第一次调用addName时，参数newName使用了左值初始化，就像在C++98中那样，newName进行了复制构造。在第二次调用中，newName的实参是std::string和+操作符执行结果的std::string，这个对象是一个右值因此被移动构造。这样做能使左值参数被复制，右值参数被移动，代码也很精简。</p>
<p>但是有一些我们需要牢记，我们先用3个版本的addName考虑这个问题：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			names.<span class="built_in">push_back</span>(newName);</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;std::string&gt; names; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			names.<span class="built_in">push_back</span>(std::forward&lt;T&gt;(newName)); <span class="comment">// std::forward复制左值，移动右值 </span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>: </span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span> <span class="comment">// 获得左值或右值</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName)); <span class="comment">// 移动参数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 下面是两个调用场景： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">&quot;Bart&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">addName</span>(name);</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">addName</span>(name + <span class="string">&quot;Jenne&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>现在我们考虑三个addName执行添加名称的代价。这里忽略编译器对复制和移动的优化，因为这样的优化是取决于上下文和编译器的，所以我们这里不进行讨论。</p>
<ul>
<li>使用重载时：无论传递过去的是左值还是右值参数，newName引用绑定了实参，这没有花多少代价，我们忽略不计。在左值参数时，newName被复制到了Widget::names中；在右值参数时，newName被移动到Widget::names中去了。因此代价总和是在左值参数时一个复制，在右值参数时一个移动。</li>
<li>使用全体引用时：和“使用重载时”一样，newName绑定到了实参上，这没有多少花销。因为使用了std::forward，左值std::string被复制到了Widget::names中，右值则被移动进去了。所以这个方法的代价之和是在左值参数时复制，右值参数时移动。<br />
而在<a
href="/2018/10/21/对于左值引用使用stdmove，对于全体引用使用stdforward/">对于左值引用使用std::move，对于全体引用使用std::forward</a>中说到如果调用者传递的参数是不同于std::string类型的参数，那么参数将会被转发到std::string的构造函数中，并且这会因为没有临时的std::string需要复制或移动而效率提高。因此使用全体引用可能使得程序效率特别高。但是这不关乎我们的分析，我们假设调用者一直传递std::string类型的临时参数。</li>
<li>传值：无论传的值是左值还是右值，参数newName必须构造。如果传的参数是左值，那么就会需要一次复制构造；如果是一个右值参数，那么就要消耗一个移动构造。在函数体中，newName是无条件移动到Widget::names。代价总和因此在参数为左值时是一个复制和一个移动，在右值时需要两次移动。相比较上面两种方法，分别在参数为左值和右值时多了额外一次移动。</li>
</ul>
<p>我们现在在回过头来看标题：<strong>如果可复制类型参数移动的代价低并且始终被复制，请考虑按值传参。</strong></p>
<p>这么做是有道理，下面对于标题的建议进行分析： 1.
只需考虑按值传参：这样只需要写一个函数，在对象中也只会生成一个函数，它避免了全体引用作为参数带来的问题。但是它却在某些情况下比其它两种方法需要更多的代价，这我们之后也会讨论。
2.
只对可复制参数考虑传值：只能移动的参数是排除在标题建议之外的。因为若不可复制，需要拷贝创造副本，那么只能通过移动构造。回忆传值方法相对重载方法的好处，因为传值方法只有一个函数要写，但是对于只移动的参数类型，没有必要在重载方法中提供一个参数为左值的重载函数，因为复制左值需要调用复制构造函数，并且对于只能移动类型来说，复制构造是禁止的。这也就是说只需要有参数为右值的重载函数，使用“重载的方法”只需要写一个重载函数--参数为右值引用的那一个。
例如：有一个类有一个数据成员std::unique_ptr<std::string>以及一个setter函数。而std::unique_ptr是一个只能移动的类型，所以对setter函数使用“重载的方法”只要使用一个函数：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setPtr</span><span class="params">(std::unique&lt;std::string&gt;&amp;&amp; str)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			p = std::<span class="built_in">move</span>(ptr);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::unique_ptr&lt;std::string&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 对于调用也很方便： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line">w.<span class="built_in">setPtr</span>(std::<span class="built_in">make_unique</span>&lt;std::string&gt;(<span class="string">&quot;Modern C++&quot;</span>));</span><br></pre></td></tr></table></figure>
在这里由std::make_unique返回的std::unique_ptr被以右值引用传给setPtr，它移动到数据成员p，所有的消耗只是一个移动。
但如果setPtr是按值传参： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setPtr</span><span class="params">(std::unique&lt;std::string&gt; ptr)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			p = std::<span class="built_in">move</span>(ptr);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这时同样的将会移动构造ptr，并且ptr将会被移动赋值给数据成员p，总共的花费是两次move，也就是使用“重载的方法”的两倍。
3.
只适用于对于移动非常低代价的参数：当移动代价很低的时候，对于多出来的一个移动操作的消耗就能被接收。但是当移动的代价不低的时候，对于多出来的一个移动操作就变成了负担，反而不如使用复制的操作。
4.
只有参数只会被复制的时候才考虑传值：为了展示为什么这是必要条件，假设在复制参数到names容器之前，addName检查新的名字是否太短还是太长。如果新名字不符合条件，那么添加名字的请求将会忽略。下面展示这个需求传值的实现：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>((newName.<span class="built_in">length</span>() &gt;= minLen) &amp;&amp; (newName.<span class="built_in">length</span>() &lt;= maxLen))</span><br><span class="line">			&#123;</span><br><span class="line">				names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
即使newName没有被添加到names里，构造和销毁newName也不可避免。这个代价在使用传引用的方法时就不需要付出。</p>
<p>不过，即使参数是随时可复制类型、移动代价很低，也会有情况是不适合传值传参的。这是因为一个函数可以有两种方法拷贝它的参数：通过构造函数（包括复制构造函数和移动构造函数）和赋值（包括复制赋值和移动赋值）。addName如果使用了构造函数的方法：它的参数newName传递给了vector::push_back并且在这个函数的内部，newName被拷贝到了一个新的元素，这个新元素在std::vector的尾部，对于使用构造函数的方法，我们前面的分析是全面的。</p>
<p>当参数是通过赋值的方式拷贝到参数中时，情况就变得非常复杂了。假设我们有一个类代表“密码”，因为密码是可变的，我们提供了一个setter函数changeTo。使用“传值传参的方法”时，代码可能是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Password</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Password</span><span class="params">(std::string pwd)</span> : text(std::move(pwd)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">changeTo</span><span class="params">(std::string newPwd)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			text = std::<span class="built_in">move</span>(newPwd);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们先不考虑密码长短这类的安全问题，构造一个Password对象：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">initPwd</span><span class="params">(<span class="string">&quot;Supercalifragilisticexpialidocious&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Password <span class="title">p</span><span class="params">(initPwd)</span></span>;</span><br></pre></td></tr></table></figure>
这里我们给p.text构造了一个std::string对象，并且使用了“传值的传参方式”，这相比“重载的方式”需要付出多一些的代价。然后我们改变p的密码值：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string newPassword = <span class="string">&quot;Beware the Jabberwock&quot;</span>;</span><br><span class="line"></span><br><span class="line">p.<span class="built_in">changeTo</span>(newPassword);</span><br></pre></td></tr></table></figure>
无论新的密码是否真的比旧的密码好，我们的changeTo需要使用赋值的方式改变密码。传递给changeTo的是一个左值（newPassword），所以参数newPwd是通过std::string的复制构造函数构造的，这个构造函数分配内存以存放新的密码。newPwd之后将会被移动赋值到text中，这会导致之前已经分配给text的内存被释放。因此有两个动态内存管理动作在changeTo中：一个是为新密码分配内存，另一个是将老密码的内存空间释放。
但是在这个例子中，老密码“Supercalifragilisticexpialidocious”比新的密码“Beware
the
Jabberwock”长，所以没有必要分配或释放任何东西。如果我们使用的“重载的方法”就可能不需要任何代价：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Password</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">changeTo</span><span class="params">(std::string&amp; newPwd)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			text = newPwd;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在这种情况下，“传值传参的方法”的代价包括额外的内存分配和释放，这个代价超过使用一个std::string的移动操作的代价几个数量级。</p>
<p>如果老密码比新密码短，“分配-释放”这个操作对通常在赋值时是不可避免的，传值传参时的运行速度和传引用传参差不多。而<strong>基于赋值的参数赋值速度因此依赖于赋值的对象类型。</strong>上面的这种理论可以使用到大多数的动态开辟内存存放数据的参数的类型中，虽然不是全部，但是std::string和std::vector在内。这种隐形的高代价只在参数是左值时会发生，因为需要它内存分配和释放，而内存的分配和释放通常只在进行复制操作时发生。对于右值参数，移动通常不会发生分配和释放。</p>
<p>因此，在使用赋值的函数中，传值传参相较于传引用传参的额外代价通常是依赖于传递的参数的类型、左值和右值实参的比例、是否类型使用了动态内存以及如果使用了动态内存，对于赋值操作符的实现函数以及赋值目标是否和赋值源是否一样大。对于std::string，这个代价还依赖于是否使用了短字符串优化（small
string optimization，SSO），并且被赋值的变量是否适合SSO缓存。</p>
<p>从上面我们也看出，对于使用复制赋值的参数，分析它的代价是非常复杂的。通常，我们使用“在未证明可行的情况下认为不可行”的策略，因此可以使用除非证明“传值传参的方法”的效率明显高于其它方法，否则使用“重载的方法”或者“全体引用传参的方法”。</p>
<p><strong>在必须尽可能快的软件中，使用“传值传参的方法”不是一个可行的办法</strong>，因为如果某处可以用移动但是没有使用是不可以接受的。如果使用“传值传参的方法”，有多少移动操作被使用是不可预知的。例如在上面添加名称的例子当中，如果Widget::addName还会调用Widget::validateName，并且这个函数还是通过传值传参，而这个validateName还会调用一个传值传参的函数......这样下去就无法预计。因为每次使用“传值传参的方法”都需要多花费一个移动操作的代价，当有一个惊人数量的调用链之后，你将会难以承受这些多花费的代价。</p>
<p>另一个值得注意的问题是，传值传参和传引用传参不一样，它容易遭受切割问题（slicing
problem）。这是C++98所讨论的问题，这里简单讲一下。如果有一个函数的参数是某个基类以及基类的派生类，你不要使用传值传参的方式传递参数，因为如果你传过去的是派生类对象，那么你将会有属性被“切割”掉：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWidget</span>: <span class="keyword">public</span> Widget &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(Widget w)</span></span>; <span class="comment">// 接受基类Widget对象参数，也接受其派生类对象参数</span></span><br><span class="line"></span><br><span class="line">SpecialWidget sw;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processWidget</span>(sw); <span class="comment">// SpecialWidget独有的属性将会被“切割”</span></span><br></pre></td></tr></table></figure>
<p>如果你不熟悉切割问题，你可以通过搜索引擎进行搜索。你会发现切割问题是C++98中另一个传值传参不被认可的原因。</p>
<p>C++11中并没有改变C++98中关于传值传参的内容。通常传值传参任然有许多性能上的问题使得你要去避讳，并且传值传参仍然会导致切割问题。在C++11中新引入的知识左值参数和右值参数。使用了可复制类型的移动语义仍然需要重载或者使用全体引用，虽然两者都有各自的缺点。对于始终复制并且移动代价低的类型、不用考虑切割问题的参数，使用传值传参提供了一个更简单实现而且差不多效率的替换传引用传参的方式，并且能避免传引用传参的不足之处。</p>
<p><strong>总结</strong></p>
<ul>
<li>对于可复制、移动代价低的参数类型，并且参数只会被复制的情况，传值传参可以提供几乎同等效率于传引用传参的能力，并且它更加容易实现，需要更少的代码。</li>
<li>对于左值参数，传值传参（例如使用复制构造函数）后跟移动操作的代价可能比传引用传参后跟复制操作的代价要高。(修改密码的例子)</li>
<li>传值传参会导致切割问题，所以对于基类参数类型，“传值传参的方法”通常不适合。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>对于左值引用使用std::move，对于全体引用使用std::forward</title>
    <url>/2018/10/21/%E5%AF%B9%E4%BA%8E%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8std_move%EF%BC%8C%E5%AF%B9%E4%BA%8E%E5%85%A8%E4%BD%93%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8std_forward/</url>
    <content><![CDATA[<p>右值引用只会绑定到将要被移动的对象上。对于一个右值引用的参数，可以肯定被引用的对象是要被移动过来的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Widget</span>(Widget&amp;&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
如上面的代码中，你可能想要传递对象给函数调用，为了利用右值的优势你就想要用移动操作。为了你想实现上面的功能，你就需要将绑定的对象转换成右值形式。我们使用std::move来完成这项工作:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Widget</span>(Widget&amp;&amp; rhs) : <span class="built_in">name</span>(std::<span class="built_in">move</span>(rhs.name)), <span class="built_in">p</span>(std::<span class="built_in">move</span>(rhs.p)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string name;</span><br><span class="line">		std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
另外，一个全体引用可能被绑定到一个可移动的对象。当右值绑定到全体引用时，全体引用就成了一个右值引用，这时应该使用std::forward:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			name = std::forward&lt;T&gt;(newName);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上面的两种情况说明：右值引用的变量通过std::move转发，而全体引用使用的右值通过std::forward转发。
<span id="more"></span></p>
<p>在<a
href="/2018/10/18/理解std_move和std_forward">理解std::move和std::forward</a>中介绍了std::forward对于右值引用可以带来正确的代码，但是会把源码变得繁冗，非常容易导致错误并且不符合语言习惯，也呼吁尽量避免使用std::forward。但是如果这里对全体引用使用std::move，这可能会导致意外地修改左值:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			name = std::<span class="built_in">move</span>(newName); <span class="comment">// 使用了std::move转换一个全体引用 </span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string name; <span class="comment">//std::shared_ptr&lt;SomeDataStructure&gt; p;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getWidgetName</span><span class="params">()</span></span>; <span class="comment">// 用于产生Widget的名称</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">auto</span> n = <span class="built_in">getWidgetName</span>();</span><br><span class="line">w.<span class="built_in">setName</span>(n); <span class="comment">// 本地变量n的值被移动到了w.name中</span></span><br></pre></td></tr></table></figure>
上面的代码中，因为setName中使用了std::move，本地变量n的数据就被移动进了w.name当中，本地变量变空。</p>
<p>当然你可能认为上面代码不合理，setName不应该声明它的参数为全体引用，或者这样写会使引用不可以是const的，因为setName很明显不应该修改它参数的值。所以你就想到了使用重载来解决上面的两个不足之处:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> std::string&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			name = newName;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(std::string&amp;&amp; newName)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			name = std::<span class="built_in">move</span>(newName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这样就可以给引用加上const以避免值被修改。这样的确可以运行，但是有很多的不足。首先因为使用了两个函数替代了一个单独的模板，需要编写和维护更多的代码。另外代码效率也非常低下。当如下使用setName时:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">w.<span class="built_in">setName</span>(<span class="string">&quot;Adela Novak&quot;</span>);</span><br></pre></td></tr></table></figure>
如果是仅使用了全体引用为参数的setName，模板类型将会推断为const
char<em>，字符串“Adela
Novak”将会被传递给setName，在setName中将会调用w内部的std::string的赋值操作符。w的数据成员因此会直接从字符串赋值过去，没有任何的临时变量产生。
而使用重载的setName就会产生一个临时的std::string对象，用于作为setName的参数，然后这个参数会被移动到w的成员中。因此一个对于setName的调用最终会调用std::string的构造函数(创建临时的std::string)、一次std::string移动赋值操作(把newName移动到w.name中去)、一次std::string的销毁操作(销毁那个临时的std::string)。这是一个比直接调用const
char</em>指针需要更加高昂代价的操作。</p>
<p><strong>因此，使用一对对于左值和右值重载的函数替换使用全体引用的模板函数会导致更高昂的运行代价。</strong></p>
<p>使用一对重载函数代替全体引用为参数的模板函数还会导致代码修改变得更加复杂。上面代码中Widget::setName只有一个参数，所以只需要两个重载函数。但是如果函数有更多的参数，每一个都可能是左值或者右值，那么n个参数就需要<span
class="math display">\[2^n\]</span>个重载函数。而且有的函数的参数个数是不定的，例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt; shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
像这样的函数，分左值和右值重载就没有办法了，只能使用全体引用了。</p>
<p>因为std::move会导致原变量边空，而有时候我们希望在一个函数中多次使用被右值引用或者全体引用绑定的对象，这就要使用之前这个对象没有被移动，这时我们就需要对最后一次使用的引用使用std::move或者std::forward，例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSignText</span><span class="params">(T&amp;&amp; text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sign.<span class="built_in">setText</span>(text);</span><br><span class="line">	<span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">	signHistory.<span class="built_in">add</span>(now, std::forward&lt;T&gt;(text));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为我们希望在signHistory.add中使用text，这就要确保setText肯定不会修改text。然后是对全体引用使用了std::forward。</p>
<p>std::move和std::forward类似，但是有时候你可能想使用的是std::move_if_noexcept（具体参看:<a
href="/2018/09/30/noexcept关键字的使用">noexcept关键字的使用</a>
）代替std::move。</p>
<p>如果一个函数的返回值是一个值，并且这个值被绑定到了一个右值引用或者一个全体引用，那么请使用std::move或者std::forward返回这个值。例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	lhs += rhs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">move</span>(lhs); <span class="comment">// 把lhs移动到返回值当中，右值引用使用std::move</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过转换lhs为return语句(通过std::move)，lhs将移动到函数的返回值的位置
如果忽略调用std::move，也就是代码如下时: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="type">const</span> Matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	lhs += rhs;</span><br><span class="line">	<span class="keyword">return</span> lhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
lhs因为是左值，编译器将它复制到函数返回值的位置。假设Matrix支持移动构造，在return语句中使用std::move将会使代码效率更高。</p>
<p>如果Matrix不支持移动，这样的转换也不会有什么副作用，因为右值只是会被通过复制构造复制走。如果Matrix之后又支持了移动，“+”操作符将会将会在编译时自动变得更优。在返回右值引用或者全体引用时使用std::move或者std::forward时没有什么坏处，反而只有好处。
根据上面的理论，有人就认为：如果对右值引用参数使用std::move可以将复制到函数返回位置变成移动到函数返回位置，那么为什么不能将函数的本地变量也通过移动的方式移动到函数返回位置作为返回呢？例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> <span class="comment">// “复制”版本的makeWidget</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Widget w;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> w; <span class="comment">// “复制”本地变量w到函数返回位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 变成 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> <span class="comment">// 移动版本的makeWidget</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Widget w;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">move</span>(w); <span class="comment">// 移动本地变量w到函数返回位置（请不要这样做）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但事实上这样做是有瑕疵的。C++标准委员会已经提前想到了这个问题，委员会在标准中对于本地变量作为返回值时做了特殊的优化，它们通过返回这个本地变量的内存地址对代码进行优化，这样避免了复制到函数返回位置的一次操作。这个优化被称作RVO(return
value optimization)，并且是被C++标准明确规定的。
这样一个好东西是非常有讲究的，因为你肯定希望在适当的地方使用这个省略复制的操作，并且不会影响到程序的行为。在C++标准中这样规定：同时满足以下两个条件时，编译器可以不复制（或者移动）返回值的函数的返回的本地对象（包括本地变量以及return语句创建的临时对象，但不包括函数的参数）：</p>
<ol type="1">
<li>本地对象的类型和函数返回的本地对象类型一致。</li>
<li>是本地对象作为函数的返回值。</li>
</ol>
<p>所以当我们返回到上面的两种makeWidget中。首先两者都是可行的代码。但是每个正规的C++编译器都会使用RVO来避免对w的复制。这也就是说复制版本的makeWidget并不会在返回的时候复制w。</p>
<p>而移动版本的则会按照预期的去做，将w移动到函数的返回值的位置。那么为什么编译器不会根据RVO不移动呢？答案是它不能这样做。因为上面的条件2中规定了是本地对象作为返回值，而移动版本的makeWidget返回右值引用。因此不可以在这里应用RVO。</p>
<p>当然实际的编码环境复杂，很多情况下你感觉还是需要使用std::move，但即使这样也建议考虑RVO。因为RVO中还这么说，如果编译器没有办法实现忽略复制，那么被返回的对象将会被当做一个右值来对待。标准中RVO如果被使用，将会在复制忽略和隐式调用std::move中二选一。所以下面的代码要不然会忽略复制，要不然就自动添加std::move:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Widget w;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这也就意味着，如果你使用了std::move()作为函数返回值，根据RVO这样不会优化你的代码，反而可能阻碍优化（杜绝了RVO）。</p>
<p>使用std::move在几种情况下可以使代码优化，例如传参的时候，被调用的函数还调用函数并且使用传进来的参数作为将被调用函数的参数。但是在作为返回表达式的一部分时，如果要使用RVO，那么就不建议使用std::move了。</p>
<p><strong>总结</strong> *
在最后一次使用某个引用时，当这个引用是右值引用时使用std::move，是全体引用时使用std::forward。
*
当某个右值引用或全体引用被函数以返回值的方式返回时，建议对右值引用使用std::move、对全体引用使用std::forward。
*
不要对本地对象使用std::move或std::forward。因为返回值优化（RVO）会优化它们。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>对并行使用std::atomic，对特殊内存使用volatile</title>
    <url>/2018/12/09/%E5%AF%B9%E5%B9%B6%E8%A1%8C%E4%BD%BF%E7%94%A8std_atomic%EF%BC%8C%E5%AF%B9%E7%89%B9%E6%AE%8A%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8volatile/</url>
    <content><![CDATA[<p>在C++编程中std::atomic经常被用于某个互斥访问的变量，它使用了特殊的机器指令保证了互斥与效率兼具（相比较使用mutex）。下面展示一个使用了std::atomic的例子：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ai</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">ai = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ai;</span><br><span class="line"></span><br><span class="line">++ai;</span><br><span class="line"></span><br><span class="line">--ai; </span><br></pre></td></tr></table></figure> 在执行完上面的代码后，可能的结果只可能是0，10，11。<br />
上面的例子说明std::atomic只保证某时对std::atomic的访问是互斥的，并不保证整个过程是互斥的。在“std::cout
&lt;&lt;
ai”代码中，在ai的值被读之后、复制给标准输出之前，另一个线程可能改变ai的值，因此值除了是10之外还可能是11和0。
另一个值得注意的地方是最后两句代码的行为。这两个是<strong>“读后写”操作（read-modify-write，RMW）</strong>，但是它们的读和写两个操作从外界来看还是原子的。这就是std::atomic最重要的一个特性之一，在std::atomic构造完成之后，保证其所有成员函数包括RMW操作在其它线程看来都是原子的。</p>
<p>而使用volatile的代码在多线程上没有任何保证任何事情<span id="more"></span>：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">int</span> <span class="title">vi</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">vi = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; vi;</span><br><span class="line"></span><br><span class="line">++vi;</span><br><span class="line"></span><br><span class="line">--vi;</span><br></pre></td></tr></table></figure>
在代码执行的过程中，任何数字都有可能被输出，因为vi没有被互斥所保护，因此会发生<strong>数据竞赛（data
race）</strong>。为了更好地理解上面的代码，有如下代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">ac</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">int</span> <span class="title">vc</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---- Thread 1 ---- */</span> <span class="comment">/* ---- Thread 2 ---- */</span></span><br><span class="line">         ++ac;                    ++ac;</span><br><span class="line">         ++vc;                    ++vc;</span><br></pre></td></tr></table></figure>
当两个线程都执行结束之后，ac的值肯定是2，因为他的每一个自加操作都是原子的。而对于vc则可能不是2，可能在读完vc的值之后另一个线程进来也读取了这个自加之前的值，然后两个线程再各自进行加一操作。并且vc的值还可能是任意值，因为<strong>C++标准中规定数据竞赛可以导致未定义行为</strong>，这也就意味着编译器可能生成做任何事情的代码，而且编译器有时会对有数据竞争的代码进行优化以避免数据竞赛，但是优化后的代码在数据竞赛时的行为仍然是不可预计的。</p>
<p>RMW不是std::atomic在并发上打败volatile的唯一例子。在为了保证计算的数据在计算完之后才能使用，通常使用std::atomic作为标志用以显示计算是否完成。代码可能看上去是这样的：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">valAvailable</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> imptValue = <span class="built_in">computeImportantValue</span>();</span><br><span class="line"></span><br><span class="line">valAvailable = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
这段代码读起来似乎没有什么问题，但是编译器看过去就是一对赋值操作。因此编译器可以对代码执行顺序进行打乱，也就是说如果有如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = b;</span><br><span class="line"></span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>
<p>进行顺序打乱之后就可能是： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = y;</span><br><span class="line"></span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure>
即使编译器不进行打乱操作，底层相关的硬件也可能进行打乱操作，因为这样有时候可以使代码运行更加快速。</p>
<p><strong>如果使用std::atomic，在进行优化时有许多强制的规定，其中一个就是写入std::atomic数据之前的代码不会在写入之后执行（哪怕是在其它核上执行）。</strong>也就意味着：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> imptValue = <span class="built_in">computeImportantValue</span>();</span><br><span class="line"></span><br><span class="line">valAvailable = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
编译器必须保证对imptValue和valAvailable赋值操作的顺序，底层相关的硬件也必须保证。因此，将valAvailable定义为std::atomic保证了imptValue在各线程不会再valAvailable之前改变。但是如果把valAvailable定义为volatile，就没有这样类似的打乱顺序的限制：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">bool</span> <span class="title">valAvailable</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> imptValue = <span class="built_in">computeImportantValue</span>();</span><br><span class="line"></span><br><span class="line">valAvailable = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
这样编译器可能就会打乱对imptValue和valAvailable赋值操作的顺序，并且底层的硬件也可能会打乱执行顺序，例如让其它CPU核心的线程在imptValue改变之前改变了valAvailable。<br />
也就是说，voliate有两个问题，无法保证操作的原子性并且在代码打乱顺序操作上没有限制，这也就是volatile没有在并发编程上有太大用处的原因。<br />
但是volatile有它自己的用处，它可以用在特殊行为的内存。在对“普通”内存写入值后，在其它数据覆盖之前是不会有变动的。例如，有一个普通的int变量，并且有如下序列的操作：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// 对x进行读取</span></span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 再次读取x</span></span><br></pre></td></tr></table></figure>
编译器将通过去除对y的复制来优化生成代码，因为它和y的初始化一样，因此是多余的。“普通”的内存中，如果在往内存里写入值之后不再读这个值，然后又往这个内存写入值时，会去除第一次写的操作，因为这个值没有被使用过。这种冗余读的操作通常被称为<strong>冗余负载（redundant
loads）</strong>，而这种多余的写被称为<strong>死储存（dead
stores）</strong>。所以例如： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line"></span><br><span class="line">y = x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;</span><br></pre></td></tr></table></figure> 编译器将会优化成如下代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
这些冗余的代码可能不是编写出的，而是在经过编译器实例化模板、内联以及各种打乱顺序的优化之后得到的代码里有这样冗余的代码，然后编译器会进行如上的优化。这样的优化通常只会发生在“普通”的内存中，“特殊”的内存不会进行上述的优化。最常见的特殊内存是用于内存映射I/O的内存。这种内存通常和外接的设备进行通信，例如：传感器、显示器、打印机等等这类不进行传统I/O操作的内存。我们再来考虑一下这段看上去进行了冗余读的代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line"></span><br><span class="line">y = x;</span><br></pre></td></tr></table></figure>
如果x对应了一个值，这个值来自于温度传感器，第二个x就不是冗余的了，因为温度可能在第一句和第二句代码之间发生改变。也就是说这段看上去冗余的写操作实际上可能进行了如下操作：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
还有可能x对应的是不同无线电发射器的控制端口，如果将第一个复制进行优化去除，那么就会改变了无线电发射器的发送序列。</p>
<p>总之，总结上面，如果读取的或者写入的不是当前内存内的信息时（例如外部内存），就会导致本机无法感知的读或写，这样进行优化无疑是有问题的。而使用volatile就是告诉编译器解决“特殊”内存的问题。它相当于告诉编译器，不要进行任何优化。所以如果x对应的是“特殊”内存，那么应该被定义为volatile。考虑下面这一段代码序列：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 再次读取x，不会被优化去除</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>; <span class="comment">// 再次写入x，不会被优化去除</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;</span><br></pre></td></tr></table></figure> 在这里的y还是volatile
int类型的，这个我们从处理特殊内存时要保留冗余负载和死储存可以得出。<br />
那么这里为什么不可以用std::atomic呢？首先我们先来看看如果x定义为std::atomic的代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> y = x; <span class="comment">// 理论上读取x</span></span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// 理论上再次读取x</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;</span><br></pre></td></tr></table></figure> 代码会被优化成： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> y = x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
这显然对于特殊内存来说是不可接受的行为。而且，这段代码不会被编译通过，因为std::atomic是不可拷贝的。因为之前说过，std::atomic的一切行为都是原子的，为了复制x到y中，编译器会生成代码以原子的操作读x并且写到y，但是硬件没有办法完成这样的操作，因此std::atomic是不可复制的，对于移动操作也是如此，因此std::atomic不存在移动和复制操作。但是还是有方法可以做到将y赋以x的值，只要通过load和store两个函数就行：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">y</span><span class="params">(x.load())</span></span>; <span class="comment">// 读x</span></span><br><span class="line"></span><br><span class="line">y.<span class="built_in">store</span>(x.<span class="built_in">load</span>()); <span class="comment">// 再次读x</span></span><br></pre></td></tr></table></figure>
但是这样做又将x的读（x.load()）和y的初始化和存储混在一起，没有理由将它们作为一个原子操作执行。在得到这样的代码之后，编译器将会进行优化，将x的值存入到寄存器中，一面对其读取两次
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">register</span> = x.<span class="built_in">load</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">y</span><span class="params">(<span class="keyword">register</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">y.<span class="built_in">store</span>(<span class="keyword">register</span>);</span><br></pre></td></tr></table></figure>
但是对于“特殊”内存，这样的优化是不可以的，因此我们可以使用std::atomic和volatile结合的方式：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> std::atomic&lt;<span class="type">int</span>&gt; val;</span><br></pre></td></tr></table></figure>
这种方法是非常实用的，因为它可以用在例如内存映射的I/O设备被并发访问时。</p>
<p>最后有一点还想说明一下，有些开发者喜欢使用std::atomic的load和store成员函数，这种偏好甚至会体现在无须使用它们的情况上。这是不合理的，访问std::atomic通常会比访问非std::atomic的变量速度慢，并且之前就已经说明，std::atomic已经阻止了编译器的优化。调用load和store函数可以帮助确定可扩展性的瓶颈，如果在表示与其它线程交换信息的地方（例如：使用了flag表示数据是否可用）没有看到对变量使用store函数，这可能就意味着这个变量本应声明但没有声明为std::atomic。</p>
<p><strong>总结</strong></p>
<ul>
<li>std::atomic可以在不使用mutex的条件下访问多线程的共享数据，它是并发编程的有用工具。并且会在编译器优化时对执行顺序作出限制，例如：写入std::atomic数据之前的代码不会在写入之后执行。</li>
<li>volatile用于读和写不可以被优化去除的内存中，它是“特殊”内存的有用工具。但是它在编译器优化时不会对执行顺序有限制。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>尽量使用lambda替代std::bind</title>
    <url>/2018/11/13/%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8lambda%E6%9B%BF%E4%BB%A3std_bind/</url>
    <content><![CDATA[<p>C++11中的std::bind继承自C++98的std::bind1st和std::bind2nd，它自从2005年起就是标准库的一部分了。这一年C++标准委员会采用了一份叫做TR1的文档，这份文档中包含了bind的描述（在TR1中，bind函数是在不同的命名空间中，所以它叫std::tr1::bind，而不是std::bind）。bind的这段长久历史就意味着有很多程序员已经拥有丰富的经验使用std::bind.如果你就是其中一个，你可能会不情愿放弃bind这样工具，这也是可以理解的。但是在C++11中你应该改变这种思维，因为lambda总是比std::bind更好的选择。
<span id="more"></span> 在这一篇文章里，我已经假设你熟悉std::bind了。</p>
<p>和在前面文章一样，我们假设称std::bind返回的函数对象叫做绑定对象（bind
object）。</p>
<p>使用lambda而不是std::bind的最重要的理由之一就是lambda可读性更好。例如，我们想写一个函数用于创建闹钟:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个时间点类型</span></span><br><span class="line"><span class="keyword">using</span> Time = std::chrono::steady_clock::time_point;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Sound</span> &#123; Beep, Siren, Whistle &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个时间长度类型</span></span><br><span class="line"><span class="keyword">using</span> Duration = std::chrono::steady_clock::duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在时间t， 发出声音s， 持续d</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d)</span></span>;</span><br></pre></td></tr></table></figure>
假设程序中已经有一些时间点已经设置闹钟，我们还需要在每个现有闹钟后1小时后设置另一个持续30秒的闹钟，至于使用什么声音还没有决定。我们可以写一个lambda修订setAlarm接口，这个接口只需要指定声音:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL = [](Sound s) <span class="comment">// setSound的lambda版本</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="built_in">hours</span>(<span class="number">1</span>),</span><br><span class="line">		s,</span><br><span class="line">		<span class="built_in">seconds</span>(<span class="number">30</span>)</span><br><span class="line">	);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
当然，也可以使用C++14的对秒、毫秒、小时等时间单位的标准结尾:s、ms、h等。这些结尾是补充在C++14的std::literals命名空间中的，代码可以改成如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL = [](Sound s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals; <span class="comment">// 为了使用C++14的结尾</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h, <span class="comment">// C++14写法，和上面代码效果一样</span></span><br><span class="line">		s,</span><br><span class="line">	<span class="number">30</span>s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
如果尝试使用std::bind来写上面的代码，将会是下面的样子，当然下面的代码有一个错误，会在稍后进阶解决，正确的代码会比下面错误的代码更复杂:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders; <span class="comment">// 需要使用“_1”占位符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>( setAlarm, <span class="comment">// setSound的bind版本</span></span><br><span class="line">	steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h,</span><br><span class="line">	_1,</span><br><span class="line">	<span class="number">30</span>s</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
因为在定义绑定对象时，setAlarm的第二个参数还没有决定，因此使用占位符“_1”占位。之后对setSoundB调用时，第一个参数就相当于setAlarm的第二个参数传递过去。因此需要知道setAlarm的声明以决定那种参数传递给setSoundB。</p>
<p>但是之前说了，这段代码不是非常正确。在lambda中，“steady_clock::now()
+
1h”是setAlarm的实参，等价于setAlarm的调用时间之后的1小时。在使用std::bind，就相当于在绑定时就决定了这个参数，因此绑定进setAlarm的是绑定的时间，设置的闹钟则是绑定之后1小时后响30秒的。
解决这个问题需要告诉std::bind在调用setAlarm时在决定这个参数的值，方法就是在原来的std::bind中嵌套另外两个std::bind:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>( setAlarm,</span><br><span class="line">	std::<span class="built_in">bind</span>( std::plus&lt;&gt;(),</span><br><span class="line">		std::<span class="built_in">bind</span>(steady_clock::now),</span><br><span class="line">		<span class="number">1</span>h</span><br><span class="line">	),</span><br><span class="line">	_1,</span><br><span class="line">	<span class="number">30</span>s</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
如果你知道C++98中std::plus的用法，你可能会对上面的代码惊讶，因为std::plus没有在尖括号中指定类型。<strong>在C++14中，对于标准操作符模板可以忽略模板的类型参数，因此可以不提供类型参数。</strong>上面的代码如果使用C++11的std::bind就相当于:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB =</span><br><span class="line">std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">	std::<span class="built_in">bind</span>(std::<span class="built_in">plus</span>&lt;steady_clock::time_point&gt;(),</span><br><span class="line">		std::<span class="built_in">bind</span>(steady_clock::now),</span><br><span class="line">		<span class="built_in">hours</span>(<span class="number">1</span>)</span><br><span class="line">	),</span><br><span class="line">	_1,</span><br><span class="line">	<span class="built_in">seconds</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>当setAlarm被重载，新的问题就又出现了。假设有一个重载的函数有第四个参数用来指定闹钟的音量:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Volume</span> &#123; Time t, Sound s, Duration d, Volume v &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d, Volume v)</span></span>;</span><br></pre></td></tr></table></figure>
之前的lambda仍然有效，因为会自动选择正确的三参数的setAlarm。但是如果std::bind就会出错。<strong>因为编译器只能看到一个函数名，所以编译器无法决定std::bind使用哪个版本的setAlarm，因此就会出现二义性。</strong>为了能使std::bind版本能编译，我们必须要指定使用的哪个版本的setAlarm:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SetAlarm3ParamType = <span class="built_in">void</span>(*)(Time t, Sound s, Duration d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> setSoundB = std::<span class="built_in">bind</span>(<span class="built_in">static_cast</span>&lt;SetAlarm3ParamType&gt;(setAlarm), <span class="comment">// 指定使用了哪种setAlarm</span></span><br><span class="line">	std::<span class="built_in">bind</span>(std::<span class="built_in">plus</span>&lt;steady_clock::time_point&gt;(),</span><br><span class="line">		std::<span class="built_in">bind</span>(steady_clock::now),</span><br><span class="line">		<span class="built_in">hours</span>(<span class="number">1</span>)</span><br><span class="line">	),</span><br><span class="line">	_1,</span><br><span class="line">	<span class="built_in">seconds</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
但是这样又带来了一个问题。在调用setSoundL时，对setAlarm的调用是一个普通的函数调用，编译器可以把这个setAlarm内联(inline):
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setSoundL</span>(Sound::Siren); <span class="comment">// setAlarm的函数体可能会被内联到这</span></span><br></pre></td></tr></table></figure>
而调用std::bind的绑定对象时，调用的是一个函数指针指向的setAlarm，这也就意味着在调用setSoundB时，对setAlarm的调用是通过指针，编译器不太可能会将其内联。:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setSoundB</span>(Sound::Siren); <span class="comment">// setAlarm的函数体不太可能内联到这</span></span><br></pre></td></tr></table></figure> 这也就导致了lambda会产生比std::bind快速的代码。</p>
<p>在上面的setAlarm只是一个例子，因此执行的内容就比较简单，如果你想让setAlarm做比较复杂的事情，你就最好使用lambda。例如你要使用下面的C++14的lambda，它会返回是否参数在下限值（lowVal）和上限值（highVal）之间，上限值和下限值都是本地变量:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> betweenL = [lowVal, highVal](<span class="type">const</span> <span class="keyword">auto</span>&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
std::bind也可以表示同样的事情。下面就是一段可以达成目的的代码，尽管代码有些晦涩难懂:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> betweenB = std::<span class="built_in">bind</span>(std::logical_and&lt;&gt;(),</span><br><span class="line">	std::<span class="built_in">bind</span>(std::less_equal&lt;&gt;(), lowVal, _1),</span><br><span class="line">	std::<span class="built_in">bind</span>(std::less_equal&lt;&gt;(), _1, highVal)</span><br><span class="line">);</span><br></pre></td></tr></table></figure> 而在C++11，则需要指定比较类型，因此代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> betweenB = std::<span class="built_in">bind</span>(std::<span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;(),</span><br><span class="line">	std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), lowVal, _1),</span><br><span class="line">	std::<span class="built_in">bind</span>(std::<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(), _1, highVal)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
因为在C++11中不支持lambda使用auto类型的参数，所以C++11的lambda版本的代码是这样的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> betweenL = [lowVal, highVal](<span class="type">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> lowVal &lt;= val &amp;&amp; val &lt;= highVal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
不论是C++11还是C++14，lambda版本的代码都是又短又容易理解的。</p>
<p>前面我们提到了std::bind的占位符，但是它们的行为不只是占位符，当然这是一个黑盒。假设我们有一个函数用来创建压缩的Widget副本:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">CompLevel</span>&#123; Low, Normal, High &#125;; <span class="comment">// 压缩等级</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">compress</span><span class="params">(<span class="type">const</span> Widget&amp; w, <span class="comment">// 压缩w的副本</span></span></span></span><br><span class="line"><span class="params"><span class="function">	CompLevel lev</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure> 并且我们希望创建一个函数对象，用来指定Widget
w要压缩多少。我们使用std::bind来创建这样的一个对象: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> compressRateB = std::<span class="built_in">bind</span>(compress, w, _1);</span><br></pre></td></tr></table></figure>
现在我们传递给std::bind参数w，w存储在对象compressRateB中，用以稍后作为调用compress的参数。但是如何存储它呢？是std::bind中是存储引用还是存储值呢？这两种方式是有很大的不同的，因为如果w在调用std::bind和调用compressRateB之间发生了改变，存储w的引用将会反映出这个改变，而存储值时则不会发生。
答案是存储了值，我们只能通过记忆std::bind的工作流程来理解。我们先来看与其不同的lambda，对于w的捕获是引用还是存值都是直接写出的：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> compressRateL = [w](CompLevel lev) <span class="comment">// w按值捕获，lev是传值</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">compress</span>(w, lev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 这里很清楚lev是传值传参，因此: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">compressRateL</span>(CompLevel::High); <span class="comment">// 参数按值传递</span></span><br></pre></td></tr></table></figure></p>
<p>在调用std::bind返回的对象时，它是如何传参的？ <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">compressRateB</span>(CompLevel::High);</span><br></pre></td></tr></table></figure>
<strong>所有传递给std::bind的参数都是按引用传递，因为函数调用操作符使用的是完美转发。</strong></p>
<p>和lambda对比，使用std::bind的代码会令人觉得可读性很差，并且有可能带来低效率。在C++14中没有理由使用std::bind。在C++11中，std::bind可以适用于两种条件下:</p>
<ol type="1">
<li>移动捕获：C++11不提供移动捕获，但是可以通过std::bind模拟这一行为。而在C++14中lambda支持初始化捕获，这也就淘汰了模拟移动捕获。</li>
<li>复合函数对象：因为绑定对象的函数调用操作符使用完美转发时，可以接受任何类型的参数（完美转发的使用限制详见：<a
href="/2018/11/06/几个完美转发失败的条件/">几个完美转发失败的条件</a>）。如果你想要绑定一个对象，并定义调用操作符使用它，那么std::bind就非常有用了:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PolyWidget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">		<span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; param)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> std::bind可以如下绑定一个PolyWidget: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PolyWidget pw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> boundPW = std::<span class="built_in">bind</span>(pw, _1);</span><br></pre></td></tr></table></figure>
boundPW可以使用任意参数（有几种失败情况）去调用。而在C++11的lambda中是没有办法做到的。在C++14中，可以轻易达到目的，方式是使用auto类型的参数:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> boundPW = [pw](<span class="type">const</span> <span class="keyword">auto</span>&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">pw</span>(param);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这两种情况是两种边缘情况，不过你不用纠结，因为C++14的编译器已经很流行了。</p>
<p><strong>总结</strong></p>
<ul>
<li>相较于std::bind，lambda表达式可读性更好，并且有时效率更高。</li>
<li>只在C++11，std::bind在两种情况下可能会变得有用：模拟移动捕获和绑定了重载调用操作符模板函数的对象。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>尽量使用nullptr替代0和NULL</title>
    <url>/2018/09/25/%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8nullptr%E6%9B%BF%E4%BB%A30%E5%92%8CNULL/</url>
    <content><![CDATA[<p>nullptr是C++11的新特性。它诞生之前，我们对于指向空的指针都是进行赋NULL或者0。但是因为C++11中引入了类型推测的缘故，这样做很容易导致程序无法编译通过，所以需要一种表示指向空的指针的数据类型。nullptr由此诞生。
<span id="more"></span></p>
<p>传统做法带来的问题，其实不光在新的C++11标准中。例如在如下代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(<span class="number">0</span>); <span class="comment">// call f(int)</span></span><br><span class="line">	<span class="built_in">f</span>(<span class="literal">NULL</span>); <span class="comment">// error! ambiguous.</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 无论如何都不可能调用f(void*)的重载函数。</p>
<p>而在C++11的新特性中，还会遇到这样的麻烦: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType,</span></span><br><span class="line"><span class="function">	<span class="keyword">typename</span> PtrType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">executeFunc</span><span class="params">(FuncType func, PtrType ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">func</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">executeFunc</span>(func, <span class="literal">NULL</span>); <span class="comment">// error! Due to NULL is not a pointer.</span></span><br><span class="line">	<span class="built_in">executeFunc</span>(func, <span class="literal">nullptr</span>); <span class="comment">// ok</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为PtrType类型推测出来是一个long型，与实际func需要的std::shared_ptr是不符的，所以编译失败。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>尽量使用基于任务的编程替代基于线程的编程</title>
    <url>/2018/11/16/%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E6%9B%BF%E4%BB%A3%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>如果你想异步运行函数doAsyncWork，你有两种最基本的选择。一个是创建一个std::thread，然后再在这个线程上运行doAsyncWork，这种方法称为<strong>基于线程</strong>的，代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">doAsyncWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">std:: <span class="function">thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>;</span><br></pre></td></tr></table></figure>
或者你可以传递给std::async参数doAsyncWork，这叫做<strong>基于任务</strong>的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(doAsyncWork); <span class="comment">// fut是future的缩写</span></span><br></pre></td></tr></table></figure> <span id="more"></span>
上面的调用中，传递给std::async的函数对象就被看作是一个任务（task）。</p>
<p>基于任务的方法通常要比基于线程的方法要好。首先从<strong>代码的长短上</strong>就能看出一些优势。这里的doAsyncWork产生了一个返回值，<strong>如果我们需要这个返回值，使用基于线程的方法就没有直接的办法做到，而如果使用基于任务的方法，这就变得很容易了。基于任务的方法中，有std::async返回的future提供了get方法用于获取返回值。</strong>这个get方法在doAsyncWork<strong>抛出异常时还可以对异常进行访问。</strong>而是用基于线程的方法时，如果soAsyncWork抛出异常，程序就消亡了（执行了std::terminate）。</p>
<p>还有一个看上去更加底层的区别就是基于任务的方法相比具有更高的抽象，可以解决例如“超额认购”(oversubscription)的问题。它可以让你从线程管理中解脱出来。我这里先来说在C++并发软件中的三种“线程”的意思：</p>
<ul>
<li>硬件线程：是计算机中真实进行计算的线程。并发的计算机体系中，每个CPU核心提供一个或多个的硬件线程</li>
<li>软件线程：也称作为操作系统线程和系统线程。它们是由操作系统管理的线程，横贯所有的在硬件线程上执行时的处理和调度。软件线程的数量可以大于硬件线程的数量，因为软件线程的可以被阻塞（例如：在I/O时或者等待信号量的时候），因此程序的效率也可以通过阻塞线程、执行其它线程来实现。</li>
<li>std::thread：是C++中依赖于软件线程实现处理的对象。一些std::thread代表了对“null”的处理，也就是没有和任何软件线程通信，这是也默认构造的状态，代表没有函数在执行、被移到其它std::thread（被移到的std::thread将会接替原来的继续依赖底层的软件线程处理）、被join了（这个函数被用于阻塞进程直到线程执行结束）或者是被detach了（这个函数用于切断std::thread和它正依赖的软件线程之间的依赖）。
软件线程的数量是有限制的。如果你试着创建超过系统能承受数量的软件线程，系统就会抛出一个std::system_error异常。如果你的函数不能抛出异常，std::system_error还是会抛出。例如doAsyncWork是nonexcept的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">doAsyncWork</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure> 这句话可能就引发异常: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>; <span class="comment">// 如果没有足够的软件线程可用，仍然会抛出异常</span></span><br></pre></td></tr></table></figure>
优秀的代码应该避免超过系统承受的软件线程的问题。一个方法是在当前线程上运行doAsyncWork。但是这可能会导致不均衡的负载，如果当前的线程是一个GUI线程，那么可能还会导致响应能力的问题。另一个方法就是等待一些已经存在的软件线程执行完毕，然后再试着创建一个新的std::thread。但是这个方法可能就造成死锁，因为可能会存在线程等待doAsyncWork执行完成的情况。</li>
</ul>
<p>即使你没有运行过多的线程，你也会有“超额认购”（oversubscription）的麻烦。当你有比硬件线程数量多的就绪的软件线程时，就会出现超额认购。当超额认购发生时，线程调度器（操作系统的一部分）分配给硬件上的软件线程时间片。当一个线程的时间片用完时，另一个线程就开始，线程切换时会进行上下文切换。这个上下文切换增加了系统线程管理的负担。尤其在被调度的软件线程所在的硬件线程在不同的核心上时，就会耗费更多的资源。并且在这种情况下，通常只有极少的cache命中线程的数据和指令，新的软件线程的运行“污染”了这个核心上运行的老的、有可能会在这课核心上再次运行的软件线程留下的cache。</p>
<p>避免超额认购问题是非常困难的。因为软件线程和硬件线程数量的比值取决于软件线程的运行频率并且这个频率是动态的，例如：当程序从运行在密集I/O的部分到密集计算部分时。最佳的比值还取决于上下文切换的消耗以及软件线程使用cache的频率。当然还离不开硬件线程的数量以及cache的具体情况（例如缓存的大小以及读写速度），这些都依赖于机器的结构。因此即使你的应用在某一平台上避免了超额认购的问题，在其它平台上还是有可能出问题的。</p>
<p>如果你使用std::async,例如： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(doAsyncWork);</span><br></pre></td></tr></table></figure>
调用就会使用C++标准库来管理线程。例如，超过系统承受的最大软件线程异常就会减少很多，因为使用上面的调用就不会发生这样的异常。std::async在调用时不保证会创建一个新的软件线程，它只是允许线程调度器为某个函数安排一个新线程用以获取结果，如果软件线程数量超出了系统的承受范围，系统将有自由不分配软件线程。</p>
<p>如果你相信“将函数运行在需要它运行结果的线程上”这种话时，你很有可能会写出有负载均衡问题的代码。这时你可以使用std::async，运行时调度比你更清楚机器发生了什么，因为它管理着来自所有处理器的线程，不只是你的代码正在运存的那个线程。</p>
<p>如果使用std::async，对于GUI线程的响应度的问题仍然无法解决。因为调度器无法知道哪一个线程有更高的优先级，这时你可以传递std::launch::async启动策略，它将会确保你要运行的GUI绘制是在一个不同的线程上，而不是get调用的线程上，并且还是立即执行（请参看：<a
href="/2018/11/21/如果任务必须执行，请指定使用stdlaunchasync启动策略/">如果任务必须执行，请指定使用std::launch::async启动策略</a>，言外之意就是说，默认的std::async可能导致线程不执行或者延迟执行，导致GUI响应度降低。）。</p>
<p>线程调度使用了和系统线程最大数一样的线程池用以避免超额认购，以及使用工作窃取算法（work-stealing
algorithm）提升负载均衡。C++标准没有要求使用线程池或者工作窃取，但是在标准库中许多容器中已经使用了这项技术。如果你使用了一个基于任务的方法编程，你肯定会感叹于它的方便。而你如果直接使用std::thread，你将要解决一堆线程资源的耗尽、超额认购以及负载均衡的问题，而且还要考虑如何在其它机器上也能解决这些问题。</p>
<p><strong>和基于线程编程相比，使用基于任务的设计可以让你从一堆手动要解决的线程管理问题上解脱，而且还提供了自然方法去检验函数的异步执行情况。</strong></p>
<p>不过std::thread还是有它独特的使用场景的。下面列举几种： *
你需要使用依赖的线程实现的API。C++并发的API通常都是根据平台选择底层API实现的，例如pthread或者Windows的线程。这些API比C++的要丰富。（例如C++没有线程的优先级）为了访问这些底层实现的线程API，你就要使用std::thread对象中提供的native_handle成员函数，其中没有和std::future功能类似的函数。
* 你需要并且有能力优化你应用中线程的使用。 *
你需要跨越C++并发API实现某个线程技术。例如：在C++没有实现的平台上实现线程池。</p>
<p><strong>总结</strong></p>
<ul>
<li>std::thread的API没有提供方法用于获取异步执行的函数的返回值，并且如果这些函数抛出异常，就立刻中止程序。</li>
<li>基于线程的调用需要你手动管理线程耗尽、超额认购、负载均衡以及新平台适配等问题。基于任务的编程可以将这些问题交给系统解决。</li>
<li>使用通过std::async的基于任务的编程时，默认的策略解决了几乎你要考虑的所有问题。响应优先级问题可以通过std::launch::async启动策略解决。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>智能指针中make_xxx函数和new的使用</title>
    <url>/2018/10/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%ADmake_xxx%E5%87%BD%E6%95%B0%E5%92%8Cnew%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在前面的std::unique_ptr、std::shared_ptr智能指针的介绍中，都介绍了使用new的方式构造智能指针。接下来我们会着重将使用new构造智能指针的方式和使用std::make_unique、std::make_share的方式进行比较。
<span id="more"></span>
对于std::make_unique函数，这个是C++14标准中的新函数，它的实现大体如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt; std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="make函数的优势">make函数的优势</h1>
<h2 id="make可以少写一次类型">make可以少写一次类型</h2>
<p>少写类型最简单的好处就是可以少写代码。其次代码的重复会导致复杂的代码和浮肿的对象代码，并且通常会生成复杂的代码，这些代码会导致包括但不限于代码的无常变化，这种现象通常会导致bug。</p>
<h2 id="使用make可以保证异常安全">使用make可以保证异常安全</h2>
<p>假设有如下的函数定义: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="type">int</span> priority)</span></span>; </span><br></pre></td></tr></table></figure>
我们使用new构造std::shared_ptr，这样调用这个函数: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">computePriority</span>()); <span class="comment">// 这样可能会导致异常 </span></span><br></pre></td></tr></table></figure>
我们来看一下编译流程:</p>
<ol type="1">
<li>在堆上构造Widget。</li>
<li>构造shared_ptr，参数使用上面在堆上构造的Widget对象。</li>
<li>执行computePriority()。</li>
</ol>
<p>但是记住，编译器没有承诺它会按照如上流程进行编译。也就是说上面的流程只是我们的想象，如果编译器用如下的流程编译，就可能会出现内存泄露:</p>
<ol type="1">
<li>在堆上构造Widget。</li>
<li>执行computePriority()。</li>
<li>构造shared_ptr，参数使用上面在堆上构造的Widget对象。</li>
</ol>
<p>当在第二步的时候，也就是执行computePriority时出现了异常，退出了processWidget函数时，Widget对象就会内存泄露。因为std::shared_ptr不会构造，对第一步的Widget的控制就会消失。
所以使用make函数的最重要的原因之一就是保证异常安全。我们可以这样编写上面的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">make_shared</span>&lt;Widget&gt;(), <span class="built_in">computePriority</span>());</span><br></pre></td></tr></table></figure> 这样就可以避免了上面可能会出现的内存泄漏。</p>
<h2 id="可以提高代码的效率">可以提高代码的效率</h2>
<p>之前讲过，shared_ptr是有两个指针指向两块空间，一个是对象，一个是控制块。如果我们使用了std::make_share构造std::shared_ptr，编译器会自动将代码优化将对象和控制块的空间一起开辟以精简代码并提高效率。如果使用new，对象和控制块很有可能就是分开开辟的，需要两次开辟空间。
另外使用make减少了一些在控制块中用于记录的空间，隐含地减少了一些内存空间。同样的std::allocate_shared函数在原理上和std::make_shared类似，因此效率也类似。</p>
<h1 id="make函数的局限性">make函数的局限性</h1>
<h2 id="无法自定义销毁过程">无法自定义销毁过程</h2>
<p>unique_ptr和shared_ptr的销毁过程都是通过构造函数实现的，因此如果要自定义销毁过程必须使用构造函数的方式。</p>
<h2
id="无法一步使用initializer_list的方式构造对象">无法一步使用initializer_list的方式构造对象</h2>
<p>在make函数中，所有参数都是以括号的方式构造，而不是使用initializer_list方式。如果要使用initializer_list的方法构造对象，只能使用如下的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> initList = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure></p>
<h1 id="杂项">杂项</h1>
<h2
id="不要使用重载的newdelete操作符构造被指向的对象">不要使用重载的new、delete操作符构造被指向的对象</h2>
<p>new、delete操作符通常用于构造或销毁大小正好是对象的size的对象。这种方法通常不适用于shared_ptr指向的对象的构造和销毁，因为使用std::allocate_shared函数开辟的空间并不是对象的大小，而是对象加上控制块的大小，所以用new、delete操作符以make函数构建或销毁对象是不合理的想法。</p>
<h2
id="stdmake_shared构造时的对象和控制块的销毁时间">std::make_shared构造时的对象和控制块的销毁时间</h2>
<p>使用std::make_shared构造的std::shared_ptr指针，当std::shared_ptr的引用计数器计数为0，那么它就会销毁这个指向的对象。但是在控制块被销毁之前，空间不会释放，这是因为两者的空间是一个整体，只能两者一起销毁。
控制块中存放了一些额外信息，这些信息中有一个弱计数器(weak
count)是用来记录指向当前对象的std::weak_ptr的数量。当std::weak_ptr检查自身时，首先检查引用计数器是否为0，并以此决定返回指向的对象还是nullptr，这个过程我们在<a
href="/2018/10/12/weak_ptr的使用">weak_ptr的使用</a>中也讲过。只要存在std::weak_ptr指向这个对象，这个对象就不能销毁。<strong>因此如果指向的对象是一个十分巨大的对象时，我们可以利用new的方式构造对象，这样可以在引用计数器为0而弱计数器不为0的时候销毁并释放对象的空间，只留下控制块。</strong>
如果你还关注异常的处理问题时，你可以使用单独语句构造对象，然后把对象作为构造参数的方式来避免这种问题:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, customDel)</span></span>; <span class="comment">// 单独语句构造对象</span></span><br><span class="line"><span class="built_in">processWidget</span>(spw, <span class="built_in">computePriority</span>()); <span class="comment">// 对象作为构造函数的参数</span></span><br></pre></td></tr></table></figure>
上面代码中，即使spw的构造函数出现了问题，抛出了异常，也会保证customDel可以得到指向。
如果这样执行可以得到异常安全的代码，但是在异常不安全的代码中，processWidget的构造函数的第一个参数是右值，因此，它会使用移动的方式移动一个std::shared_ptr。但是使用单独语句构造对象的异常安全的代码的第一个参数是spw，是一个左值，使用的复制的方式，效率上会有损耗，因为我们之前也讲过需要对引用计数器加一操作。为了使代码更高效，我们做如下修改:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, customDel)</span></span>; <span class="comment">// 单独语句构造对象</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">move</span>(spw), <span class="built_in">computePriority</span>()); <span class="comment">// 对象作为构造函数的参数</span></span><br></pre></td></tr></table></figure></p>
<p>引用《Effective Modern
C++》中的一句话：大多数情况下使用make_xxx函数是明智的。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>康拓展开及其逆运算</title>
    <url>/2020/05/20/%E5%BA%B7%E6%8B%93%E5%B1%95%E5%BC%80%E5%8F%8A%E5%85%B6%E9%80%86%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="康拓展开">康拓展开</h1>
<p>康拓展开用于计算某一排列在所有从小到大的全排序中的顺序，例如求：[1,3,2]在其全排列：[1,2,3]、[1,3,2]、[2,1,3]、[2,3,1]、[3,1,2]以及[3,2,1]的位置，这里显然是在第二个。</p>
<p><strong>另外注意：应用康拓展开的数列中不可以有重复的数字。</strong></p>
<p>康拓展开可以用于哈希压缩，例如有一组连续数字组成的无重复元素的排列，我们可以根据康拓展开将其压缩为其在全排列中的位置。</p>
<h2 id="公式">公式</h2>
<p>康拓展开的基本公式如下： <span class="math display">\[X = a_{1} * (n
- 1)! + a_{2} * (n - 2)! + ... + a_{n} * 0!\]</span> 其中<span
class="math inline">\(a_{i}\)</span>表示在当前排列中，第i位之后的数中小于第i位数的个数。
<span id="more"></span> ## 举例
例如：排列[2,5,4,1,3]，求其在全排序中的顺序，我们套用如上公式：<span
class="math inline">\(X = 1 * 4! + 3 * 3! + 2 * 2! + 0 * 1! + 0 * 0! =
46\)</span>，也就是从初试排列[1,2,3,4,5]到此排列需要经过46次排序换位，是全排列中的第47个。
这里解释一下上面公式的代入：
第一个2的后面只有1比它小，以1开头的排列有4!个，因此第一项为1*4!。
第二个5的后面有1、3、4比它小，因为2已经出现在了5前面，因此不考虑。这样的排列有3!个，因此第二项为3
* 3!。 以此类推。</p>
<h1 id="康拓展开的逆运算">康拓展开的逆运算</h1>
<p>康拓展开逆运算就是求某一排序位置的排序。</p>
<h2 id="举例">举例</h2>
<p>例如有一个由5个数组成的从0开始连续的不含重复元素的序列，要求它第96个的排列，我们可以如下处理：</p>
<p>由于第96个排列需要从初始位置进行95次换序，因此96-1。
用95除以4!，得3余23，说明目标排列有3个数比第1个数小，因此第1个数取4。
用23除以3!，得3余5，说明目标排列有3个数字比第2个数小，而4已经取过，因此第2个数取5。
用5除以2!，得2余1，类似如上所述可得3。 用1除以1!，得1余0，可得2。
最后一位只能是1。 因此目标排列为[4,5,3,2,1]。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>欧几里得算法与扩展欧几里得算法</title>
    <url>/2019/03/21/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="欧几里得算法">欧几里得算法</h1>
<p>欧几里得算法可以用于计算两个数的最大公约数。<span id="more"></span>它的具体形式如下：
<span class="math display">\[ gcd(a, b) = gcd(b, a \% b) \]</span></p>
<h2 id="实现">实现</h2>
<p>如果用C语言实现，它的代码可以如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="证明">证明</h2>
<p>设<span class="math inline">\(r = a \% b\)</span>，则<span
class="math inline">\(a = k * b + r\)</span>，移项得<span
class="math inline">\(r = a - k * b\)</span>。再设<span
class="math inline">\(d = gcd\left(a, b\right)\)</span>，显然<span
class="math inline">\(d | a\)</span><span
class="math inline">\(且\)</span><span class="math inline">\(d |
b\)</span>，由此可以推出<span class="math inline">\(d |
r\)</span>，即<span class="math inline">\(d | a \%
b\)</span>。因此可得a、b的公约数也是b、a % b的公约数。</p>
<p>如何证明是最大的公约数呢？假设b和<span class="math inline">\(a \%
b\)</span>存在更大的公约数q，<span class="math inline">\(q |
b\)</span>且<span class="math inline">\(q | (a - k * b)\)</span>
，可得<span class="math inline">\(q | a\)</span>
。所以如果假设成立，那么存在更大的公约数q，使得<span
class="math inline">\(q | a\)</span>且<span class="math inline">\(q |
b\)</span>。因为d已经是a、b的最大公约数，所以<span
class="math inline">\(q = b\)</span>。因此得证。</p>
<h1 id="扩展欧几里得算法">扩展欧几里得算法</h1>
<p>扩展欧几里得算法，就像它的名字一样，是从欧几里得算法上扩展而来。它是用来计算如下不定方程：</p>
<p><span class="math display">\[ax + by = gcd(a, b)\]</span></p>
<p>根据裴蜀定理，如上的方程肯定是有解的。</p>
<h2 id="原理">原理</h2>
<p>扩展欧几里得算法基于欧几里得算法得出。</p>
<p>设 <span class="math display">\[
\begin{aligned}
    &amp; gcd(a, b) = a{x}_1 + b {y}_1 \\
    &amp; gcd(b, a \% b) = b{x}_2 + (a \% b){y}_2 \\
\end{aligned}
\]</span> 则 <span class="math display">\[
\begin{aligned}
      &amp;gcd(a, b) \\
    = &amp;gcd(b, a \% b) \\
    = &amp;b{x}_2 + (a \% b){y}_2 \\
    = &amp;b{x}_2 + (a - [a / b] * b){y}_2 \\
    = &amp;b{x}_2 + a{y}_2 - [a / b] b{y}_2 \\
    = &amp;b({x}_2 - [a / b]{y}_2) + a{y}_2
\end{aligned}
\]</span></p>
<p>由待定系数法可得：</p>
<p><span class="math display">\[\begin{equation}
    \left\{
        \begin{aligned}
            {x}_1 &amp; = {y}_2 \\
            {y}_1 &amp; = {x}_2 - [a / b]{y}_2
        \end{aligned}
    \right. \nonumber
\end{equation}\]</span></p>
<h2 id="实现-1">实现</h2>
<p>用C语言的实现如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">extendEuclid</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)</span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> q = <span class="built_in">extendEuclid</span>(b, a % b, x, y);</span><br><span class="line">	<span class="type">int</span> t = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = t - a / b * y;</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个代码也可以进行优化，优化结果如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">extendEuclid</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)</span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> q = <span class="built_in">extendEuclid</span>(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数论</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>新标准中的enum</title>
    <url>/2018/09/26/%E6%96%B0%E6%A0%87%E5%87%86%E4%B8%AD%E7%9A%84enum/</url>
    <content><![CDATA[<p>在C++11标准中我们引入了enum
class，它和C++98标准中的enum一样都是枚举类型，但是还是有很多差别。在这我们就来学习两者之间的差异。
<span id="more"></span> # 作用域</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">// C++98 </span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>; <span class="comment">// error! redefinition of &#x27;white&#x27; </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; black, white, red &#125;; <span class="comment">// C++11 </span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>; <span class="comment">//ok </span></span><br></pre></td></tr></table></figure>
<p>可以看出C++98标准enum中的white作用域是在当前的定义域中，在这个定义域中再次定义white就会出现重定义。而在C++11中，enum
class中white的定义域是在这个enum class内，我们在enum
class所在定义域中定义white不会出现重定义。</p>
<h1 id="enum接受自动类型转换">enum接受自动类型转换</h1>
<p>在enum中，成员可以根据需要转换成整数型（在通过整型转换成浮点型等）。而enum
class则不是，它的成员是Color类的对象，虽然从二进制角度看成员是存放整型信息的，但是它还是一个Color对象。我们通过下面的代码来理解:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; param &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Color</span>&#123; black, white, red &#125;; </span><br><span class="line">	<span class="built_in">f</span>(white);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> white根据需要转换成了int型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; param &lt;&lt; std::endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">Color</span>&#123; black, white, red &#125;;</span><br><span class="line">	<span class="built_in">f</span>(Color::white); <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这时编译器会报错，我这里的错误是说找不到f的重载函数参数是Color，而且Color也没有办法转换成int类型。也就是说Color::white是以Color对象传参，并且不会进行类型转换。
这时如果执意要使用enum
class的成员转换成int，可以使用static_cast进行转换，毕竟它们是二进制相同的。</p>
<h1 id="提前声明">提前声明</h1>
<p>所谓提前声明就是说变量在某处声明，但是不进行初始化。enum是不支持的，而enum
class就是支持的。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span>; <span class="comment">// error!</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">B</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
导致这样的原因是enum有时会使用紧凑的存储结构，<strong>enum的大小不光由成员的数量决定，还有成员的数据范围决定，因为这个数据范围决定了成员实际使用的内存大小。</strong>当然这只是有时，因为这种紧凑的数据结构可能会牺牲效率，有时为了效率编译器还是会使用非紧凑类型的数据结构。但是这种特别的问题就导致了enum不可以提前声明。
解决这种问题的方法是告诉编译器enum的成员都是用什么数据类型。具体代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>: std::<span class="type">uint32_t</span>; <span class="comment">//使用32位无符号整型作为一个对象的大小 </span></span><br></pre></td></tr></table></figure> 这样就可以提前声明enum了。 虽然enum
class默认使用了int作为一个对象的内存大小，但是也可以使用上面的方法修改这一默认值:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>: std::<span class="type">uint32_t</span>; </span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<ul>
<li>C++98的enum是没有作用域的枚举类型，它的成员的作用域是enum的定义范围。而C++11的enum
class不是，只能在enum class中可见。</li>
<li>enum的默认成员类型是不确定的，而enum class则使用了int型。</li>
<li>enum
class始终可以提前声明，但是enum只有在明确了成员类型才可以提前声明。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式基础</title>
    <url>/2019/02/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>正则表达式在计算机的学习中是一项必不可少的环节。之前一直有一些接触，但是始终还是处于要用了查文档的阶段，没有系统的学习。这次就抽空系统学习正则表达式。
<span id="more"></span> 特殊字符 ----</p>
<h3 id="文字字符">文字字符</h3>
<p>所谓文字字符就是没有特殊意义的字符，它是相对于特殊字符，具体可以查看特殊字符部分。<strong>对于文字字符，匹配的结果是字符在目标字符串中第一次的出现。</strong></p>
<p>例如：正则表达式<em>a</em>，它是一个文字字符。对于字符串<em>Bach is a
man</em>，它会匹配第一个Bach中的a，而man中的a则不会进行匹配，因为它不是出现在第一个。</p>
<p>同理对于正则表达式<em>dog</em>，对于字符串<em>Hot dog is not a
dog</em>，它会匹配第一个Hot dog中的dog，而不会匹配a dog中的dog。</p>
<h3 id="特殊字符">特殊字符</h3>
<p>特殊字符就是指在正则中有特殊作用的字符，它就和C语言中的函数printf中的“%”一样。它的存在是为了让正则能更简洁地表达。</p>
<p><strong>在正则表达式中，一共有12个特殊字符，它们也被称为<em>元字符</em></strong>：</p>
<p>反斜杠<strong>*<em>、脱字号<strong>^</strong>、美元符号<strong>$</strong>、点<strong>.</strong>、垂直符号<strong>|</strong>、问号<strong>?</strong>、星号</em>、加号</strong>+<strong>、开括号</strong>(<strong>、闭括号</strong>)<strong>、开方括号</strong>[<strong>以及开花括号</strong>{**。</p>
<p>通常在单独使用这些元字符时是会发生错误的。但<strong>如果你只想使用这些特殊字符的字面含义的时候，你可以在它们之前加一个反斜杠。</strong></p>
<p>例如：你想匹配1+1=2这个字符串，你就可以使用<em>1\+1=2</em>这个正则来完成。如果你没有这么做，那么就会得到一个错误提示。</p>
<p>但是有一个例外。对于花括号，通常解析正则表达式时除非它是重复操作符的一部分，否则就会把它当成一个文字字符，例如：<em>a{1,5}</em>。不过还是建议使用反斜杠以区别，因为在Java等许多语言中还是会出现问题，它们不会像上面那样。</p>
<p>同样的，对于闭方括号<strong>]</strong>，如果它在字符类外，那么它就是一个文字字符，但如果在字符类内，那么就会使用另一套规则。不过还是一样，推荐使用反斜杠区别文字字符和特殊字符的闭括号，因为在Ruby等语言中不会如上所做。</p>
<p><strong>除了特殊字符外，其它字符请不要使用反斜杠，因为反斜杠也是一个特殊字符，它结合一个文字字符会有特殊含义，例如：-9数字的缩写。</strong></p>
<p><strong>我们还可以使用。</strong>例如：对于正则表达式<em>，它会匹配上字符串</em><em>，也就是。还有，就是，也就是正则</em><em>和</em>是一样的，这在PHP、Java等中是支持在字符类内和外使用这种写法。</p>
<p>另外还要注意，在编程时有时要分别注意反斜杠在编程语言和正则中的规则。例如对于正则表达式<em>1\+1=2</em>，在C语言中，如果你要使用一个字符串存储这个正则，那么你就要写成<em>1\+1=2</em>。因为在C语言字符串中反斜杠也是一个特殊字符。</p>
<h2 id="不可显示的字符">不可显示的字符</h2>
<p>不可显示的字符是指的例如换行、水平制表符、tab符等无法打印出具体字符的字符。</p>
<p>对于这些字符的处理是比较凌乱的。例如换行符，在Windows和Unix中是不一样的，Windows使用，而Unix使用。这里就要结合具体情况了，就比如一段Windows上编码的文本在Unix下进行正则匹配，那么就要使用Windows的规则。</p>
<p>**对于这些特殊字符还可以使用*，也就是使用反斜杠加小写c加一个大写的字母组成，代表着Control+A到Control+Z。当然也可以使用01到1A来表示，它们是等价的。例如：，它也可以使用0D、00D替代。</p>
<p>不过使用，因为在不用的应用中行为可能不一样。有的应用支持，这样有时候有的应用就会需要5位来存储正则代码，而有的可能会指向Unicode的第一字节把它当成一个ASCII处理。还有时有的应用只允许到0x40，然后到会因为超过0x40又代表了0x00到0x1F。</p>
<p>因此我们要分情况处理，对于支持Unicode的引擎，使用的方式插入Unicode。</p>
<p>**而对于换行符，除了上面介绍的方法之外，我们还可以使用***，它包含了Unicode的换行。而且*匹配的是所有换行符，包括。</p>
<p>对于，要注意一点，它是匹配，也就是说，例如*的正则，可以匹配字符。</p>
<h2 id="字符类字符集">字符类（字符集）</h2>
<p>字符类，又被成为字符集，是用于告诉正则引擎匹配在几个字符中匹配出一个。例如：对于字符串gray和grey，你可以使用正则<em>gr[ae]y</em>进行匹配，而对于字符串graay或graey就不能使用这个正则进行匹配了。</p>
<p>在字符类中，你可以使用横线。例如：<em>[0-9]</em>，它可以匹配一个单独的数字，位于0和9之间；或者你还可以使用一个<em>[0-9a-fA-F]</em>匹配一个八进制数字。</p>
<h3 id="否定字符类">否定字符类</h3>
<p>对于否定字符类，就是指匹配不在所给范围内的字符。它和点（.）不一样，<strong>否定字符类还会隐含匹配换行符</strong>。如果你不希望这样，你需要在否定字符类中指定换行符，例如：<em>[^0-9]</em>将会匹配任一非数字和换行符。</p>
<p>另外还要明确，<strong>否定字符类是需要进行对字符进行匹配的</strong>。例如正则<em>a[^n]</em>表示的是“匹配一个a后面跟着一个字符不是n”，而不是“匹配一个后面不是n的a”，也就是说，否定字符类的前提是有字符的存在。</p>
<h3 id="对于元字符的处理">对于元字符的处理</h3>
<p><strong>在字符类中，只有闭方括号]、反斜杠、脱字符^以及连字符-是特殊字符，而其余的字符都是了普通字符。</strong>例如：正则<em>[+]</em>可以匹配1+1=2。</p>
<p><strong>要想使用这里的特殊字符的字面意义，只要在前面加一个反斜杠即可</strong>，例如：正则<em>[\]</em>可以匹配字符串1\1=1。</p>
<p>不过还有可以不使用反斜杠转义就使用特殊字符的字面意义匹配的写法。对于脱字符<sup>，可以把它放到非开方括号的右侧即可，例如：<em>[x<sup>]<em>。而闭方括号可以放到开方括号的右侧或者否定字符类的否定脱字符^的右侧，例如：</em>[]x]<em>或者</em>[</sup>]x]</em>。对于连字符，可以放到开方括号的右侧、闭方括号的左侧以及否定字符类的否定脱字符</sup>的右侧，例如：<em>[-x]</em>、<em>[x-]</em>以及<em>[<sup>-x]<em>、</em>[</sup>x-]</em>。</p>
<h3 id="重复字符类">重复字符类</h3>
<p>之前我们说的字符类仅仅可以匹配一个字符，**如果我们要重复使用这些字符类时，可以使用问号?、星号*以及加号+**。</p>
<p>**问号?表示重复0或1次；星号*表示重复任意次，包括0次；加号+表示重复非零次。**</p>
<p><strong>另外注意，以上三种均为贪婪的。</strong>例如：正则表达式ABC*，字符串ABC，匹配结果是ABC，而不是AB。如果如上重复字符符号后面加上一个问号，那么就会变得懒惰。例如：正则表达式<em>ABC+?</em>，字符串ABCCC的结果就是AB；<em>ABC??</em>匹配的结果就是AB。</p>
<h3 id="字符类的减法">字符类的减法</h3>
<p>在 XML
Schema, XPath, .NET等语言中，还支持一种字符类的减法。就是匹配在一个字符类但不在另一个字符类的字符。它的形式就是<em>[class-[subtract]]</em>，也就是如果在某个连字符后面的字符是一个开方括号，那么就自动认为这是一个字符类的减法。</p>
<p>例如：<em>[a-z-[aeiou]]</em>匹配非元音字母，如果不适用字符类的减法，那么将会是<em>[b-df-hj-np-tv-z]</em>，明显就很麻烦。</p>
<p><strong>对于字符类减法的否定字符类，它的规则是先否定，再减法。</strong>例如：<em>[^1234-[3456]]</em>，它的顺序是先否定1234，再用否定后的集合减去3456，因此匹配7890。</p>
<h3 id="字符类的交集">字符类的交集</h3>
<p>字符类的交集就是匹配同时满足多个字符类的字符，目前是Java、Ruby1.9之后的版本支持。它的形式是<em>[class&amp;&amp;[intersect]]</em>。如果没有脱字符作否定字符类，那么你还可以省略intersect外的方括号，也就是这样：<em>[class&amp;&amp;intersect]</em>。</p>
<p>我们举一个例子：<em>[a-z&amp;&amp;[^aeiuo]]</em>可以匹配非元音字符。如果我们不用交集来表示，那么正则表达式就会变成：<em>[b-df-hj-np-tv-z]</em>，更加麻烦。</p>
<p>多个字符类的交集可以合并在一起写，例如：[1-5&amp;&amp;[7-8]&amp;&amp;0]等等。</p>
<p><strong>在否定字符类的交集当中，规则和减法不一样，这里是先交集，再否定。</strong>例如：<em>[<sup>1234&amp;&amp;3456]<em>匹配的就是除了34以外的字符。如果你想做到和减法一样，先否定再减法，那么你可以这么写：</em>[[</sup>1234]&amp;&amp;3456]</em>。</p>
<h3 id="字符类的缩写">字符类的缩写</h3>
<p>上面我们讲了很多关于字符类的使用，对于一些比较常用的字符类，正则表达式中内置了许多渐变写法。例如：对于数字字符类，我们可以使用<em>[0-9]</em>之外，还可以使用*</p>
<p>重要具体的渐变写法有如下：</p>
<ul>
<li>所有的数字，至少相当于<em>[0-9]</em>。在支持Unicode的情况下，，例如波斯数字۱۲۳۴۵۶۷۸۹。</li>
<li>：所有的字符，至少相当于<em>[A-Za-z0-9</em>]*。在支持Unicode的情况下，，例如汉字。</li>
<li>：代表空白字符，它包含了<em>[
</em>（注意）。在支持Unicode的情况下，还包含Unicode中“<a
href="https://www.fileformat.info/info/unicode/category/Zs/list.htm">sparator</a>”目录下的字符。</li>
<li>：和<em>[^</em>一样。</li>
<li>：和<em>[^]</em>一样。</li>
<li>：和<em>[^]</em>一样。</li>
</ul>
<p>另外在perl中，还引入了<em></em><em>配水平的空白符，这包括了tab和Unicode中“<a
href="https://www.compart.com/en/unicode/category/Zs">space
separator</a>”目录下的字符。</em>是匹配垂直空白符，这包括了所有的Unicode中的换行符，它相当于<em>[]</em>。目前PHP、Java8都支持。另外在Ruby1.9之后，<em>示的是十六进制数，也就是相当于</em>[0-9a-fA-f]*。</p>
<h2 id="正则表达式引擎的特征">正则表达式引擎的特征</h2>
<p>大多数的正则表达式引擎是“正则表达式指导”的，也有一部分是“文本指导的”。</p>
<p>对于正则表达式指导的引擎，<strong>正则表达式引擎始终会返回最左边的一个匹配。</strong>它将要匹配的字符串从左往右依次和正则表达式的从左往右依次比较，直到完全匹配才停止。一匹配完就停止，这个特征在垂直线部分尤其重要。</p>
<h2 id="点.特殊字符">点（.）特殊字符</h2>
<p><strong>点匹配除了换行符以外<em>任一</em>字符。</strong>不匹配换行符的原因是一个历史原因，因为世界上第一款正则匹配工具是基于行为单位的，它是一行行读入字符串文件的。</p>
<h3 id="单行模式和多行模式">单行模式和多行模式</h3>
<p>在单行模式中，我们可以使用点匹配换行符。而在多行模式中，如果检索的字符串包含多行，那么^和$除了匹配整个字符串的开始和结尾之外，还能匹配每行的开始和结尾。</p>
<p>也就是说单行模式只影响点.，而多行模式影响^和<span
class="math inline">\(。两种模式的对象是不一样的。我是这么理解的，正则表达式每次只处理一行，因此单行模式就将字符串看成一行，因此中间的换行符也认为是一个普通字符，可以用点匹配；而多行模式就是讲一串字符传看成多行，因此每次换行符的出现都看成新的一行，因此点不应该匹配换行符，而^和\)</span>可以匹配任一行的开头的换行（结尾）。</p>
<h3 id="星号是贪婪的"><strong>星号是贪婪的</strong></h3>
<p>有如下例子：有正则表达式".*"，如果用来匹配Put a "string" between
double quotes，那么结果将是"string"；但如果匹配Houston, we have a
problem with "string one" and "string two". Please
respond.那么结果将会是"string one" and "string
two"。这个原因就是星号是贪婪的。</p>
<h2
id="脱字符和美元符号特殊字符">脱字符（^）和美元符号（$）特殊字符</h2>
<p>对于这两者，前者表示匹配一行的开头，后者表示匹配一行的结束。通常脱字符是在行首或者换行符的右侧，而美元符号是在行位或者换行符的左侧。</p>
<p>另外对于<em>和</em>，<em>仅匹配行首，而</em>仅匹配行尾。它们不会匹配换行。</p>
<h2 id="字符边界">字符边界</h2>
<p>元字符*一个可以用作匹配一个被称为“字符边界”的位置。字符边界，是指以下三种情况：</p>
<ul>
<li>在字符串的第一个字符是文字字符，那么第一个字符之前。</li>
<li>如果字符串的最后一个字符是文字字符，那么最后一个字符之后。</li>
<li>如果一个字符串的相邻两个字符中，一个是文字字符，另一个不是文字字符，那么两个字符之间。</li>
</ul>
<p>文字字符就是指可以展示文字的字符，也就是。</p>
<p>我们使用<em>个例子：正则</em>匹配字符串44 sheets of
a4。匹配结果将会没有，因为无法找到两个字符边界满足匹配条件。</p>
<p><strong>另外还有。。</strong></p>
<h2 id="垂直线特殊符号">垂直线（|）特殊符号</h2>
<p>垂直线被用作进行候选匹配。用法是word1|word2。</p>
<p><strong>垂直线的优先级是最低的</strong>，因此在使用的时候要格外注意其优先级，并要结合括号使用。例如：正则表达式<em>cat|dog)匹配结果是dog或者cat，并且前后有字符边界。但如果没有使用括号，那么将会匹配</em>或者*dog两个表达式。</p>
<p>另外要注意的是，因为“正则表达式指导”的正则引擎始终是匹配最先出现的（在“正则表达式引擎的特征”一部分已经说过）。因此在使用垂直线时，要明确正则引擎会匹配正则式中最早出现的那个。例如：正则表达式<em>GetValue|Get|Set|SetValue</em>，若字符串为SetValue，则匹配结果就是Set，因为Set最先满足条件（正则中的候选项SetValue还没有被尝试匹配）。<strong>因此要注意，垂直线的匹配是按照正则中各项的顺序进行的，匹配最先满足条件的一项。</strong></p>
<p>而对于“文本指导”的正则引擎，则匹配最长的一项。例如：正则<em>GetValue|Get|Set|SetValue</em>匹配字符串SetValue的结果就是SetValue。</p>
<h2 id="问号特殊符号">问号（?）特殊符号</h2>
<p>问号是用于表示可选项的，例如：正则表达式<em>colou?r</em>匹配color和colour。它相当于{0,1}，也就是<strong>表示某一项出现0次或1次</strong>。</p>
<p><strong>问号的匹配是贪婪的，也就是说匹配的结果如果可以出现，并且也是最左，那么就匹配这个。</strong>例如：正则表达式<em>Feb
23(rd)?</em>，对于字符串Today is Feb 23rd, 2003，它的结果就是Feb
23rd，因为Feb 23和Feb
23rd都是最左匹配结果，但是问号贪婪，匹配最长的结果。</p>
<h2 id="花括号特殊符号">花括号（{}）特殊符号</h2>
<p>虽然我们有星号、加号以及问号用来表示重复，但是有时我们需要制定重复的次数，这时就可以使用花括号。它的写法是这样的：<em>{min,max}</em>，min指重复最少次数，max指重复最大次数。<strong>如果不需要指定最大时可以使用<em>{min,}</em>，这表示重复次数大于等于min。</strong>如果重复指定次数，那么就<em>{time}</em>。</p>
<p>这里还要强调一下花括号是贪婪的，它和加号问号星号是一样的。例如：正则表达式<em>ABC{0,3}</em>，字符串为ABCCC，那么匹配结果就是ABCCC。</p>
<p>如果你想避免使用贪婪，也就是变得懒惰，那么你可以在循环符号后面加一个问号。例如：正则表达式<em>ABC{0,3}?</em>，字符串ABCCC，匹配结果就是AB。在+后面添加也可以。</p>
<h2 id="括号特殊符号">括号（()）特殊符号</h2>
<p>括号一般用于存放部分正则表达式，这是它的一个用处。</p>
<p><strong>括号还有一个用处就是存储部分匹配的字符串，被存储的字符串就是正则表达式中放在括号中的部分。它们依次分别存放在一个叫做“捕获组”的地方。</strong></p>
<p>例如：正则表达式Set(Value)?，字符串Set和SetValue，对于前者存储的是空，而对于后者存储的是Value。</p>
<p><strong>如果你不想使用这个捕获组，你可以在开括号后面加上?:。</strong>例如：<em>color=(?:red|green|blue)</em>。</p>
<p>对于前面的捕获组，我们如何使用？答案就是<strong>使用反斜杠加捕获组编号的方法。</strong></p>
<p>例如：对于正则表达式<em>Set(Va)?(lue)?\1</em>，字符串SetValueVa，是可以完全匹配的。<em>\1</em>存储的是Va的值，因为<em>(Va)?</em>匹配成功，因此\1存储的是Va，因此这个正则表达式相当于<em>Set(Va)?(lue)?Va</em>。</p>
<p><strong>这里组的编号是固定的，如果某个组没有捕获到，那么它会在相应位置写上空，而不会把自己的位置延续给下一个。</strong></p>
<p>例如：正则表达式<em>Set(Value)?(Key)?</em>，对于字符串SetKey来说，<em>\1</em>捕获组存储的是空，而不是Key，Key始终存在<em>\2</em>。</p>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
  </entry>
  <entry>
    <title>母函数</title>
    <url>/2018/06/04/%E6%AF%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在数学中，某个序列的母函数(Generating
function，又称生成函数)是一种形式幂级数，其每一项的系数可以提供关于这个序列的信息。
使用母函数解决问题的方法称为母函数方法。母函数可分为很多种，包括普通母函数、指数母函数、L级数、贝尔级数和狄利克雷级数。对每个序列都可以写出以上每个类型的一个母函数。构造母函数的目的一般是为了解决某个特定的问题，因此选用何种母函数要看序列本身的特性和问题的类型。
<span id="more"></span>
在算法比赛中母函数通常解决类似如下的问题：给5张1元，4张2元，3张5元，要得到15元，有多少种组合？某些时候会规定至少使用3张1元、1张2元、0张5元。某些时候会规定有无数张1元、2元、5元。</p>
<p>首先构造如下的多项式乘积： <span class="math display">\[
\begin{align}
&amp;(x^{value[0] * min[0]} + x^{value[0] * (min[0] + 1)} + ... +
x^{value[0] * max[0]}) \nonumber \\
*&amp;(x^{value[1] * min[1]} + x^{value[1] * (min[1] + 1)} + ... +
x^{value[1] * max[1]})\nonumber \\
&amp;...\nonumber \\
*&amp;(x^{value[N] * min[N]} + x^{value[N] * (min[N] + 1)} + ... +
x^{value[N] * max[N]}) \nonumber
\end{align}
\]</span>
其中value[i]表示该乘积表达式第i个因子的权重，对应于具体问题的每个物品的价值或者权重。min[i]表示该乘积表达式第i个因子的起始系数，对应于具体问题中的每个物品的最少个数，即最少要取多少个。max[i]表示该乘积表达式第i个因子的终止系数，对应于具体问题中的每个物品的最多个数，即最多要取多少个。x没有实际意义，可以理解为为了凑成母函数需要的幂级数而添加的。这样的多项式乘积求出来的式子中，均为<span
class="math inline">\(a*x^{k}\)</span>的形式，其中x还是无意义；a代表了能得到k权重的方法有a个。</p>
<p>举个例子：给1张1元，1张2元，3张5元，要得到18元，有多少种组合？</p>
<p>我们先构造多项式乘积： <span class="math display">\[
\begin{aligned}
&amp;(x^{1*0}+x^{1*1})*(x^{2*0}+x^{2*1})*(x^{5*0}+x^{5*1}+x^{5*2}+x^{5*3})
\nonumber \\
=&amp;(1+x)*(1+x^{2})*(1+x^{5}+x^{10}+x^{15})\nonumber \\
=&amp;1+x+x^{2}+x^{2}+x^{5}+x^{6}+x^{7}+x^{8}+x^{10}+x^{11}+x^{12}+x^{13}+x^{15}+x^{16}+x^{17}+x^{18}
\nonumber
\end{aligned}
\]</span> 因为<span
class="math inline">\(x^{18}\)</span>的系数为1，所以有一种组合。</p>
<p>具体到程序，我在网上找到了下面的模板：首先因为比较难直接文字说明，我就先说一下以下代码注释中数学术语的约定（毕竟不是数学专业，而且我语文也很差）。<span
class="math inline">\((1+x^{2})*(1+x^{6}+x^{12})*(x^{6}+x^{12})\)</span><span
class="math inline">\(为例\)</span><span
class="math inline">\((1+x^{2})\)</span>为一个项，<span
class="math inline">\((1+x^{6}+x^{12})\)</span>又为另一个项。以此类推<span
class="math inline">\((1+x^{6}+x^{12})\)</span>中，<span
class="math inline">\(x^{6}\)</span>为该项中的一个数，1为另一个数，以此类推。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a为索引为指数的项的系数，b为中间结果。</span></span><br><span class="line"><span class="type">int</span> a[MAX],b[MAX];</span><br><span class="line"><span class="comment">//初始化a</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>; <span class="comment">//表示有几种因子，也就是说有几种物品</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> P = <span class="number">15</span>; <span class="comment">//P是可能的最大指数</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//循环每个因子，就是现在是第几项与之前的结果相乘</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=min[i];j&lt;=max[i]&amp;&amp;j*value[i]&lt;=P;j++)<span class="comment">//在这个项里面的选了几个几次幂,换到题目里就是选了i种物品j个。所以实际增加的权重是value[i] * j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k+j*value[i]&lt;=P;k++)<span class="comment">//上层循环选的j*value[i]次幂要和前几项的乘积的每个数都乘，k是之前结果中选择的指数</span></span><br><span class="line">            b[k+j*value[i]]+=a[k];<span class="comment">//k + j * value[i]是j*value[i]次幂和k次幂相乘后的指数，这个指数的系数是在前几项的乘积的相同指数的数的系数上加上a[k],因为还没有乘到的项中的数的系数都为1，所以只要加a[k](即使要加也是a[k]*1)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(a,b,<span class="built_in">sizeof</span>(b));<span class="comment">//b赋值给a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数论</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
  </entry>
  <entry>
    <title>理解C++11中特别成员函数的生成</title>
    <url>/2018/10/03/%E7%90%86%E8%A7%A3C++11%E4%B8%AD%E7%89%B9%E5%88%AB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<p>特别成员函数指的是类中可能会默认生成的函数。在C++98中，它们分别是默认构造函数、默认析构函数、复制操作。C++11添加了重要新特性--移动，所以在C++11中还新添加了移动操作。这几个特别成员函数中，复制操作和移动操作又分成复制构造函数(constructor)、复制等号操作符(assignmeng
operator)和移动构造函数、移动等号操作符。 <span id="more"></span>
以默认移动构造函数和默认移动等号操作符来举例，两种方法的形式如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Widget</span>(Widget&amp;&amp; rhs); <span class="comment">// move constructor</span></span><br><span class="line">	Widget&amp; <span class="keyword">operator</span> = (Widget&amp;&amp; rhs); <span class="comment">// move assignment operator</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<strong>通常我们认为默认复制构造函数和默认复制等号操作符的两种方法是互相独立的。</strong>也就是说，即使手动定义了构造函数，如果还需要使用复制等号操作符的方式，这时候编译器会自动生成复制等号操作符的方式。这个是C++98中的定义，在C++11中同样延续了这种做法。
但是<strong>在移动构造函数和移动等号操作符上，两种方式是不互相独立的。</strong>也就是说，如果你定义了其中一个，但是要用到另外一个时，编译器是不会自动生成另外一个的默认函数。这种做法可以这样理解：因为自定义了其中的一个方式，意味着默认的移动可能会导致问题，所以另一个移动的方式就不能使用默认的。
另外，<strong>移动构造函数和移动等号操作符在自定义了复制构造函数或复制等号操作符的类中是不会自动生成的。</strong>这也是可以理解的：因为默认的复制是有问题的，所以有理由判断默认的移动也是有问题的，所以要求自定义移动的函数。同样的，<strong>如果自定义了移动构造函数或移动等号操作符，那么这个类中也不会自动生成复制构造函数或复制等号操作符。</strong>理解方式和上面类似。
在理论上还有一个“三条定理”(Rule of
Three)。这个三条定理说明了<strong>复制构造函数、复制等号操作符以及析构函数应该一起定义。</strong>因为无论你定义了任何一个复制操作就意味着你可能对另一个复制操作也需要自定义，因为复制操作不是默认的。而且此时析构函数也应该根据他们自定义的复制操作进行自定义的析构操作。
但是这个定理虽然正确，却因为出现的比C++98晚，所以C++98没有采用。而C++11也没有采用这个定理，是因为这样可能会导致老标准的代码升级C++11语法会导致很多问题，为了保证兼容性，也没有采用这套标准。所以我们的代码中应该对C++标准加强，遵守这一定理。</p>
<p>C++11中特别成员函数的生成规则总结起来如下: *
默认构造函数：和C++98标准中一样，只有用户没有定义构造函数时(包括复制构造函数和移动构造函数)会自动生成。
*
析构函数：和C++98标准一样，但有一点：生成的析构函数是默认noexcept的。另外强调，C++98中基类的析构函数如果是virtual的，那么继承类的自动生成的函数也是virtual的。
*
复制构造函数：和C++98标准一样。在用户没有自定义复制构造函数的时候会进行默认生成，当类中定义了移动的相关操作（对移动等号操作符和移动构造函数中的一个进行自定义），那么就不会自动生成。如果类中存在自定义析构函数或者复制等号操作符时，即使可以自动生成复制构造函数，但也请不要这样使用，这是因为“三条定理”的缘故。
*
复制等号操作符：和C++98标准一样。在用户没有自定义复制等号操作符的时候会进行默认生成，当类中定义了移动的相关操作（对移动等号操作符和移动构造函数中的一个进行自定义），那么就不会自动生成。如果类中存在自定义析构函数或者复制构造函数时，即使可以自动生成复制等号操作符，但也请不要这样使用，请遵守“三条定理”。
*
移动构造函数和移动等号操作符：只有当类中没有用户定义的复制的操作、移动的操作或者析构函数时会自动生成。</p>
<p>还有一种特殊的情况: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="title">Widget</span><span class="params">(<span class="type">const</span> T&amp; rhs)</span></span>;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; Widget&amp; <span class="keyword">operator</span>= (<span class="type">const</span> T&amp;rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
当T为Widget类型时，上面的两个函数看上去就是复制操作了，但是这种情况编译器还是会生成默认的复制构造函数和默认的复制等号操作符。这个以后会讨论。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式的模式</title>
    <url>/2019/02/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式的模式的格式是(?mode)expr，或者是(?mode:expr)。例如：正则表达式(?i)R，对于字符串rR的匹配结果就是r。因为(?i)开启了大小写不敏感模式。这个表达式还可以写成(?i:R)。</p>
<p>之前我介绍过正则表达式的基本语法（<a
href="/2019/02/18/正则表达式基础/">正则表达式基础</a>），讲到一个单行多行模式，这就是正则表达式的模式。今天我们就来简单介绍一下正则表达式的模式。</p>
<p>正则表达式的模式有大概如下几种：</p>
<ul>
<li>(?i)：大小写不敏感模式。</li>
<li>(?-i)：大小写敏感模式。</li>
<li>(?s)：单行模式。</li>
<li>(?m)：多行模式。</li>
</ul>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
  </entry>
  <entry>
    <title>理解std::move和std::forward</title>
    <url>/2018/10/18/%E7%90%86%E8%A7%A3std_move%E5%92%8Cstd_forward/</url>
    <content><![CDATA[<p>std::move不会移动任何东西，std::forward也不会转发任何东西。这两个函数在运行时，甚至不会做任何事。它们没有生成任何可执行的代码，它们的作用会在编译时得到发挥：std::move要做的就是把任意的参数转换成右值。而std::forward在特定的情况下会把参数转换成右值，这种特殊情况其实就是参数也是一个右值。
<span id="more"></span> # std::move</p>
<p>我们先来看一个std::move在C++11中的大致过程:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">typename</span> remove_reference::type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference::type&amp;&amp;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它引用了一个对象，然后返回了这个对象，上面的remove_reference是模板元编程的一个转换类，它可以把参数的引用符去除。</p>
<p>形参中的&amp;&amp;代表了这是一种全体引用，它不是单纯的右值引用。如果不清楚全体引用，就记住如果T是一个左值引用，那么T&amp;&amp;就是一个左值引用，想进一步了解全体引用，可以参看:<a
href="/2018/10/20/区别全体引用和右值引用/">区别全体引用和右值引用</a>。为了防止T&amp;&amp;是一个左值，我们使用了模板元编程的remove_reference来保证返回的是一个右值。</p>
<p>另外，根据我们之前介绍的，上面的代码在C++14中可以这么写:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">typename</span> <span class="type">remove_reference_t</span>&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span><span class="comment">// 使用C++14标准的remove_reference_t move(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> <span class="type">remove_reference_t</span>&amp;&amp;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出move函数没有做任何移动的操作，只是做一个转换操作。</p>
<p>事实上，右值只是通常会去被移动，假设有如下的代码: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Annotation</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="type">const</span> std::string text)</span> : value(std::move(text)) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上面的代码如果使用一个std::string类型构造一个Annotation类，会造成value是拷贝构造的。虽然std::move(text)是一个右值，但是由于text是一个const类型，进行了std::move操作之后，变成了右值的const
std::string类型。而std::string的构造函数如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">string</span>(<span class="type">const</span> string&amp; rhs); <span class="comment">// 复制构造函数</span></span><br><span class="line">		<span class="built_in">string</span>(string&amp;&amp; rhs); <span class="comment">// 移动构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>value如果选择移动构造函数，被移动的是一个右值的const
std::string，因此不可以作为移动构造的参数，所以不可以移动构造。为了维持const的正确性，只能选择复制构造函数进行构造。</p>
<p>因此我们可以得出两个结论：</p>
<ul>
<li>如果你想对象是可以被别的对象移动构造的，请不要使用const。</li>
<li>std::move不只是做移动操作，它还有可能会导致复制操作。</li>
</ul>
<h1 id="stdforward">std::forward</h1>
<p><strong>std::forward可以根据全体引用绑定的是左值还是右值，对转发的内容保持左值或右值的属性。</strong>这也是std::move与std::forward的最大区别之处。std::forward的使用原理这里不介绍，如果有兴趣可以参看:理解引用折叠。下面对其使用举一个例子：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">const</span> Widget&amp; lvalArg)</span></span>; <span class="comment">// 参数为左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rvalArg)</span></span>; <span class="comment">// 参数为右值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>(); <span class="comment">// 获取当前时间</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">makeLogEntry</span>(<span class="string">&quot;Calling \&#x27;process\&#x27;&quot;</span>, now); <span class="comment">// 记录日志</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndProcess</span>(w);</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndProcess</span>(std::<span class="built_in">move</span>(w));</span><br></pre></td></tr></table></figure>
在logAndProcess中，如果logAndProcess的参数为w，那么就会调用参数是左值的process函数；如果logAndProcess的参数为右值，那么就会调用参数是右值的process函数。因为param始终是一个左值，如果直接调用process(param)都会执行参数为左值的重载函数。为了避免这种情况，我们使用std::forward对param进行转换，如果param为右值引用，就会传给process一个右值；如果param为左值引用，那么就不处理，直接将左值传给process。</p>
<p>std::move的转换是无条件的，std::forward的转换是有条件的。这时候可能你会有一个疑问，我们是否可以使用std::forward完全替换std::move？答案是可以的，但是我们没有必要要这样做。因为这两者有它们各自的使用场景。</p>
<p>我们对比std::forward和std::move的使用后发现，对于std::forward你还需要指定类型，这会导致代码变得繁冗并且容易导致错误。例如:std::forward&lt;T&amp;&gt;和std::forward<T>就是不一样的。</p>
<p>关于std::move和std::forward的使用条件，可以参看:<a
href="/2018/10/21/对于左值引用使用std_move，对于全体引用使用std_forward">对于左值引用使用std::move，对于全体引用使用std::forward</a>。</p>
<h2 id="总结">总结</h2>
<ul>
<li>std::move功能是无条件的转换到右值。不过它实际上不移动任何东西。</li>
<li>std::forward只当模板类型参数被绑定为一个右值时才将参数转化到一个右值。</li>
<li>std::move和std::forward在运行时不进行任何操作，它们要做的都是在编译时完成的。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>理解引用折叠</title>
    <url>/2018/10/28/%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0/</url>
    <content><![CDATA[<p>之前我们讲过，模板函数的参数如果为全体引用，那么实参的引用类型取决于实参是左值还是右值。例如下面的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
模板参数类型T被编码为什么类型取决于实参是左值还是右值。当左值作为实参，那么T将会被推断为左值引用；当右值作为实参，那么T将会被推断为非引用。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">widgetFactory</span><span class="params">()</span></span>; <span class="comment">// 函数返回了一个右值</span></span><br><span class="line"></span><br><span class="line">Widget w; <span class="comment">// 一个左值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(w); <span class="comment">// 使用了左值作为实参，T被推断为Widget&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">widgetFactory</span>()); <span class="comment">// 使用右值作为了实参，T被推断为Widget</span></span><br></pre></td></tr></table></figure>
对于func的两个调用，都是传递了Widget，但是因为其中一个Widget是左值，另一个是右值，T被推断为了不同的类型了。这个也决定了全体引用被推断为左值引用还是右值引用，而且这也是std::forward的依赖机制。
<span id="more"></span>
在我们更进一步了解std::forward之前，我们必须先知道一个准则，那就是在C++中，我们不可以使用引用引用一个引用。也就是用代码来说，下面的代码是非法的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; &amp;rx = x; <span class="comment">// 非法代码！不能使用引用引用一个引用。</span></span><br></pre></td></tr></table></figure></p>
<p>但是我们考虑这样的代码，看看这个模板的全体引用参数被传递了一个左值时会发生什么:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(w); <span class="comment">// 传递给func一个左值，T被推断为Widget&amp;</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们使用类型推断推导T，并且实例一个模板函数，我们得到下面的代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Widget&amp; &amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里居然使用了一个引用了引用的引用！但是编译器却不提示任何错误。编译器是怎么从上面那段看似有错误的代码推导T呢？答案是引用折叠。是的，你不可以定义一个引用引用一个引用，但是编译器可以这样做。当编译器生成了这样的引用，引用折叠就会发生。</p>
<p>C++中有两种引用，一种是左值引用，另一种是右值引用。所以一共有四种可能的引用了引用的引用。如果一个引用了引用的引用出现在了可以出现的地方，那么引用折叠就遵循下面的原则:
<strong>如果被引用的引用或者引用其它引用的引用中，有一个是左值引用，那么这个引用就被推导成左值引用，否则（两者都是右值引用），就推导成一个右值引用。</strong></p>
<p>在我们上面的例子中，因为是一个右值引用引用了一个左值引用，因此被推导成了Widget&amp;。这就是按照引用折叠的规则来的。</p>
<p>引用折叠也是std::forward的一个重要部分。std::forward将右值引用转换为右值。展示一个简单使用的例子:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; fParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">someFunc</span>(std::forward&lt;T&gt;(fParam));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更多std::forward的使用，可以参看:<a
href="/2018/10/18/理解std_move和std_forward/">理解std::move和std::forward</a>
因为fParam是一个全体引用，类型参数T将可以表示传给f的参数是左值还是右值。std::forward的作用就是转换fParam（一个左值）到一个右值。</p>
<p>下面是std::forward的实现代码，虽然不是标准库中的代码，但是可以用来std::forward的行为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设传给f是一个左值Widget，T将会被推断称Widget&amp;，并且对std::forward的调用将会变为对实例化的std::forward&lt;Widget&amp;&gt;的调用。带入Widget&amp;，std::forward的调用将会变成:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp; &amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 再根据引用折叠变成: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&gt;(param)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因此，左值参数传入了std::forward就会返回一个左值引用。因为传入了一个Widget&amp;，而std::forward返回了Widget&amp;，左值引用也是左值，因此std::forward没有做什么事情。</p>
<p>现在假设给f函数传递一个Widget的右值，在这种情况下T将会被推断为Widget。所以会变为对实例化后的std::forward的调用，用Widget替换T之后，得到如下的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">forward</span><span class="params">(Widget&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里没有引用折叠的发生，因此这也是对std::forward调用的最终生成版本。
右值引用作为参数，返回的是右值，所以std::forward将会返回一个右值。在对f函数的调用中，就这样将fParam转化成了右值，然后传递给了someFunc。</p>
<p>在C++14中，我们可以将std::forward的示例代码改写成如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>引用折叠在四种情况下可能发生，</p>
<ol type="1">
<li><p>也是最有可能出现的情况是模板实例化时，也就是上面的举例中可能会发生。</p></li>
<li><p>auto类型生成时，这种情况也很有可能发生的。我们考虑如下代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">widgetFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(w);</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">widgetFactory</span>());</span><br></pre></td></tr></table></figure> 这个可以用auto做如下的模仿改写。有定义: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; w1 = w;</span><br></pre></td></tr></table></figure>
w1初始化为一个左值，因此推断auto为Widget&amp;.然后将Widget&amp;带入定义的auto中，因此w1成为了引用引用的引用:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; &amp;&amp; w1 = w;</span><br></pre></td></tr></table></figure> 在经过引用折叠之后，就变成了: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; w1 = w;</span><br></pre></td></tr></table></figure>
因此w1是一个左值引用。 同理，若有如下定义: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = <span class="built_in">widgetFactory</span>();</span><br></pre></td></tr></table></figure>
w2初始化为一个右值，因此auto为无引用的左值Widget。替换auto之后，就变成:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp;&amp; w2 = <span class="built_in">widgetFactory</span>();</span><br></pre></td></tr></table></figure> w2是一个右值引用。
所以我们现在有了新的理解，全体引用不是一个特殊的引用，而是的确是一个右值引用，并且其上下文满足两种条件:</p>
<ul>
<li>类型推测区分左值和右值。T类型左值被推断为T&amp;类型，T类型右值被推断为还是T类型。</li>
<li>有引用折叠发生。
全体引用的概念仍然是十分有用的，因为它可以让你不用知晓上下文即可推断左值或者右值的类型，然后在上下文中替换推断类型之后运用引用折叠来明确发生了什么。</li>
</ul></li>
<li><p>使用typedef和别名声明时。如果使用了typedef和别名声明时，在typedef的创建和赋值就会出现引用引用的引用，假设我们有一个Widget类的模板，并且这个模板中，有右值引用在typedef中:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T&amp;&amp; RvalueRefTot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 如果我们使用一个左值引用类型实例化一个Widget:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&lt;<span class="type">int</span>&amp;&gt; w;</span><br></pre></td></tr></table></figure>
使用int&amp;替换Widget类中的T，Widget中的typedef就会变成这样:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp; &amp;&amp; RvalueRefToT;</span><br></pre></td></tr></table></figure> 经过引用折叠之后就会变成: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp; RvalueRefToT;</span><br></pre></td></tr></table></figure>
这样我们也会发现这个RvalueRefToT和我们的命名想表达的不一样--它是一个左值引用，而不是右值引用。</p></li>
<li><p>typedecl中。如果我们只用了decltype，一个引用了引用的引用就可能会出现，然后就会发生引用折叠。</p></li>
</ol>
<p><strong>总结</strong></p>
<p>引用折叠发生在四种情况下：模板的实例化中、auto类型生成时、typedef和别名声明的创建和使用时以及decltype中
当编译器生成一个引用引用的引用是，就会发生引用折叠。结果是一个单一的引用。如果引用和被引用的引用有一个是左值引用，那么结果就是一个左值引用，否则就是右值引用。
全体引用是一个右值引用，它会根据模板类型是左值或右值有不同结果，并且会发生引用折叠。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>确保跳出作用域时std::thread是不可连接的（unjoinable）</title>
    <url>/2018/11/22/%E7%A1%AE%E4%BF%9D%E8%B7%B3%E5%87%BA%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%97%B6std_thread%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%88unjoinable%EF%BC%89/</url>
    <content><![CDATA[<p>每个std::thread对象都有两种状态，可连接(joinable)和不可连接(unjoinable)。<strong>可连接的std::thread对象与可以被执行或正在执行的底层异步线程相通信。当一个std::thread对象对应的底层线程被阻塞或者正在等待被调度时也是可连接的。例如：正在等待底层线程执行完毕的std::thread也被看做是可连接的。</strong></p>
<p>不可连接的std::thread的情况包括以下几种： *
默认构造的std::thread。这个不难理解，因为这时候std::thread中没有可执行的函数，因此也没有底层运行线程。
*
已经被移走的std::thread。移动一个std::thread对象到另一个std::thread对象就意味着底层执行线程现在与另一个std::thread通信。
*
std::thread已经被连接过（执行过join函数）了。在执行过join函数之后，std::thread在底层线程执行完毕后，不再对应某个底层执行线程了。
*
std::thread已经被分开（执行过detach）了。detach会切断std::thread和底层执行线程的连接。</p>
<p>为什么我们要知道一个std::thread是否可连接呢？原因就是当一个可连接的线程被销毁，这个程序也将终止。<span id="more"></span>例如，我们有一个函数doWork。假设我们要对过滤函数filter设置优先级，这也就是要使用native_handle，它只有在std::thread的API中才有，基于任务的API中（例如：future）是没有这个的。代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> tenMillion = <span class="number">10&#x27;000&#x27;000</span>; <span class="comment">// C++14的写法，可以对大数用单引号进行分割</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doWork</span><span class="params">(std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; filter,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> maxVal = tenMillion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; goodVals;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		[&amp;filter, maxVal, &amp;goodVals]</span></span></span><br><span class="line"><span class="params"><span class="function">		&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">			&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">if</span>(filter(i)) goodVals.push_back(i);</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用native_handle设置优先级，设置部分代码暂时先忽略</span></span><br><span class="line">	<span class="keyword">auto</span> nh = t.<span class="built_in">native_handle</span>();</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">conditionsAreSatisfied</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		t.<span class="built_in">join</span>();</span><br><span class="line">		<span class="built_in">performComputation</span>(goodVals);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
更好的实现是使用暂停状态，这可以在做计算之前调整优先级，这将会在后面讲解<a
href="/2018/12/07/考虑使用void类型的future的一次性的事件通信/">考虑使用void类型的future的一次性的事件通信</a>。
回到doWork，如果conditionAreSatisfied()返回了true，代码运行起来没什么问题。但是如果返回了false或者抛出了异常，std::thread的对象t将会是可连接的，然后它的析构函数就会在doWork退出之前被调用，这也就会导致程序的终结退出。那么为什么是终结退出而不是隐含使用join或者detach呢？答案当然是这会使情况更加糟糕。</p>
<ol type="1">
<li>如果使用了join，std::destructor将会等待底层的异步执行线程运行结束。这听上去很合理，但是这会导致程序有不合理的举动，并且很难调试出。例如：doWork将会在conditionsAreSatisfied()返回false时仍然执行完了filter过滤函数。</li>
<li>如果使用detach。切断std::thread的连接似乎比使用join合理，但是这么做还是可能导致严重问题。例如：goodVals是一个本地变量，并且被按址捕获了，如果在lambda中修改（通过push_back）了它，然后这个lambda就被异步执行，这时conditionsAreSatisfied()返回false，doWork就要返回，doWork的本地变量（包括goodVals）要被销毁。然后lambda如果在本地变量销毁之后还试图访问原来本地变量的地址，就会导致非法的访问。如果lambda试图修改原来地址上的数据，那么还有可能导致修改了其它变量的数据。</li>
</ol>
<p><strong>C++标准委员会就规定，如果销毁了可连接的线程，后果就是程序终止运行。</strong></p>
<p>因此你就有职责确保你定义的std::thread对象在退出某个作用域时是不可连接的。但是这是很难确保的，例如：return、goto、break、continue以及异常等都会导致跳出作用域，跳出作用域的方法太多了。</p>
<p>如果你想在对象每次退出它自己的作用域的时候执行一些动作的话，你可以在析构函数中添加这些动作。这个对象被称作为RAII（Resource
Acquisition Is
Initialization，尽管这项技术的关键不在初始化上，而在销毁）对象，并且类被称作RAII类。RAII类在标准库中非常常见，例如在STL容器中（每个容器的析构函数都会销毁容器中元素的内存数据）、智能指针、std::fstream对象（析构函数中关闭了相应的文件）等等，但是标准库中std::thread仍然没有标准的RAII类。
不过我们可以自行编写RAII类，这也不复杂。例如，下面的类允许调用者指定在销毁ThreadRAII对象时使用join还是detach:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadRAII</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="keyword">enum class</span> <span class="title class_">DtorAction</span> &#123; join, detach &#125;;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ThreadRAII</span>(std::thread&amp;&amp; t, DtorAction a)</span><br><span class="line">			:<span class="built_in">action</span>(a), <span class="built_in">t</span>(std::<span class="built_in">move</span>(t)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		~<span class="built_in">ThreadRAII</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(t.<span class="built_in">joinable</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(action == DtorAction::join)</span><br><span class="line">				&#123;</span><br><span class="line">					t.<span class="built_in">join</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					t.<span class="built_in">detach</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">std::thread&amp; <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		DtorAction action;</span><br><span class="line">		std::thread t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 关于这段代码简单提示几点：</p>
<ul>
<li>构造函数只接受std::thread的右值，因为我们要移动std::thread到ThreadRAII对象中。std::thread对象不可复制。</li>
<li>在构造函数初始化的时候，先初始化了action，然后再初始化了t。这是因为当t被初始化之后线程就会开始运行了，如果先初始化t的话就会导致有一段时间没有决定销毁方法，线程已经在运行了，因为为了安全起见，使用了std::thread。</li>
<li>ThreadRAII提供了get函数用来访问std::thread对象。提供这样的get函数避免了复制整个std::thread，并且也可以在需要的时候使用std::thread。</li>
<li>在ThreadRAII析构函数应用到一个函数之前，它会检查t是否是可连接的。这一步是有必要的，因为在不可连接的线程上使用使用join或者detach是未定义行为。在外界构造的std::thread中，使用get访问t、对t调用了join或者detach，亦或使用了移动都会使t变得不可连接。
那么你可能会想如果在执行完t.joinable()之后，其它线程将t变成了不可连接的，这里就会产生一个竞争的问题。想法很好，但是是不可能的。在ThreadRAII对象执行析构函数时，其它线程不应该调用这个对象的成员函数。如果有同步的调用，当然会有竞争，但是这个竞争不会发生在析构函数中，而是会发生在外部试图同时执行两个成员函数（析构函数和其它什么函数）的地方。因此，成员函数的同步调用只会在成员函数都是const类型时安全。（原因参看：<a
href="/2018/10/02/确保const成员函数线程安全/">确保const成员函数线程安全</a>）
使用了ThreadRAII的doWork将会是这样的: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">doWork</span><span class="params">(std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; filter,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> maxVal = tenMillion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; goodVals;</span><br><span class="line"></span><br><span class="line">	<span class="function">ThreadRAII <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		std::thread(</span></span></span><br><span class="line"><span class="params"><span class="function">			[&amp;filter, maxVal, &amp;goodVals]</span></span></span><br><span class="line"><span class="params"><span class="function">			&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">if</span>(filter(i))</span></span></span><br><span class="line"><span class="params"><span class="function">						goodVals.push_back(i);</span></span></span><br><span class="line"><span class="params"><span class="function">			&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		),</span></span></span><br><span class="line"><span class="params"><span class="function">		ThreadRAII::DtorAction::join</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> nh = t.<span class="built_in">get</span>().<span class="built_in">native_handle</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">conditionsAreSatisfied</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		t.<span class="built_in">get</span>().<span class="built_in">join</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们在上面的代码中使用了join，因为detach会导致调试时异常困难。但是join会导致程序行为异常（执行完线程t的任务再退出），但相比较于未定义行为已经好很多了。
不过在之后我们还会发现，在ThreadRAII中使用join不光会导致程序行为异常，还会导致程序挂起。合理的解决方法是与异步运行的lambda通信，并告知它不在需要它工作了，请尽早返回，这项技术被称为可中断线程（interruptible
thread）但我们在C++11中无法实现这项技术，只有自己创建代码，具体可以参见Anthony
Williams的《C++ Concurrency in Action》的9.2章节。</li>
</ul>
<p>在<a
href="/2018/10/03/理解C++11中特别成员函数的生成">理解C++11中特别成员函数的生成</a>中说到，如果定义了析构函数，那么就不会有默认的移动构造函数，对象因此也就不可移动了。因此如果你要让RAII类可移动，请手动添加移动函数。</p>
<p><strong>总结</strong></p>
<ul>
<li>确保std::thread在跳出作用域时不可连接（unjoinable）。</li>
<li>在析构函数中使用join会导致难以调试出的程序行为异常（通常是线程不立即结束，而是会运行完）。</li>
<li>在析构函数中使用detach会导致难以调试的未定义行为（访问已经被销毁的内存空间）。</li>
<li>在数据成员中，最后一个定义std::thread对象。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>确保const成员函数线程安全</title>
    <url>/2018/10/02/%E7%A1%AE%E4%BF%9Dconst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>在编程中，我们通常会使用这样一种函数：它可以计算某个数值，但是它不修改任何数据，我们很自然的把这种函数定义成const。但是有时候这种函数会进行很复杂的计算，而且因为它可能进行复杂计算，我们通常也都不希望多次运行它，就会使用缓存技术。因为缓存技术的引入，在多线程环境下，就要考虑线程安全问题。
C++11中引入了两种用于保证线程安全的类，一个叫做lock_guard，另一个叫做atomic。前者是类似于操作系统中的信号量的PV操作，后者是类似于只能独占访问的变量，使用原子操作进行读写。下面介绍两者。
<span id="more"></span></p>
<h1 id="lock_guard的使用">lock_guard的使用</h1>
<p>有如下的数据类型，它可能存在于缓存中，当不在缓存中时就需要用户即使获取，为了保证其线程安全，我们使用了如下的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Polynomial</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		<span class="keyword">using</span> RootsType = std::vector&lt;<span class="type">double</span>&gt;; </span><br><span class="line">		<span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">		</span>&#123; </span><br><span class="line">			<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>; </span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(!rootsAreValid)</span><br><span class="line">			&#123; </span><br><span class="line">				<span class="comment">// get roots</span></span><br><span class="line">			&#125; </span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> rootVals; </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>: </span><br><span class="line">		<span class="keyword">mutable</span> std::mutex m; </span><br><span class="line">		<span class="keyword">mutable</span> <span class="type">bool</span> rootsAreValid&#123; <span class="literal">false</span> &#125;; </span><br><span class="line">		<span class="keyword">mutable</span> RootsType rootVals&#123;&#125;; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
在这种情况下我们可以保证其实线程安全。但是这个类中使用了不可移动的类mutex，所以这个类变得不可复制或移动。</p>
<h1 id="atomic的使用">atomic的使用</h1>
<p>有时使用lock_guard保证线程安全会显得大材小用。例如当你想统计对某个数据的访问计数，就可以使用atomic完成，因为其花费的代价可能会比mutex小很多（这个花费要取决于你的标准库是怎么定义mutex）。例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			++callCount;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> std::<span class="built_in">hypot</span>(x, y);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">mutable</span> std::atomic&lt;<span class="type">unsigned</span>&gt; callCount&#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 使用如上代码就可以线程安全地统计函数的调用计数了。</p>
<h1 id="选择决策">选择决策</h1>
<p>刚刚介绍了两个类的使用，下面来介绍什么时候用lock_guard，什么时候用atomic。其实也就是一句话:
<strong>单变量的独占访问用atomic，过程或者说是多变量的独占访问使用lock_guard。</strong>
例如，某个函数会执行一次很复杂的计算，但是这个计算无论何时调用都是一样的结果，也就是说这个函数的返回值是可以进行缓存的。如果这个函数可能会被多线程调用，这个函数该怎么设计？
根据上面的决策思路，我们会使用lock_guard。因为这里面牵涉到了一系列过程的线程安全。如果我们没有按照上面的决策，我们使用了atomic。那么代码可能是这样的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(cacheValid)</span><br><span class="line">				<span class="keyword">return</span> cachedValue;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> val1 = <span class="built_in">expensiveComputation1</span>();</span><br><span class="line">				<span class="keyword">auto</span> val2 = <span class="built_in">expensiveComputation2</span>();</span><br><span class="line"></span><br><span class="line">				cachedValue = val1 + val2;</span><br><span class="line">				cacheValid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> cachedValue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">mutable</span> std::atomic&lt;<span class="type">bool</span>&gt; cacheValid&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">		<span class="keyword">mutable</span> std::atomic&lt;<span class="type">int</span>&gt; cachedValue;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
这段代码使用了atomic，那么它是线程安全的么？如果线程1在计算val1时，线程2进来了，发现数据没有缓存，那么计算val1...如果没有线程执行到cacheValid
=
true这一句，所有线程执行函数都会执行一遍val1和val2的计算。这样还是造成了很大的资源浪费。需要改进。但如果我把代码的cacheValid置true前移，放在计算val1的前面，那么就不会出现已进入函数，后面线程重复计算的情况，但这时又带来新的问题，就是线程1的数据还没算出来，cacheValid已经标记有缓存，这样接下来的线程不会多计算val1和val2，但是从缓存取出来的数据是有问题的。因此我们就会想到，需要独占的不是说某一个变量，而是几个变量、一个过程。所以我们就要使用lock_guard。代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(cacheValid)</span><br><span class="line">				<span class="keyword">return</span> cachedValue;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> val1 = <span class="built_in">expensiveComputation1</span>();</span><br><span class="line">				<span class="keyword">auto</span> val2 = <span class="built_in">expensiveComputation2</span>();</span><br><span class="line"></span><br><span class="line">				cachedValue = val1 + val2;</span><br><span class="line">				cacheValid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> cachedValue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">		<span class="keyword">mutable</span> <span class="type">int</span> cachedValue;</span><br><span class="line">		<span class="keyword">mutable</span> <span class="type">bool</span> cacheValid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 使用这一段代码完美解决了我们的需要。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>素数表的最优实现</title>
    <url>/2018/06/01/%E7%B4%A0%E6%95%B0%E8%A1%A8%E7%9A%84%E6%9C%80%E4%BC%98%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>对于素数表的构建，基本思路是：除了1以外的正整数的倍数都不是素数。反之同理，素数不可能是某两个非1整数的积。
所以有以下代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) p[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i * <span class="number">2</span>; j &lt;= n; j += i)</span><br><span class="line">		p[j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后进行优化: 1.i的枚举至多只需要到sqrt(n) + 1即可 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(n) + <span class="number">1</span>; ++i)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i * <span class="number">2</span>; j &lt;= n; j += i)</span><br><span class="line">		p[j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>2.如果某个数不是素数，那么它的倍数可以用它的素因数表示，所以非素数可以排除
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(n) + <span class="number">1</span>; ++i)</span><br><span class="line">	<span class="keyword">if</span>(p[i]) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i * <span class="number">2</span>; j &lt;= n; j += i) </span><br><span class="line">			p[j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>3.j不必从i*2开始筛，在i=2时筛过;也不必在i*3时开始..;不必从i*(i-1)时开始；而是应该从i*i开始
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(n) + <span class="number">1</span>; ++i)</span><br><span class="line">	<span class="keyword">if</span>(p[i]) </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i * i; j &lt;= n; j += i) </span><br><span class="line">			p[j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>经过三轮优化得到的代码是最优的素数表实现代码。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>类型别名定义</title>
    <url>/2018/09/25/%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>在C++98中，我们使用typedef来定义一个类型的别名。但是C++11大量的类型推测类型使得typedef不能满足新特性的需求。所以在C++11中使用了using新特性来定义类型的别名。
<span id="more"></span> 使用C++11新的using特性定义类型别名，则只要使用如下的代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; </span><br><span class="line">MyAllocList&lt;Widget&gt; lw; </span><br></pre></td></tr></table></figure></p>
<p>而在C++98中我们这样定义别名: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAllocList</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAllocList&lt;Widget&gt;::type lw; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以在C++98中使用模板的typedef定义的类型别名，都会有::这样的小尾巴，如果使用C++98的定义方式是没有办法避免的。如果使用C++11的标准就可以避免这个小尾巴。
<strong>在C++98中，模板函数、模板类使用嵌套类或者类中定义typedef的别名时，要使用typename关键字来告诉编译器这是一个“内嵌依赖类型名”，也就是说这个类型是在类内部定义的</strong>:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAllocList</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>接触过模板元编程的都知道可以使用模板对数据类型进行操作，这是定义在type_traits头文件中的一系列模板完成的，例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type <span class="comment">// C++11: const T -&gt; T </span></span><br></pre></td></tr></table></figure>
但这种::后缀还是不是很方便，所以在C++14中引入了_t后缀用于去除::后缀。例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="type">remove_const_t</span>&lt;T&gt; <span class="comment">// C++14: const T -&gt; T </span></span><br></pre></td></tr></table></figure></p>
<p>如果你使用的代码是C++98风格的代码，如果想转换成C++14的风格，你只要做类似于下面的事:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">using</span> <span class="type">remove_const_t</span> = <span class="keyword">typename</span> remove_const&lt;T&gt;::type; </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>考虑使用void类型的future的一次性的事件通信</title>
    <url>/2018/12/07/%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8void%E7%B1%BB%E5%9E%8B%E7%9A%84future%E7%9A%84%E4%B8%80%E6%AC%A1%E6%80%A7%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>有时候我们会出现一个线程等待另一个线程完成的情况。例如要等待某个线程完成对数据结构的初始化、等待计算阶段的完成亦或是等待传感器获取到数据。通常我们为了实现线程间互相通信时，会使用条件变量（condition
variable，condvar）。有如下定义：检测条件的任务被称为<strong>检测任务（detecting
task）</strong>；对条件作出反应的任务被称为<strong>反应任务（reacting
task）</strong>。<br />
它们的运行策略也很简单：反应任务等待条件变量满足，检测任务在事件发生时通知条件变量。下面介绍C++中几个实现进程同步的方式。
<span id="more"></span> # 基于条件变量（condvar）的方式</p>
<p>如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">std::mutex m;</span><br></pre></td></tr></table></figure>
<p>检测任务的代码很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">... <span class="comment">// 检测事件</span></span><br><span class="line"></span><br><span class="line">cv.<span class="built_in">notify_one</span>(); <span class="comment">// 告知反应任务有事件发生 </span></span><br></pre></td></tr></table></figure>
<p>如果有若干的反应任务要被通知，那么应该使用notify_all，但是这个无伤大雅，这里假设只有一个反应任务。</p>
<p>而反应任务的代码比较复杂了，因为在调用wait等待条件变量时，必要通过std::unique_lock对象进行互斥（在等待一个条件变量之前通常要进行互斥，这是线程库中通用的做法。通过std::unique_lock对象互斥也是C++11API的组成）。下面是理论上反应任务的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// 互斥锁定</span></span><br><span class="line"></span><br><span class="line">cv.<span class="built_in">wait</span>(lk); <span class="comment">// 等待通知。但这样的写法是有问题的</span></span><br></pre></td></tr></table></figure>
<p>这段代码有代码异味（code
smell）：即使代码是正常工作的，但是某些方面有一些不正常。这个异味是来自对mutex的使用上。mutex被用在控制访问分享的数据上，但是检测任务和反应任务都有可能不需要mutex。例如，检测任务可能负责初始化一个全局的数据结构，然后转向反应任务使用这个数据结构。如果检测任务在这个全局的数据结构初始化之后再也不访问这个数据结构，并且如果反应任务在检测任务告知自身已经准备好之前不会访问这个全局数据结构，那么这两个线程就会自觉隔离开自己，而不需要使用mutex。条件变量的方法是用在一个线程与另一个线程之后运行时使用的。<br />
这里有另外两个问题你需要注意：</p>
<ul>
<li><strong>如果检测任务在反应任务执行wait之前通知条件变量，那么反应任务将会被挂起。</strong>为了条件变量能唤醒一个任务，那么另一个任务必须已经在等待条件变量。如果检测任务碰巧在反应任务执行wait之前进行通知，那么反应任务将会错过这个通知，并且有可能永远等待下去。</li>
<li><strong>由于虚假唤醒（spurious
wakeup）带来的wait发生问题。</strong>在许多语言的线程API中都可能出现虚假唤醒的问题，也就是条件变量会在没有被通知的情况下被唤醒。恰当的代码都是通过等待的确认条件真实发生之后再发生唤醒。C++确认条件变量很简单，可以使用lambda（或者其它函数对象）传递给wait以测试被等待的条件。wait代码如下：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv.<span class="built_in">wait</span>(lk, []&#123; 返回是否事件发生; &#125;); </span><br></pre></td></tr></table></figure>
使用这个功能的前提是能判断正在等待的条件是否为真。但是在我们之前的例子中，都是判断一个事件是否发生，反应线程可能没有办法知道是否事件已经发生。这也就是为什么要wait一个条件变量的原因。</li>
</ul>
<h1 id="基于flag的方式">基于flag的方式</h1>
<p>这个例子使用了基于flag的方式： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 检测到事件发生</span></span><br><span class="line"></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">// 告知反应任务</span></span><br></pre></td></tr></table></figure>
反应线程简单的<strong>轮询（poll）</strong>这个flag，当这个flag赋完值，反应任务就知道等待的事件已经发生了：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!flag);</span><br></pre></td></tr></table></figure>
这个方法能避免所有基于条件变量设计带来的缺陷。这里没有必要使用mutex，而且如果检测任务在反应任务轮询之前就设置flag为true也没有问题，并且也不会发生虚假唤醒的问题。但是还是有问题，就是反应任务检测条件变量的代价比较高。上面的代码是使用的while，需要占用硬件资源，并且线程是一直在运行的。而使用wait则是硬件级的阻塞，不会占用系统资源，线程也被挂起。</p>
<h1 id="基于条件变量和基于flag的结合">基于条件变量和基于flag的结合</h1>
<p>上面两种方法都或多或少有一些问题，我们通常可以使用条件变量和基于flag结合的设计。flag被用于判断事件是否发生，但是对于flag的访问则是需要用mutex进行同步，因为mutex防止同时访问flag，对于flag只需要使用简单的bool就可以，不需要使用std::atomic，这在<a
href="/2018/12/07/对并行使用stdatomic，对特殊内存使用volatile/">对并行使用stdatomic，对特殊内存使用volatile</a>中有具体的证明。之后检测任务将会看上去这样：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测任务</span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">flag</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 检测事件的发生</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">g</span><span class="params">(m)</span></span>; <span class="comment">// 防止flag被同时访问</span></span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知反应任务</span></span><br></pre></td></tr></table></figure></p>
<p>反应任务的代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反应任务</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">	cv.<span class="built_in">wait</span>(lk, []&#123; <span class="keyword">return</span> flag; &#125;); <span class="comment">// 如果flag为真，则对mutex上锁，并且解除阻塞，否则就不锁定mutex并且阻塞线程。 </span></span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 对检测到的事件的反应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法避免了我们之前提到的使用while时会占用系统资源的问题。无论反应任务是否在检测任务通知之前wait，它都可以正常工作，并且无论是否发生了虚假唤醒都可以，而且还不需要轮询。但是这里还有一个问题，检测任务和反应任务是通过一个非常稀奇古怪的方式通信。条件变量通知反应任务，其等待的事件可能已经发生，反应任务必须检查这个等待的事件是否已经发生。设置flag就是为了告诉反应任务事件真的已经发生了，但是检测任务还要通过通知条件变量让反应任务醒来并且检查flag。这个方法似乎不是非常干净。</p>
<h1 id="基于future的方式">基于future的方式</h1>
<p>其中一个解决方法就是通过在反应任务的future使用wait以避免使用条件变量、mutex以及flag。这个方法可能听上去比较特别，因为在<a
href="/2018/12/02/请注意不同的线程处理方式的析构函数行为/">请注意不同的线程处理方式的析构函数行为</a>中我们说到future是调用者与被调用通信信道的接收终端，但是这里没有调用者和被调用者这样一层关系。不过在这一篇文章中还说到，通信信道发送终端是std::promise。我们可以利用这样的通信信道，在检测任务和反应任务之间进行通信。</p>
<p>具体的设计非常简单。检测任务有一个std::promise对象（也就是通信信道的写终端），反应任务有一个对应的future。当检测任务检测到寻找的事件发生之后，它将设置std::promise（例如写入通信信道中）。与此同时，反应任务在future上wait，这个wait阻塞了反应任务，直到std::promise被设置。</p>
<p>std::promise和future（包括std::future、std::shared_future等在内）都需要指定一个类型参数，这个类型参数指定了通信信道中传递的数据的类型。但是在上面的例子中，很显然没有数据被传递；反应任务则设置future。我们要解决的是std::promise和future模板的类型参数，这个类型参数可以代表没有数据通过通信信道传输，这个类型就是void。因此检测任务将会使用std::promise，反应任务就会使用std::future或者std::shared_future。当检测任务检测的事件发生，它将会设置std::promise，反应任务则会等待future。尽管反应任务不会从检测任务收到任何数据，但是通信信道还是会让反应任务在检测任务“写”了void类型数据时知道，方法就是通过调用std::promise中的set_value方法。<br />
所以给出代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br></pre></td></tr></table></figure></p>
<p>检测任务的代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">... <span class="comment">// 检测事件</span></span><br><span class="line"></span><br><span class="line">p.<span class="built_in">set_value</span>(); <span class="comment">// 通知反应任务</span></span><br></pre></td></tr></table></figure></p>
<p>反应任务的代码如下： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...<span class="comment">// 准备反应</span></span><br><span class="line"></span><br><span class="line">p.<span class="built_in">get_future</span>().<span class="built_in">wait</span>(); <span class="comment">// 等待p对应的future</span></span><br></pre></td></tr></table></figure>
和使用flag的方法一样，这里没有使用mutex；无论检测任务是否在反应任务wait之前设置std::promise，都会正常工作；并且对虚假唤醒有免疫。和基于条件变量的方法一样，反应任务在wait之后是真实地被阻塞，从而在等待时不消耗系统资源。</p>
<p>然而这种方法也不是非常完美地。当然，基于future的方式解决了其它方式的问题，但是它还有一些问题。例如，<a
href="/2018/12/02/请注意不同的线程处理方式的析构函数行为/">请注意不同的线程处理方式的析构函数行为</a>说到std::promise和future中间还有一个分享状态，并且分享状态通常是动态分配空间，因此你需要假设使用基于future的方式的设计要在分配和销毁的操作上有所消耗。</p>
<p>更重要的是，std::promise可能只能被设置一次。std::promise和future之间的通信信道是一个一次性的机制：不能被多次使用。这是一个和基于条件变量和基于flag的方式不同之处，这两者都可以被多次使用。（条件变量可以一直通知下去，而flag可以清除了再设置）。</p>
<p>这个一次性的限制可能没有你想象的那么制约你。假设你想要创建一个处于挂起状态的系统线程，也就是说你想要避免与线程创建相关的所有开销，以至于当你在线程上执行某些东西时，普通线程创建延迟可以避免。或者你可能想创建一个挂起状态的线程以至于你可以在让它运行之前进行配置。这样的配置可能包括设置它的优先级或者核心密切度。C++的并发API没有办法做到这些，但是std::thread对象提供了native_handle成员函数，这个函数的结果可以让你访问系统依赖的的线程API（通常是POSIX或者Windows线程）。底层API通常可以实现配置线程的特点，例如优先级和依赖度。</p>
<p>假设你希望挂起一个线程只一次（创建之后，运行线程上函数之前），使用void的future是一个合理的选择。下面是大概的代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">react</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		p.get_future().wait();</span></span></span><br><span class="line"><span class="params"><span class="function">		react();</span></span></span><br><span class="line"><span class="params"><span class="function">	&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 运行到这里时，t是挂起状态的</span></span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">set_value</span>();</span><br><span class="line"></span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为保证t在跳出detect函数作用域时是不可连接是非常重要的，上面代码如果在“...”处发生异常就会导致跳出作用域时不是可连接的，所以要使用RAII类（具体讲解参见：<a
href="/2018/11/22/确保跳出作用域时std::thread是不可连接的（unjoinable）/">确保跳出作用域时std::thread是不可连接的（unjoinable）</a>）。代码大致如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ThreadRAII <span class="title">tr</span><span class="params">( <span class="comment">// 使用了RAII对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">		std::thread([]&#123; p.get_future().wait();</span></span></span><br><span class="line"><span class="params"><span class="function">			react(); </span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;),</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">		ThreadRAII::DtorAction::join</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// tr中的线程在这里是挂起状态的</span></span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">set_value</span>(); <span class="comment">// 将tr中的线程开始运行 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码还是有一些要注意的地方。在“...”的地方，如果发生了异常，set_value将会永远不调用。这也就是说，lambda中的wait将会永远不返回。也就是说，运行lambda的线程永远不会结束，而RAII对象tr配置的join决定了tr在销毁时会执行join。换句话说，如果一个异常被忽略，函数将会挂起，因为tr的析构永远不会结束。</p>
<p>当然有很多种方法可以解决这个问题，这里请读者自行思考。根据《Effective
Modern C++》作者提示，可以访问<a
href="http://scottmeyers.blogspot.com/2013/12/threadraii-thread-suspension-trouble.html">作者博客问题页</a>进行考虑。这里将展示如何使用非RAII的代码挂起然后唤醒一个反应任务。关键是在反应任务中使用std::shared_future替换std::future：std::future的share成员函数将分享状态的拥有权给由share成员函数创建的std::shared_future。唯一的细微之处是每个反应线程需要各自拥有引用了分享状态的std::shared_future。所以lambda要按值捕获由share取得的std::shared_future：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> sf = p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::thread&gt; vt; <span class="comment">// 反应线程的容器</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vt.<span class="built_in">emplace_back</span>([sf]&#123; <span class="comment">// 按值捕获，捕获std::shared_future</span></span><br><span class="line">			sf.<span class="built_in">wait</span>();</span><br><span class="line">			<span class="built_in">react</span>();</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">set_value</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : vt)</span><br><span class="line">	&#123;</span><br><span class="line">		t.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>总结</strong></p>
<ul>
<li>在简单的事件通信中，基于条件变量（condvar-based）的设计需要一个多余的mutex在检测任务和反应任务的进度关系上做限制，并且需要反应任务确认事件真实发生（防止虚假唤醒）。</li>
<li>使用基于flag的设计可以避免上述基于条件变量的设计拥有的问题，但是要基于轮询，而不是使用阻塞。</li>
<li>条件变量和flag可以一起被使用，但是这样的通信机制有一些生硬（反应任务需要检查自己是否等待的事件发生）。</li>
<li>使用std::promise以及future的通信机制解决了上述问题。但是如果使用std::future时通信时，因为分享状态在堆上的原因，这种通信是一次性的。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>考虑使用进驻（emplacement）代替插入（insertion）</title>
    <url>/2018/12/14/%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%A9%BB%EF%BC%88emplacement%EF%BC%89%E4%BB%A3%E6%9B%BF%E6%8F%92%E5%85%A5%EF%BC%88insertion%EF%BC%89/</url>
    <content><![CDATA[<p>如果你有一个容器中存放了例如std::string这样的对象，使用插入来添加一个新的元素似乎是非常合理的（例如使用insert，push_front，push_back等等），你传递过去的参数也是std::string，和要保存在容器中的是同一种类型，但是上面的想法不是始终正确的。
<span id="more"></span> # emplace通常效率更高</p>
<p>考虑这一段代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;</span><br><span class="line"></span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyzzy&quot;</span>);</span><br></pre></td></tr></table></figure>
在这里，容器中存放了std::string，但是这里真实想要通过push_back存储的是字面类型的字符串，也就是说你传递过去的参数不是真实的std::string类型。std::vector的push_back是对左值和右值重载的：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">		<span class="type">void</span> <span class="built_in">push_back</span>(<span class="type">const</span> T&amp; x);</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>;</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 在调用vs.push_back("xyzzy");中编译器看到实参的类型（const
char[6]）和push_back使用的参数类型（std::string的引用）不匹配，因此就通过从字面的字符串生成临时的std::string解决这种不匹配，然后把这个临时的对象传递给push_back。换句话说，和下面代码类似：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="string">&quot;xyzzy&quot;</span>));</span><br></pre></td></tr></table></figure> 代码编译之后是可以运行的，但是可以进一步优化性能。</p>
<p>为了在容器中创建一个新的std::string元素，每次插入新元素都调用了std::string的构造函数，但是上面的代码却不只一次调用了构造函数，而是调用了两次。并且也因此调用了一次析构函数。下面是如上调用push_back之后程序发生的事情：</p>
<ol type="1">
<li>有一个临时的std::string对象从字面的字符串“xyzzy”被创建。这个对象没有名字，我们暂且称呼它为temp。构造temp是第一步，因为这是一个临时对象，temp因此是一个右值。</li>
<li>temp被传递给push_back的右值重载函数，在那里temp被绑定给了右值引用参数x。然后在std::vector的内存中x再次被构造，这个构造的才是真正在std::vector中创建新的对象，这次构造是使用的移动构造函数，因为x是一个右值。</li>
<li>在push_back返回之后，temp被销毁，因此调用了std::string的析构函数。</li>
</ol>
<p>如果有方法可以直接跳到步骤2那么就可以提高程序的效率，因为避免了多余的一次构造temp以及销毁temp。</p>
<p>因为你是一名C++程序员，对于C++来说效率是它最吸引人的特点，如果你不追求效率，那么你为什么不使用Python呢？所以我们需要让程序效率最大化，而这里的方法是使用emplace_back函数替代push_back。</p>
<p>emplace_back实现了我们所希望的：无论什么实参传递给std::vector用以构造std::string，始终不会出现临时的对象：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);</span><br></pre></td></tr></table></figure>
emplace_back使用了完美转发，所以只要你不突破完美转发的限制（具体可以参看：<a
href="/2018/11/06/几个完美转发失败的条件/">几个完美转发失败的条件</a>），你就可以传递类型的参数以及各种组合。例如，如果你想要在vs中通过std::string的构造函数创建一个由单字母和重复次数构成的std::string，代码可能就是这样的：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&quot;x&quot;</span>);</span><br></pre></td></tr></table></figure>
所有的标准容器中，只要支持push_back的都支持emplace_back。类似地，每一个支持push_front的标准容器都支持emplace_front；每一个支持insert的标准容器（但是std::forward_list和std::array例外，std::forward是关联容器）都支持emplace。关联容器（associative
container）提供emplace_hint用来实现“线索”迭代器的insert操作，并且std::forward_list有emplace_after用来与insert_after对应。</p>
<p>因为类型构造所需的参数都由emplace函数传递过去了，因此进驻可以用在需要没有临时对象产生的插入，并且插入和进驻最后的结果是一样的。例如：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">queenOfDisco</span><span class="params">(<span class="string">&quot;Donna Summer&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure> 下面两个调用都是有效的： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vs.<span class="built_in">push_back</span>(queenOfDisco);</span><br><span class="line"></span><br><span class="line">vs.<span class="built_in">emplace_back</span>(queenOfDisco);</span><br></pre></td></tr></table></figure>
入驻函数可以因此做插入函数能做的任何事情。入驻函数有时会比插入函数效率更高，但是理论上绝对不会效率更低。但即使如此为什么不是一直使用入驻函数呢？</p>
<h1 id="emplace效率更低的情况">emplace效率更低的情况</h1>
<p>当然，理论是理论，和实践还是有不一样的。在当前标准库的实现中，有几种情况会导致效率比插入函数低。这样的情况比较难以找出特征，因为这要依赖于实参类型、使用的容器、容器的入驻函数和插入函数的使用位置、存放类型构造函数的容器安全，并且对于容器，容器是否可以存放相同的数据（例如：std::set，std::map，std::unordered_set，set::unordered_map）、值是否已经在容器中也是有影响的。通常，性能调整的建议是：对于入驻和插入进行基准测试。</p>
<p>当然这种方法不是很令人满意，因此你将要学习一种启发式的方法帮助你判断入驻函数和插入函数哪种更适合。在下面的条件中，如果都满足，入驻将极大可能地有优异的性能：</p>
<ul>
<li><strong>值将通过构造的方式添加到容器中，而不是赋值的方式</strong>：在最开篇的例子（添加值为“xyzzy”的std::string到std::vector
vs中）当中展示了将值添加到vs的结尾的方法，这个结尾没有对象存在。新的值因此只能通过构造的方法添加进std::vector。如果我们改变例子，新的std::string将会存放到一个已经有对象存在的空间当中，那么事情将会不一样了：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;string&gt; vs;</span><br><span class="line">...</span><br><span class="line">vs.<span class="built_in">emplace</span>(vs.<span class="built_in">begin</span>(), <span class="string">&quot;xyzzy&quot;</span>); <span class="comment">// 在vs的开头处添加“xyzzy”</span></span><br><span class="line">```    </span><br><span class="line">在这段代码中，对于已经被std::string占领的内存vs\[<span class="number">0</span>\]不是通过构造的方式添加进去，而是通过移动赋值的方式放到内存中。但是移动赋值需要有一个移动源，也就是说要有临时的对象被创建以作为移动源。之前之所以说进驻比插入的好就是因为能省去这个临时对象，但是这里无法省去，所以在这时使用入驻就没有好处了。  </span><br><span class="line">对于是否添加一个值到容器是由构造和复制来完成通常都是由实施者来决定，但是启发式方法再一次可以提供帮助。  </span><br><span class="line">基于节点的容器一直都是用构造函数添加新的值，并且大多数标准容器都是基于节点的。只有std::vector、std::deque、std::string不是（虽然std::array也不是，但是它不支持插入和进驻，所以这里不考虑）。在非节点的容器中，你可以依赖emplace\_back以在添加新值时使用构造以代替赋值。对于std::deque同样可以使用emplace\_front。</span><br><span class="line">*   **实参类型和容器存放的数据类型不一样**：如果T类型的对象要添加到container&lt;T&gt;中，入驻就不太可能会比插入快，因为不需要创建临时变量以满足插入。</span><br><span class="line">*   **容器不会因为数据重复而拒绝插入**：这就意味着如果容器要不然是允许重复数据存在要不然你保证你插入的值都是独一无二的。这条原则是因为，容器为了检查要添加的数据是否是独一无二的，会在进驻函数创建一个节点，这个节点存放了新的值，这样可以将这个节点的值和已经存在的节点比较。如果这个节点的值没有在容器中，那么这个节点将会被链接进容器，否则就会被销毁，这也就意味着会有一次构造和销毁可能会被浪费。</span><br><span class="line"></span><br><span class="line">下面的调用就满足了上面的几个条件，因此它们也比调用push\_back快：</span><br><span class="line">```c++</span><br><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);</span><br><span class="line"></span><br><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure>
当决定是否使用进驻函数，有两点是要记在心中的。第一点就是资源管理。假设有一个容器，存放了std::shared_ptr<Widget>类型的值：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::list&lt;std::shared_ptr&lt;Widget&gt;&gt; ptrs;</span><br></pre></td></tr></table></figure>
然后你想添加一个std::shared_ptr，并且这个智能指针是使用指定的销毁函数。之前说过，请可能地使用std::make_shared来创建std::shared_ptr（具体请参看：<a
href="/2018/10/14/智能指针中make_xxx函数和new的使用/">智能指针中make_xxx函数和new的使用</a>），但是有时你没有办法使用std::make_shared创建指针，其中一种情况就是当你希望指定销毁函数时，那你就必须直接使用new获得传统指针，这个指针被std::shared_ptr管理。</li>
</ul>
<p>如果有如下的销毁函数： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">killWidget</span><span class="params">(Widget* pWidget)</span></span>;</span><br></pre></td></tr></table></figure>
使用插入函数的代码差不多是这样的： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptrs.<span class="built_in">push_back</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget, killWidget));</span><br></pre></td></tr></table></figure> 当然也可以写成这样：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptrs.<span class="built_in">push_back</span>(&#123; <span class="keyword">new</span> Widget, killWidget &#125;);</span><br></pre></td></tr></table></figure>
不管使用哪个，都免不了在调用push_back之前构造一个临时的std::shared_ptr。push_back的参数是一个std::shared_ptr的引用，因此必须要有一个std::shared_ptr对象给参数引用。</p>
<p>如果使用进驻，那么这个std::shared_ptr的临时变量的创建就可以避免。但是在这里这个临时变量有它重要的意义。考虑下面潜在的时间序列：</p>
<ol type="1">
<li>在上面的任意一个调用中，临时的std::shared_ptr<Widget>对象被构造用于存放传统指针，这个传统指针是new
Widget的运行结果。我们称这个对象叫temp。</li>
<li>push_back通过引用控制着temp，再分配节点空间用来存放temp的副本时，抛出了一个“内存耗尽”的异常。</li>
<li>因为异常被抛出，并且冒泡到push_back，temp就会销毁。std::shared_ptr作为对其指向的Widget的唯一引用，它自动释放Widget，因此调用了killWidget。</li>
</ol>
<p>即使异常发生了，也没有任何内存泄露发生：在push_back中通过new
Widget创建的Widget在管理其的std:shared_ptr销毁时被销毁。</p>
<p>但如果我们考虑使用emplace_back时什么会发生： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptrs.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> Widget, killWidget);</span><br></pre></td></tr></table></figure> 1. new
Widget创建的传统指针被完美转发到了开辟新节点的构造函数上了，然后内存耗尽，抛出异常。
2.
随着异常冒泡出emplace_back，传统指针是唯一能访问到堆上的Widgetd方法，而这个传统指针丢失了。这个Widget发生了泄露。</p>
<p>在这个情况下就发生了内存泄露。上面的例子对于std::unique_ptr也是同样成立。从根本上说，资源管理类（如std::shared_ptr以及std::unique_ptr）的有效性取决于资源（例如来自new的传统指针）被立即传递给资源管理对象的构造函数。而std::make_shared和std::make_unique自动完成资源的立即传递也是它们同样重要的原因。</p>
<p>在调用存放资源管理对象的容器（例如std::list&lt;std::shared_ptr<Widget>&gt;）的插入函数中，函数参数通常确保在获取资源（例如使用new）和构造资源管理对象之间没有其它动作。在进驻函数中，完美转发延迟了资源管理对象的创建，直到它们可以在容器的内存中构造再创建，这也为异常导致内存泄露留下了窗口期。所有标准的容器都可能发生这样的问题，当时用这些容器并且存放资源管理对象时，你必须格外注意到底该使用进驻函数还是插入函数。不要为了效率忽略了异常安全。</p>
<p>其实坦白地说，你不应该传递类似于“new
Widget”这样的表达式给emplace_back或者push_back，甚至大多数函数，因为这会导致异常安全问题（具体参看<a
href="/2018/10/14/智能指针中make_xxx函数和new的使用/">智能指针中make_xxx函数和new的使用</a>）。为了避免异常安全问题，我们要将“new
Widget”返回的指针用独立的语句放到资源管理对象中，然后将对象作为右值传递给原来要传递“new
Widget”的函数。代码类似于这样： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, killWidget)</span></span>;</span><br><span class="line"></span><br><span class="line">ptrs.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(spw));</span><br></pre></td></tr></table></figure>
emplace_back版本的代码也类似： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, killWidget)</span></span>;</span><br><span class="line"></span><br><span class="line">ptrs.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(spw));</span><br></pre></td></tr></table></figure>
不管使用哪种方式，都付出了创建和销毁spw的代价。当你添加资源管理对象到容器中时并且确保了没有行为发生在获得资源和将其传给资源管理对象之间，使用进驻函数通常不会比插入函数更有效率。</p>
<p>另外还有一个指的注意的是进驻函数和explicit是有影响的。在C++11支持的正则表达式中，假设我们创建一个正则表达式对象：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::regex&gt; regexes;</span><br></pre></td></tr></table></figure> 如果你不小心写出了这样的代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">regexes.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
你在编写时没有注意到这个错误，你编译了这段代码并且通过编译。接下来你就要花大量的时间寻找bug所在。但是为什么一个nullptr可以放到正则表达式的容器中呢？指针毕竟不是正则表达式。但是如果你尝试写这样的代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std:regex r = <span class="literal">nullptr</span>; <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
编译器将会报错。但是如果你是用push_back代替emplace_back时：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">regexes.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>); <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
这个奇怪的行为的原因是std::regex对象可以由字符串构造，也就是可以如下构造：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">upperCaseWord</span><span class="params">(<span class="string">&quot;[A-Z]+&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
如果通过字符串创建std::regex将会付出很高的代价，所以为了尽量减少无意中发生这些事件的可能，std::regex的参数为const
char
*的构造函数为explicit。这也就是为什么有几种调用会编译出错的原因了，因为它们尝试将一个指针转换成std::regex，并且explicit阻止了这样的转换。</p>
<p>然而在调用emplace_back时，我们没有声称传递std::regex对象，我们传递的是std::regex构造函数的实参。这就不会被认为是隐式地转换要求，也就是类似于下面的代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">r</span><span class="params">(<span class="literal">nullptr</span>)</span></span>; <span class="comment">// 可以通过</span></span><br></pre></td></tr></table></figure>
上面的代码虽然可以编译通过，但是会导致未定义行为。std::regex要求 const
char*是非空的，nullptr会导致运行时程序的崩溃。</p>
<p>抛开emplace_back和push_back不说，我们看看两个非常相似的初始化带来的不同结果：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::regex r1 = <span class="literal">nullptr</span>; <span class="comment">// 编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::regex <span class="title">r2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>; <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure> 在标准的术语中，前者r1使用的是<strong>复制初始化（copy
initialization）</strong>，后者r2使用的是<strong>直接初始化（direct
initialization）</strong>。复制初始化是不可以使用explicit构造函数的，而直接初始化可以。这也就是为什么两者结果不一样的原因了。</p>
<p>而在进驻函数和插入函数中，进驻函数使用的是直接初始化，而插入函数使用的是复制初始化，因此：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">regexes.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>); <span class="comment">// 编译通过</span></span><br><span class="line"></span><br><span class="line">regexes.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>); <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure>
对于explicit构造函数请务必注意，因为你有可能定义了explicit，编译器还将你有问题的代码转化成可编译的类型。</p>
<p><strong>总结</strong></p>
<ul>
<li>在实践中，进驻函数应该在某些时刻比插入函数效率更高，并且进驻至少不会比插入效率低。</li>
<li>在实践中，进驻函数在以下条件同时满足时效率往往会高：1.被添加的值是构造到容器中，而不是赋值过去的。2.传递过去的实参类型和容器容纳的数据类型不同。
3.容器不会拒绝与已有值相同的值的插入。</li>
<li>进驻函数可能在explicit的构造函数下进行类型转换，而插入函数无法做到。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>要假设移动操作是不存在的、高代价的以及没有被使用的</title>
    <url>/2018/10/30/%E8%A6%81%E5%81%87%E8%AE%BE%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E6%98%AF%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E3%80%81%E9%AB%98%E4%BB%A3%E4%BB%B7%E7%9A%84%E4%BB%A5%E5%8F%8A%E6%B2%A1%E6%9C%89%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84/</url>
    <content><![CDATA[<p>移动语义是C++11中的重要功能。移动操作有着和移动指针一样低的代价，对于临时对象的复制操作很高效，以致于临时对象的复制成为了一种优化级别的操作。移动语义不光如此，它还要求编译器在合适情况下自动用移动替换复制。如果你将C++98代码使用C++11编译器编译，你很有可能会发现它运行得更快了。</p>
<p>让我们先从许多不支持移动语义的类型开始。C++11标准库重构了C++98的标准库，为移动操作比复制操作快的类型添加了移动操作，并且为库内的组件补全了需要的操作。如果你没有为使用C++11而修改任何代码，这时使用支持移动操作C++编译器就变得有益了，因为C++11编译器会在缺少移动操作的类里自动生成移动操作，但是编译器只会在没有定义复制操作、移动操作和析构函数的类中这么去做，数据成员或者基类禁用了移动操作的类也将会禁止编译器自动生成移动操作。因此对于那些没有明确支持移动和没有使用编译器自动生成的移动操作的类型，我们不应该相信对其使用C++11编译器会相较C++98有怎么样的提升。
<span id="more"></span></p>
<p>即使是那些明确使用了移动的类型也可能没有和你想象的那样高效。C++11标准库中所有的容器支持移动，但是移动不一定是高效的，那些可以使用高效的移动操作的容器，是冒着容器内元素无法移动的风险进行的。</p>
<p>std::array是C++11中的一个新容器。std::array实际上是C++基本的内建数组的一个STL接口。它和其它的标准容易不一样，其它的容器中的元素是存放在堆上的，它们通过一个指针指向堆上的内存地址对内容进行访问（不过事实上要比这个复杂，为了简化分析，我们不多说）。这个指针的存在使得可以在常量时间内移动这个容器内的内容：复制指向内容的指针，然后将原来容器的指向null。</p>
<p>下面用std::vector与std::array作比较: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Widget&gt; vw1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向vw1中插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将vw1移动到vw2需要常量时间</span></span><br><span class="line"><span class="keyword">auto</span> vw2 = std::<span class="built_in">move</span>(vw1);</span><br></pre></td></tr></table></figure>
而std::array就不一样了，他没有指针，因为其中的数据是直接存储在std::array对象中:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::array&lt;Widget, 100000&gt; aw1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向aw1中插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将aw1移动到aw2需要线性时间</span></span><br><span class="line"><span class="comment">// 需要将aw1中的每个元素移动到aw2</span></span><br><span class="line"><span class="keyword">auto</span> aw2 = std::<span class="built_in">move</span>(aw1);</span><br></pre></td></tr></table></figure>
注意aw1中的元素是移动到aw2中的。假设Widget是一个移动比复制快的类型，那么移动一个存放Widget的std::array比复制要快，所以std::array提供移动操作。因为容器中的每个元素必须被复制或移动，所以std::array的移动和复制操作都是在线性时间复杂度。“移动一个容器和给几个指针赋值一样代价低”的说法是绝对存在问题的。</p>
<p>另外，std::string提供了常量时间的移动和线性时间的复制。这个让你听上去移动好像比复制快很多，但事实却不是这样的。许多字符串满足了短字符优化(small
string
optimization，SSO)。在SSO中，短字符（通常15个字符之内）被存储在std::string的缓存内，而不是存放在新开辟的堆中并用指针指过去。因此移动使用了SSO的短字符所花的时间不比复制其少，SSO没有指针可以移动。
使用SSO是因为在应用中会大量出现短字符，使用内部的缓存存储字符内容减少了动态开辟内存的需要，并且这通常是一个高效的做法。短字符的高效也意味着，短字符移动操作比复制操作慢。</p>
<p>即使对于支持快速移动操作的类型来说，一些看上去会使用移动的可能最后还是使用的复制。在<a
href="/2018/09/30/noexcept关键字的使用/">noexcept关键字的使用</a>中，我们举了std::vector中push_back函数的例子，只有在移动不会出错的情况下，才会选择进行移动操作，否则就做复制操作。这样的一个结果就是，即使一个类型提供了移动操作，并且这个移动操作比复制操作快很多，而且这个移动操作在代码中很合适，但是编译器仍然选择了使用复制操作，因为移动操作没有被声明为noexcept。</p>
<p>还有一个值得一提，那就是对于极少情况下，只有右值才可以被使用移动操作。</p>
<p>因此，C++11中的移动语义在以下情况中对代码优化没有好处： *
没有移动操作：要移动的对象中没有移动操作，所以将会使用复制来替代移动。 *
移动操作效率低：对某个对象的移动效率没有复制来的高，例如SSO。 *
移动操作不可用：对于使用移动操作的上下文中，要求是没有异常的发生。如果某个操作没有声明为noexcept，就不会发生移动操作。
*
源对象是左值：极少情况下只有右值才可以被移动，如果是对左值进行移动操作就不会发生移动操作。
这条建议通常用在写模板时，因为你不知道你正在对什么类型进行编码，你需要保守一些：假设移动操作是不存在的、高代价的以及没有被使用的。在代码经常变动的时候也可以使用这种建议。</p>
<p><strong>总结</strong>
要假设移动操作是不存在的、高代价的以及没有被使用的，当然已知类型或者支持移动语义时可以除外。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>请注意不同的线程处理方式的析构函数行为</title>
    <url>/2018/12/02/%E8%AF%B7%E6%B3%A8%E6%84%8F%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<p>在之前我们说到，一个可连接的（joinable）std::thread有一个对应系统底层的执行线程。一个非延迟任务的future也和底层系统线程有一个相似的关系。因此std::thread对象和future对象都可以被看作是系统线程的两个使用处理方式。</p>
<p>之前我们还说过，std::thread在遇到可连接线程跳出作用域时，采取的策略是程序直接终止运行，而不是隐式执行join或者detach。<strong>而在future中，则是有可能隐式执行join，也有可能隐式执行detach，甚至也有可能什么都不做。反正future是不会导致程序终止。</strong>下面我们就来细讲future的这种策略。
<span id="more"></span>
future会将程序的结果保存在一个叫做std::promise的对象中，也就是说被调用者就是通过std::promise对象与调用者进行通信以传递结果。但是有一个问题，就是被调用者的结果存放在哪才能响应调用者执行get呢？如果这个结果存放在被调用者的std::promise中，那么在被调用完之后std::promise就会随着被调用对象而销毁；这个结果如果存放在调用者的future中，因为std::future会被用于创建一个std::shared_future（被调用者的结果的拥有权从std::future转交给std::shared_future），这会导致原std::future销毁后还会被复制许多次，又因为不是所有结果的类型是可拷贝的，所以这样做也不是很合适。那么哪一个和被调用者相关的future存放结果呢？
所以被调用者执行结果既不是适合存放在被调用者相关的对象中，也不是适合存放在调用者相关的对象中。而是存放在两者之外的一个地方，这个地方被称为<strong>共享状态</strong>（shared
state）。共享状态是一块堆中的对象，它的类型、接口以及实现方式在标准中没有指定，因此标准库编写者可以随心所欲地实现它。</p>
<p>共享状态的存在是非常重要的，因为它直接决定了future的销毁方式。具体的来说：</p>
<ul>
<li>最后一个使用某个非延迟任务的共享状态的future的销毁会通过std::async阻塞到任务完成。在必要时，对这个future的销毁会在异步运行的线程上隐式调用join。</li>
<li>其它的future就简单地直接销毁future对象。在异步运行的线程上，这就像在对应的线程上隐式执行了detach。在延迟执行的对象上，这就相当于不执行这个任务。</li>
</ul>
<p>这些规则听上去很复杂，但是我们可以用一个“普通”规则和一个“特殊”规则来描述：
“普通”规则：只有future的数据成员会被销毁，在销毁时不会执行join、detach甚至是运行任何东西（事实上还是会做一件事的，那就是会递减共享状态的引用计数器，这步操作是由使用了这个共享状态的future和被调用者的std::promise共同完成的，这个引用计数器记录了何时可以销毁共享状态）。</p>
<p>如果一个future满足了下面所有的条件时就会实行“特殊”： *
这个future必须是引用了由std::async创造的共享状态 *
任务的启动策略必须是std::launch::async。不论是系统在运行时选择的还是在std::async中选择的。
*
这个future是最后一个引用某个共享状态的一个。std::future永远都是满足条件的。但是std::shared_future就会对是否是最后一个引用进行判断。</p>
<p>只有当所有的条件都满足了，future的销毁才会使用“特殊”行为。“特殊”行为就是阻塞线程，直到异步运行的任务完成。更具体的说就是，就是类似于在std::async启动策略创建的任务上调用join。</p>
<p>为什么会对非延迟任务、并有std::async启动的分享状态有一条特殊的规则呢？这是因为标准委员会希望避免默认detach带来的问题，但是他们又不希望使用激进的策略作为命令控制编程。所以他们妥协使用隐式的join。这个决定是充满争议的，因此在C+14指定是也存在强烈的呼声禁用这个特殊的行为，不过最终还是没有做出任何改变。</p>
<p>在future提供的API中，没有一个是可以确定future是否引用了由std::async创建的分享状态，所以给你一个future对象，你是无法确定系统是否会在销毁异步运行的任务时使用阻塞。</p>
<p>这种行为不确定就会带来问题，下面讲如何避免这种不确定。
有如下的补全代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::future&lt;<span class="type">void</span>&gt;&gt; futs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::shared_future&lt;<span class="type">double</span>&gt; fut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
当然如果你有方法知道future不会满足上面的三个条件以在销毁时执行特殊行为（例如通过程序逻辑），你确实可以保证future不会再销毁时阻塞。不过这里可以使用一种方法，上面讲到，必须是引用std::async创建的共享状态的future会发生阻塞，而能创建共享状态的方式不只有std::async，还有例如std::packaged_task。std::packaged_task对象会通过包装要异步执行的函数，然后使得它的结果会被放到共享状态中。之后可以通过std::packaged_task的get_future函数获取引用了分享状态的future：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calcValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">pt</span><span class="params">(calcValue)</span></span>; <span class="comment">// 包装calcValue，使得它可以异步执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut = pt.<span class="built_in">get_future</span>(); <span class="comment">// 获取pt的future</span></span><br></pre></td></tr></table></figure>
<strong>这里的fut的共享状态不是有std::async创建的，因此它的销毁也会遵循“常规”行为。</strong></p>
<p>只要创建了，std::packaged_task
pt就可以在线程上运行了。（它可以通过std::async运行，但是如果你希望通过std::async运行某个任务，就没有必要使用std::packaged_task。因为std::async做了std::packaged_task做的任何事情。）</p>
<p>std::packaged_task是不可拷贝的，因此当pt传递给std::thread的构造函数时，它必须要转换成右值：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::move(pt))</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在知道std::packaged_task特性之后，我们就可以使用其来保证future的销毁时遵循普通行为了。在下面的代码中我们要做一个有趣的分析，我们把代码放在一个作用域中：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">pt</span><span class="params">(calcValue)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> fut = pt.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(std::move(pt))</span></span>;</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 作用域的结尾。在下面会讨论这里的三种情况。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码中的“...”部分是在std::thread的创建之后、作用域结束之前，我们要进行讨论。t这里可能会有三种情况：
* t没有发生什么。在这里t将会变得是可以join的，这就会导致程序终止。 *
t执行了join。那么就没有必要在fut的析构函数中进行阻塞，因为调用者已经执行join。
*
t执行了detach。那么就没有必要在fut的析构函数中执行detach。因为调用者已经执行detach。</p>
<p>换句话说，<strong>如果future的共享状态是由std::packaged_task生成的，通常是没有必要考虑销毁策略。因为究竟是终止程序、join还是detach的选择将会在std::thread对象创建后进行指定，与std::packaged_task无关。</strong></p>
<p><strong>总结</strong></p>
<ul>
<li>future的销毁通常只是销毁数据成员。</li>
<li>最后一次使用某个引用了分享状态的future，并且这个分享状态是非延迟任务的、通过std::async启动的future将会阻塞到任务完成后再销毁自己。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>跳跃表数据结构分析</title>
    <url>/2018/04/14/%E8%B7%B3%E8%B7%83%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Redis中的跳跃表数据结构是通过两个结构体实现的： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> &#123;</span><br><span class="line">	sds ele; <span class="comment">/* 节点存放的数据 */</span></span><br><span class="line">	<span class="type">double</span> score; <span class="comment">/* 节点排序依据 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *backward;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">zskiplistLevel</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *forward;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">	&#125; level[]; <span class="comment">/* 节点的层数 */</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplist</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">zskiplistNode</span> *header, *tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">	<span class="type">int</span> level; <span class="comment">/* 表最大层数 */</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
zskiplist结构体是跳跃表整体的数据结构，它里面存储了跳跃表的头和尾，以及跳跃表的最大长度（节点个数）和节点的最大层数。
<span id="more"></span></p>
<p>zskiplistNode结构体则是跳跃表节点结构体。ele存储数据；score存储节点排序依据；backward则是存放了上一个节点（不一定是前驱，只是score小于并最接近当前节点，或者是score等于当前节点而ele小于并最接近当前节点的ele）；后驱结构体level，用于存储所有的后驱，分层存储，并且存储了当前节点的当前层到下一个当前层的节点的跨度。</p>
<p>我们用一张图来展示跳跃表的结构： <img
src="/images/跳跃表数据结构分析/zskiplist.png" />
这是一个length为10，level为4的跳跃表。
由上图可以看到，表的头结点不存储数据，Redis中的跳跃表也是如此，另外尾节点始终指向空。</p>
<p>另外，根据Redis对于跳跃表的Create函数（zslCreate函数）可以得知，每个节点最大拥有ZSKIPLIST_MAXLEVEL（32）层，所以这避免了跳跃表无限制增加层数的问题。</p>
]]></content>
      <categories>
        <category>Redis源码分析</category>
        <category>zskiplist</category>
      </categories>
  </entry>
  <entry>
    <title>通道（channel）的阻塞和关闭</title>
    <url>/2020/03/07/%E9%80%9A%E9%81%93%EF%BC%88channel%EF%BC%89%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<h1 id="通道的阻塞">通道的阻塞</h1>
<h2 id="触发条件">触发条件</h2>
<p>在Golang中，如果不给通道设置buffer大小，那么不论是向通道发送还是从通道接收数据时都会发生阻塞等待。发送时阻塞的时长取决于何时从通道接收数据；接收时等待的时长取决于何时向通道发送数据。
<span id="more"></span> 例如有如下的代码： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// time.Sleep(1e9)</span></span><br><span class="line">	fmt.Println(&lt;- ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// time.Sleep(1e9)</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">go</span> receive(ch)</span><br><span class="line">	<span class="keyword">go</span> send(ch)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10e9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
receive和send函数中的两处注释只要有一处解除，结果“10”都会延迟1秒以后显示。</p>
<h2 id="阻塞的判断">阻塞的判断</h2>
<p>如何判断通道发生阻塞？在Golang中主要使用的是select-case的语法。</p>
<p>它的格式大致如下： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- ch1 :</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	<span class="keyword">case</span> &lt;- ch2 :</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	<span class="keyword">case</span> ch3 &lt;- :</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	<span class="keyword">default</span> :</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果所有case中的情况不成立，也就是所有通道都被阻塞，那么就会执行default。<strong>如果有多个case成立，那么就随机执行一个。</strong></p>
<p>利用select-case判断通道阻塞的代码可以如下： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;- ch :</span><br><span class="line">	<span class="keyword">default</span> :</span><br><span class="line">		<span class="comment">// channel ch is blocked</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果ch发生阻塞，那么default就会执行。当然这么做如果ch没有发生阻塞，那么ch中就会取出一个数据，这就需要在程序设计时做出改变。</p>
<h2 id="死锁的形成">死锁的形成</h2>
<p>在通道中，如果收和发其中一个执行了，但另一个永远不执行，那么就会导致通道死锁。Go对于死锁的判断是所有goroutine都被阻塞或者执行完毕，但通道仍然被占用，这时就会出现“deadlock”的panic。</p>
<p>例如： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	&lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一个只有收操作的程序是永远等不到发送的数据的，因此就会导致“deadlock”的错误提示。</p>
<h2 id="通道阻塞会导致的其它问题">通道阻塞会导致的其它问题</h2>
<p>通道阻塞可能会导致死锁，但这属于程序设计的问题，而不是程序的可优化之处。<strong>通道阻塞会导致通道不被及时回收。</strong></p>
<p>例如： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- client.Call() &#125;()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> resp := &lt;- ch:</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(<span class="number">1e9</span>):</span><br><span class="line">		<span class="comment">// timeout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果1秒之后client.Call()仍然没有执行完毕就会触发time.After()，也就是宣告执行超时。倘若此后client.Call()执行完毕，而ch通道在之后又没有收的操作，这就会导致ch被阻塞。但因为不满足所有goroutine都被阻塞或者执行完毕的条件，所以不会出现“deadlock”的panic，因此程序表面上是执行一切正常，但是ch却不会被GC程序自动回收。</p>
<p>如果要解决上面的问题，只要向ch提供buffer即可： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 提供了buffer就可以避免阻塞，从而也不会导致ch不被GC程序回收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- client.Call() &#125;()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> resp := &lt;- ch:</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	<span class="keyword">case</span> &lt;- time.After(<span class="number">1e9</span>):</span><br><span class="line">		<span class="comment">// timeout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="通道的关闭">通道的关闭</h1>
<p><strong>通道的关闭只可以由发通道执行，收通道在通道不为空的情况下是无感的。</strong>通道的关闭意味着不会再向这个通道发送任何数据。</p>
<h2 id="通道关闭的判断">通道关闭的判断</h2>
<p>通道关闭的判断方法主要有两种：一是使用ok标记，二是使用for-range语法。</p>
<h3 id="ok标记判断法">ok标记判断法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">val, ok := &lt;- ch <span class="comment">// 当ch被关闭了，那么ok就会为false</span></span><br></pre></td></tr></table></figure>
<h3 id="for-range语法判断">for-range语法判断</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> input := <span class="keyword">range</span> ch &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当ch关闭时，ch中数据被遍历完之后会自动退出遍历。如果ch被阻塞，那么只是在原地阻塞等待新数据进入进行下一次遍历</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>避免使用lambda的默认捕获模式</title>
    <url>/2018/11/09/%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8lambda%E7%9A%84%E9%BB%98%E8%AE%A4%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在C++11中有两种默认的捕获模式：按址和按值。默认的按址捕获会导致悬空引用，而默认的按值捕获确实可以避免这个问题，但是这也将让你的lambda表达式变得脱离外部数据（本地变量、参数等）的。
<span id="more"></span> # 不要使用默认的按址捕获模式</p>
<p>按址捕获会使lambda表达式包含本地变量的引用或lambda定义的空间中可用的参数。如果使用的lambda的生命周期超出了本地变量或者参数的生命周期，lambda中对这些变量或者参数的引用将会悬空。例如，假设我们有一个过滤函数的容器，容器中的函数都是使用一个int作为参数，并且返回一个bool值用以指示传进去的值是否满足这个过滤器:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;</span><br><span class="line"></span><br><span class="line">FilterContainer filters;</span><br></pre></td></tr></table></figure> 我们添加一个过滤器，过滤不是5的倍数: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">	[](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % <span class="number">5</span> == <span class="number">0</span>; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
这样写没什么问题，但是我们通常会遇到不能硬编码一个5进去，而是要通过计算，这样代码可以就看上去是这样的了:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">	<span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[&amp;](<span class="type">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码就会发生问题。这段lambda使用了一个本地变量divisor，但是这个变量在addDivisorFilter退出时就会销毁。而addDivisorFilter在执行完filters.emplace_back之后函数就会返回，所以加到filters中的过滤函数在执行时就是有问题的，在执行这样的过滤函数时就会出现未定义行为。</p>
<p>如果显式地按址捕获divisor，还是会出现同样的问题: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">	[&amp;divisor](<span class="type">int</span> value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
使用的显式捕获，可以更方便地看到lambda是否可用依赖于divisor的生命周期。也就是说，写出“divisor”的名字，可以让我们记住确保divisor的生命周期和lambda表达式的一样长。</p>
<p>如果你知道某个lambda表达式将会立刻使用，并且不会被复制，你使用引用是没有风险的。你可能会争论，没有悬空指针的风险就没有必要避免使用默认的引用捕获模式，例如，我们过滤lambda可能被用作C++11的std::all_of函数的参数，这个函数可以返回是否所有的元素都满足某个条件:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workWithContainer</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">	<span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> ContElemT = <span class="keyword">typename</span> C::value_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> std::begin;</span><br><span class="line">	<span class="keyword">using</span> std::end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(std::<span class="built_in">all_of</span>(</span><br><span class="line">				<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container),</span><br><span class="line">				[&amp;](<span class="type">const</span> ContElemT&amp; value)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> value % divisor == <span class="number">0</span>; </span><br><span class="line">				&#125;</span><br><span class="line">		)</span><br><span class="line">	) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码是正确的，并且是安全的，但是这个安全是不稳固的。如果lambda在别的上下文中被使用，粘贴到divisor被销毁的上下文时，代码将会发生悬空，而且你很难想到要去进行divisor的生命周期的分析。
所以从长远的说，应该使用显式指定捕获变量的lambda，而不是使用默认的捕获模式。</p>
<p>在C++14中引入了lambda中的auto类型，上面的代码在C++14中可以利用auto简化，对ContElemT的类型定义可以去除掉。因此if条件可以被改成如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(std::<span class="built_in">all_of</span>(</span><br><span class="line">		<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container),</span><br><span class="line">		[&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h1 id="不要使用默认的按值捕获模式">不要使用默认的按值捕获模式</h1>
<p>一个解决divisor生命周期的问题就是使用默认按值捕获模式。因此我们可以将添加filters的lambda的代码改成如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">	[=](<span class="type">int</span> value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="comment">// 这样divisor就不会悬空了</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
但实际上，使用按值捕获模式不是反悬空的利器。问题在于如果你以按值模式捕获了一个指针，就会将指针复制到lambda表达式中，但是你没有防止表达式外的代码将这个指针指向的地址内的数据销毁，因为这样也会导致悬空。</p>
<p>假设Widget对象能做的事情之一就是作为filters的容器的添加的入口:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> divisor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> Widget::addFilter被定义成如下的样子: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[=](<span class="type">int</span> value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码乍一看是一段安全的代码：lambda表达式依赖于divisor，但是默认按值捕获模式使divisor是复制到lambda中的，保障了divisor在lambda被调用时。
但事实上这样描述是有错误的！捕获的只会是lambda所在空间中可见的非static的本地变量（包括参数）。在Widget::addFilter的函数体中，divisor不是一个本地变量，而是一个Widget对象的数据成员，它不能被捕获。那这里为什么是正确的？请往下看。</p>
<p>如果写默认捕获，代码就无法编译通过: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[](<span class="type">int</span> value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="comment">// 错误！代码不会被编译通过</span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
另外如果尝试显式捕获divisor（不论按值捕获模式还是按址捕获模式），代码也不会编译通过，因为divisor不是一个本地变量或者参数:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[divisor](<span class="type">int</span> value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="comment">// 错误！没有本地变量或者参数可以被捕获</span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所以如果使用了默认按值捕获是无法捕获divisor的，但不使用按值捕获的话，代码也不会编译通过。这种情况下该怎么办呢？
答案是使用指针--this指针。每个非static成员函数拥有一个this指针，你可以使用这个指针访问数据成员。例如在Widget的成员函数中，编译器内置隐式地将divisor替换成了this-&gt;divisor。在Widget::addFilter使用的默认按值捕获中:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[=](<span class="type">int</span> value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
被捕获的是Widget对象的this指针。编译器将代码改写成类似下面的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> currentObjectPtr = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[currentObjectPtr](<span class="type">int</span> value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % currentObjectPtr-&gt;divisor == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这也就是说，这段lambda的是否可用取决于this指针的生命周期。</p>
<p>另外，再考虑下面的代码: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = std::vector&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;;</span><br><span class="line">FilterContainer filters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> pw = std::<span class="built_in">make_unique</span>&lt;Widget&gt;();</span><br><span class="line"></span><br><span class="line">	pw-&gt;<span class="built_in">addFilter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当调用doSomeWork时，一个依赖于由std::make_unique生产的Widget的过滤函数被创建，这个过滤函数包含了一个指向Widget的指针--Widget的this指针。这个过滤函数被添加到filters容器中，但是当doSomeWork执行完毕之后，这个Widget对象就会被std::unique_ptr的管理机制所销毁。由此可见，filters包含了悬空的指针。
解决这样的问题可以复制数据成员到本地变量中，然后捕获这个本地变量来解决:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> divisorCopy = divisor;</span><br><span class="line"></span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[divisorCopy](<span class="type">int</span> value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 事实上，你使用默认按值捕获也是有用的: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> divisorCopy = divisor;</span><br><span class="line"></span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[=](<span class="type">int</span> value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但不建议这样做。<strong>因为默认的捕获模式可以在你认为你在捕获divisor时，无意中捕获this指针。</strong></p>
<p>在C++14中，一个更好的捕获成员变量的方法是使用普遍化的lambda捕获(generalized
lambda capture，又称初始化捕获，请参看:<a
href="/2018/11/11/使用初始化捕获将对象移动到lambda表达式中/">使用初始化捕获将对象移动到lambda表达式中</a>):
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addFilter</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[divisor = divisor](<span class="type">int</span> value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为默认捕获模式和广泛的lambda捕获没有任何关系，因此在C++14中也要避免使用默认的捕获模式也成立。</p>
<p>按值捕获还有一个额外的缺点就是会使lambda看上去是独立的、可以不依赖外界数据运行的，而事实上是需要外界数据的。因为lambda依赖的数据不只有本地变量和参数，还有static方式存储的对象。这些使用了static的对象如果定义在全局空间或者命名空间中，亦或是在类中、函数中和文件中定义的static，在lambda中使用都可能导致它们无法被捕获。思考下面这段代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">	<span class="type">static</span> <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line"></span><br><span class="line">	filters.<span class="built_in">emplace_back</span>(</span><br><span class="line">		[=](<span class="type">int</span> value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	++divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可能就因为看到了“[=]”就认为lambda使用了所有对象的拷贝副本，从而认为这是一个使用按值捕获的独立lambda。但事实上这不是一个按值捕获的独立lambda，这个lambda没有使用任何非static的本地变量，只是使用了static的变量divisor，因此没有捕获到任何东西。在addDivisorFilter的末尾，divisor会执行自加1，并且lambda已经在addDivisorFilter中被存储到filters中了，这个lambda
的行为因此也将会改变（因为divisor的值改变了）。换种方式理解就是，lambda通过引用的方式捕获到了divisor，这样和默认的按值捕获看上去非常不一样。如果你不使用按值捕获，就不会有这样的风险。</p>
<p><strong>总结</strong></p>
<ul>
<li>默认的按址捕获可以导致引用悬空</li>
<li>默认的按值捕获可能会导致指针悬空（尤其是this指针），并且它还会使lambda看上去是独立的（也就是没有使用任何引用的）。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>避免重载全体引用为参数的函数</title>
    <url>/2018/10/22/%E9%81%BF%E5%85%8D%E9%87%8D%E8%BD%BD%E5%85%A8%E4%BD%93%E5%BC%95%E7%94%A8%E4%B8%BA%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>有这样一段代码用于在日志中记录当前的时间和日期，然后添加名字到整体的一个数据结构中:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; names;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	names.<span class="built_in">emplace</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 考虑如下的调用之后，你会发现代码的效率并不是很高:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">petName</span><span class="params">(<span class="string">&quot;Darla&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAddAdd</span>(petName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Persephone&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAddAdd</span>(<span class="string">&quot;Patty Dog&quot;</span>);</span><br></pre></td></tr></table></figure>
在第一个调用中，petName被绑定到了引用参数name。在logAndAdd中，name被赋值给了names.emplace函数。因为name是左值，所以name被复制到了names里。这个复制是没有办法避免的，因为name是一个左值引用。
在第二个调用中，参数name绑定到了由“Persephone”显式构造的std::string上，这是一个右值。name本身是一个左值，所以被复制到了names中。但是理论上我们可以感觉到，这个name可以移动到names中，因为name引用的是一个右值。
在第三个调用中，参数name绑定了一个右值，但是这一次的std::string是隐式从“Patty
Dog”构造的。然后就和第二次调用一样，把name复制到names中。因为这一次使用的是直接使用字面的字符串，所以没有必要创造这个临时的std::string，而是应该将这个字面的字符串直接传给emplace函数来构造一个std::string。所以在第三种调用中完全没有必要使用任何的复制和移动std::string的操作。
<span id="more"></span>
为了提高上述代码的效率，我们可以使用下面这个使用了全体引用的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>); names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">petName</span><span class="params">(<span class="string">&quot;Darla&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAddAdd</span>(petName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Persephone&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAddAdd</span>(<span class="string">&quot;Patty Dog&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure> 效率可以得到提升。</p>
<p>如果这时候重载一个方法可以用id来代替name进行logAndAdd，并且这个id是int类型的，这时候我们如果对logAndAdd函数进行重载，那么就应该是这样的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">nameFormIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line"></span><br><span class="line">	names.<span class="built_in">emplace</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">petName</span><span class="params">(<span class="string">&quot;Darla&quot;</span>)</span></span>; <span class="comment">//下面三个都调用了logAndAdd(T&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">logAddAdd</span>(petName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Persephone&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAddAdd</span>(<span class="string">&quot;Patty Dog&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(<span class="number">22</span>); <span class="comment">// 调用了logAndAdd(int)</span></span><br></pre></td></tr></table></figure> 其实这是有问题的。假设有如下的调用: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> nameIdx;</span><br><span class="line"></span><br><span class="line"><span class="built_in">logAndAdd</span>(nameIdx); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>
我们来分析下为什么会出错。首先由两个重载函数，其中一个的参数是全体引用，这个函数的T可以被推导为short。因此编译器就使用这个全体引用为参数的函数，因为它匹配得更加精准了。而int为参数的函数因为short要匹配上它还需要进行到更大范围的类型的转换，因此优先使用精准匹配那个，也就是logAndAdd(T&amp;&amp;)了。但是在这个函数中，name被std::forward到了emplace函数当中，因此在这时，就会执行std::string类型的构造函数，并且参数为short。因为std::string没有这样的构造函数，所以编译失败。这个错误的根源是全体引用为参数的函数因为自动推导是的模板函数变成比其它重载函数有更加准确的类型的参数的函数。参数类型是全体引用的函数是C++中最贪心的函数。它们会推导生成参数类型和实际调用的参数相同的函数。这个导致了重载参数是全体引用的函数是一个不明智的选择。</p>
<p>特别是使用完美转发构造函数(perfect forwarding
constructor)时最容易栽进这样的坑里。想想一个Person类，拥有几个构造函数来替代一个只能使用std::string或者index的构造函数:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">// 完美转发构造函数</span></span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">			<span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span> : name(std::forward&lt;T&gt;(n))&#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Persion</span><span class="params">(<span class="type">int</span> idx)</span> : name(nameFromIdx(idx))&#123;</span> &#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
不过还是和前面一样，如上代码中如果传递给logAndAdd是一个整数类型或者其它数字类型，还是调用全体引用函数，从而编译失败。但是更糟糕的是，这里还有很多看不到的编译器自动生成的重载函数。</p>
<p>在前面(<a
href="/2018/10/03/理解C++11中特别成员函数的生成/">理解C++11中特别成员函数的生成</a>)讲过，在合适的情况下，编译器将会生成复制和移动构造函数，并且在有模板函数能生成复制或者移动构造函数时仍然会生成。如果Person类的复制构造函数和移动构造函数生成了，Person类将会看上去更加高效:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">			<span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span> <span class="comment">// 完美转发构造函数</span></span></span><br><span class="line"><span class="function">			:name(std::forward&lt;T&gt;(n))&#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Persion</span><span class="params">(<span class="type">int</span> idx)</span></span>; <span class="comment">// int为参数的构造函数 </span></span><br><span class="line">		<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; rhs); <span class="comment">// 编译器自动生成的复制构造函数</span></span><br><span class="line">		<span class="built_in">Person</span>(Person&amp;&amp; rhs); <span class="comment">// 编译器自动生成的移动构造函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 如果这样调用: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>; <span class="comment">// 根据p复制新的Person对象，但这不会编译成功</span></span><br></pre></td></tr></table></figure>
这里我们尝试根据一个Person对象生成另一个Person对象。但是代码不会调用复制构造函数，而是调用完美转发函数。这个函数尝试使用Person对象创建Person中的std::string成员变量，也就是name。因为不存在从Person到std::string的转换方法，因此编译器报错。
为什么会出现这样的问题呢？因为这是C++规则规定：<strong>cloneOfP为非const类型的左值，因此这就意味着模板构造函数可以生成一个非const左值为参数的Person构造函数。</strong>也就是Person看上去是这个样子的:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(Person&amp; n)</span> : name(std::forward&lt;Person&amp;&gt;(n));</span></span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Persion</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line">		<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; rhs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure>
<strong>cloneOfP可能传给复制构造函数或者模板生成的函数。而调用复制构造函数则需要p为const类型的，而模板生成的函数则没有这个要求，所以编译器选择了模板生成的完美转发函数。</strong></p>
<p>当然我们还可以给p一个const属性: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> Person&amp; n)</span></span>;</span><br><span class="line">		<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; rhs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Person <span class="title">cp</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(cp)</span></span>; <span class="comment">// 此时就会调用复制构造函数</span></span><br></pre></td></tr></table></figure>
因为p现在是const类型的，根据选取最佳参数匹配函数的原则应该选参数为const
Person&amp;的构造函数。但这时候有两个这样的构造函数，根据C++的规则，我们优先选择非模板生成的函数，也就是选择复制构造函数。</p>
<p>完美转发构造函数和编译器自动生成的复制移动函数经常会导致一系列问题，尤其在继承时。例如在继承类初始化时，复制或移动会导致一些你意想不到的问题:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialPerson</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">SpecialPerson</span>(<span class="type">const</span> SpecialPerson&amp; rhs) :<span class="built_in">Person</span>(rhs) &#123; &#125;</span><br><span class="line">		<span class="built_in">SpecialPerson</span>(SpecialPerson&amp;&amp; rhs) :<span class="built_in">Person</span>(std::<span class="built_in">move</span>(rhs)) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在上面代码中继承类构造时指定基类的构造方式，并且使用继承类的对象作为基类的构造参数。这种情况下，继承类的复制和移动操作不调用基类的任何移动或者复制构造函数。它们调用的是基类的完美转发构造函数。因为继承类传给基类的是SpecialPerson类型的对象，而基类的不是模板的构造函数都是以Person作为参数类型的。完美转发函数的模板会生成一个完美匹配参数的函数，所以完美转发函数得到调用。</p>
<p>根据上面的讲述，应该可以理解为什么要避免重载全体引用为参数的函数。如果重载参数为全体引用的函数是一个错误的做法，对于需要转发大量参数类型的函数时你该怎么做呢？对于重载参数为全体引用的函数你可以尽量避免，但当无法避免时我们有什么技巧可以使得程序既不会出现上面的问题，又可以达到转发大量参数类型的目的？请参看下一章：<a
href="/2018/10/25/重载参数为全体引用的函数的替代方法/">重载参数为全体引用的函数的替代方法</a>。</p>
<p><strong>总结</strong> *
重载参数为全体引用的函数可能会导致重载发生的次数超乎你想象，因为模板函数的参数类型推测结果可能精准匹配你的实参。
*
完美转发函数尤其可能会导致问题。因为它可以更完美地生成适合非const左值的复制函数，并且可能会劫持继承类调用父类的复制或移动构造函数。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>重载参数为全体引用的函数的替代方法</title>
    <url>/2018/10/25/%E9%87%8D%E8%BD%BD%E5%8F%82%E6%95%B0%E4%B8%BA%E5%85%A8%E4%BD%93%E5%BC%95%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在之前(<a
href="/2018/10/22/避免重载全体引用为参数的函数/">避免重载全体引用为参数的函数</a>)我们说到要尽量避免重载参数为全体引用的函数。但是又讲到，重载全体引用为参数的函数有时可以给我们带来很多好处，例如当函数需要转发大量的参数时。所以这一章节我们讲解几种能让程序达到我们满意效果的几种方法，本质就是避免重载全体引用为参数的函数，或者应用参数类型匹配限制。
<span id="more"></span></p>
<h1 id="禁止重载">禁止重载</h1>
<p>在<a
href="/2018/10/22/避免重载全体引用为参数的函数/">避免重载全体引用为参数的函数</a>中我们把使用std::string和idx进行记录添加的函数起两个名字，避免了重载。例如:logAndAddName和logAndAddIdx，这样就可以互不影响地工作了。但是这种方法对于被重载的函数是构造函数却是没有用的，因为构造函数的名字是C++语言定死的，没有办法重新起。而且没有理由要抛弃重载。</p>
<h1 id="通过const-t传递">通过const T&amp;传递</h1>
<p>一个替代方法是使用C++98语法，把通过全体引用传递变成通过const类型的左值类型传递。但是这种方法并不是非常高效。</p>
<h1 id="通过值传递">通过值传递</h1>
<p>我们可以使用通过值传递替代通过引用传递来简化代码。这样做的一些建议将会在后面给出。我先简单用代码展示一下代码怎么写:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(std::string n)</span> : name(std::move(n)) &#123;</span> &#125; </span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="type">int</span> idx)</span> : name(nameFromIdx(idx)) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
因为构造函数中的std::string的构造函数是不接受整数的，包括int和类int参数，所以将会自动调用参数为int的重载函数。以此类推，如果参数是可以构造std::string的，就会调用参数为std::string的重载函数。
这里顺便提及一下，如果参数是0或者NULL，将会调用参数为int的重载函数。如果不知道具体原因可以参考:<a
href="/2018/09/25/尽量使用nullptr替代0和NULL/">尽量使用nullptr替代0和NULL</a>。</p>
<h1 id="使用传递标记">使用传递标记</h1>
<p>上面介绍的通过const的左值引用和通过值的方式传递都无法支持完美转发。如果你是要使用完美转发才使用的全体引用那就没有办法使用上面两种方法了。然而我们不想拒绝重载和全体引用，我们该如何避免对参数为全体引用的函数的重载呢？
有一个新的方法，叫做传递标记。当调用重载函数时，编译器会先选择参数最佳的调用，这个参数最佳会把参数的组合考虑在内，不是单纯地看参数类型是否最合适。所以当一个全体引用参数变成了一个类型完美的函数后，这个函数的其它非全体引用参数也是参数列表中的一部分，通过其它的参数达到调用非全体引用的重载函数。这就是这个方法的基本思路，下面使用一个例子:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; names;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line"></span><br><span class="line">	names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
接下来我们将加入对index的支持。因为参数为index时使用的逻辑和std::string时是不一样的，因此需要将两种情况下的逻辑写到两个函数里，一个函数支持整数为参数，一个函数支持非整数的操作。而logAndAdd用来转发到相应的函数。
两个函数可以其同一个名字，例如logAndAddImpl，因此要使用到重载。其中一个函数要使用全体引用，不过我们会给这两个函数第二个参数，用来防止我们落入之前所说的混乱当中。这个第二个参数成为了选择哪个函数调用的关键。代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">logAndAddImpl</span>(</span><br><span class="line">		std::forward&lt;T&gt;(name),</span><br><span class="line">		std::<span class="built_in">is_integeral</span>&lt;T&gt;()</span><br><span class="line">	); <span class="comment">// 有细微瑕疵</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的代码有细微的瑕疵。如果T为整数的引用，那么将会调用参数为非整数的logAndAddImpl。因为整数的引用不是整数。所以整改后的代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">logAndAddImpl</span>(</span><br><span class="line">		std::forward&lt;T&gt;(name),</span><br><span class="line">		std::is_integeral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;()</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> C++14中可以写成std::remove_reference_t。</p>
<p>而logAndAddImpl有两个重载函数，我们这样写: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line"></span><br><span class="line">	names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="type">int</span> idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="type">int</span> idx, std::true_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">logAndAdd</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
logAndAdd传递一个布尔型给logAndAddImpl函数，但是true和false是运行时的值，所以我们需要使用一个编译时的布尔型来选择调用哪个logAndAddImpl。在标准库中提供了std::true_type和std::false_type来表示运行时的true和false。</p>
<p>在index的logAndAddImpl重载函数中，我们通过将std::string传递给logAndAdd函数可以避免在两个重载函数中都要编写写日志的代码。
在这种设计方式中，std::true_type和std::false_type就是标记。标记的目的是用来强制调用某个我们想要的重载函数。它们在运行时是没有任何作用的，因此编译器在编译时会将这个标记忽略掉。这是一种模板元编程的正常技巧，你接触当代的C++代码越多了你就会发现这个方法很常见。
标记传递的方法在运行时没有任何不同，只是可以让我们没有问题地结合全体引用和重载。转发函数logAddAdd的参数中是一个没有限制的全体引用，但是这个函数没有使用重载。而在实际的逻辑函数logAndAddImpl中，我们使用了重载，并且其中一个使用了全体引用作为了参数。但是我们还使用了第二个参数作为标记，也就是编译器在选择重载函数的时候不光看第一个全体引用函数，还看第二个标记参数。此时全体引用是否完美匹配参数就显得不那么重要了。</p>
<h1 id="在使用全体引用的模板上加限制">在使用全体引用的模板上加限制</h1>
<p>传递标记的中心思想就是一个非重载函数作为对外接口，通过调用这个接口转发到逻辑函数上去。创建一个非重载的转发函数非常简单，但是在之前我们考虑了一个问题，一个完美转发构造函数可能会拦截对编译器自动生成的默认复制构造函数和默认移动函数，即使写了一个构造函数并且使用传递标记的方法，有些构造还是通过编译器自动生成的函数进行，从而绕过了传递标记的方法。</p>
<p>但是，最严重的问题不是默认生成的函数会屏蔽标记传递函数的使用，而是标记传递函数可能会屏蔽默认生成的函数。有时你可能希望调用复制构造函数以复制某个类型数据的左值。但是如果某个构造函数使用了全体引用作为参数会导致这个构造函数在复制非const左值时一直被调用。还有，如果一个类的构造函数是完美转发构造函数，那么它的继承类调用的复制或构造函数将会一直调用这个完美转发函数函数。
正好这时你想使用编译器自动生成的和全体引用的结合，那么标记转发就不适合你了，你需要使用一种技术可以让你选择模板函数的生成使用条件，这就是std::enable_if。
std::enable_if提供了一种方法可以强制编译器使某些特定的类型模板函数不生成，也就是让它们不可用(disable)。默认情况下，任何类型都是可以通过模板函数生成的，但是你可以通过std::enable_if使得部分类型在特定情况下不可以生成。在<a
href="/2018/10/22/避免重载全体引用为参数的函数/">避免重载全体引用为参数的函数</a>的例子中，我们可以使用std::enable_if这样编写Person的构造函数:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">template</span>&lt;</span><br><span class="line">			<span class="keyword">typename</span> T,</span><br><span class="line">			<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;condition&gt;::type</span><br><span class="line">		&gt; <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
为了理解在代码中发生了什么，建议自行了解std::enable_if做了什么，你可以通过搜索“SFINAE”来找到相关内容。我们着重了解一下condition的表达。
condition条件如果想指定T不是Person是，模板函数可以生成代码的话，我们可以通过使用模板代码段std::is_same，因此condition就替换成!std::is_same::value。上面的condition非常接近正确代码了，因为我们没有考虑T为Person&amp;时，也就是当调用代码如下时:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Nancy&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cloneOfP</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure>
cloneOfP从对象p复制一个对象。因为上面的构造函数的参数是全体引用，因此T被推测为Person&amp;。而在std::enable_if的条件中，!std::is_same::value的值为真，因此上面的cloneOfP调用的是这个全体引用为参数的构造函数。而实际上本意是调用默认复制构造函数。
另外这个问题也可以引申到T为const、volatile的情况。我们可以统一使用std::decay::type使T去除掉const、volatile和引用。具体的代码如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">template</span>&lt;</span><br><span class="line">			<span class="keyword">typename</span> T,</span><br><span class="line">			<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt; </span><br><span class="line">				!std::is_same&lt;</span><br><span class="line">					Person, </span><br><span class="line">					<span class="keyword">typename</span> std::decay&lt;T&gt;::type </span><br><span class="line">				&gt;::value </span><br><span class="line">			&gt;::type </span><br><span class="line">		&gt; <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这种格式非常难懂，这也是为什么我最后介绍这个方法。如果你能很好地理解&lt;&gt;符号是非常好的，不过之前的几种方法可以替代这个方法的话就请使用前几种方法。在上面的代码中，如果从一个Person构造一个新的Person对象，不论之前的Person对象是左值还是右值、const或者非const、volatile或者非volatile都将不会影响调用全体引用的构造函数。</p>
<p>这样就结束了么？不！这里还疏忽了一点。对于从Person继承的类，并且定义了复制构造和移动构造函数，如下:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialPerson</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">SpecialPerson</span>(<span class="type">const</span> SpecialPerson&amp; rhs) <span class="comment">// 复制构造函数，调用基类的转发构造函数</span></span><br><span class="line">			:<span class="built_in">Person</span>(rhs) &#123; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">SpecialPerson</span>(SpecialPerson&amp;&amp; rhs) <span class="comment">// 移动构造函数，调用基类的转发函数</span></span><br><span class="line">			:<span class="built_in">Person</span>(std::<span class="built_in">move</span>(rhs)) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
我们向基类Person传递了SpecialPeron，我们希望调用基类的复制和移动函数，但是我们传给了基类SpecialPerson对象，不是Person对象，这就造成问题，它们的类型是不同的。如果我们构造了一个SpecialPerson，在构造函数中构造基类Person时就会调用上面的模板函数生成的参数完美的函数。这样传进去的就是SpecialPerson对象，而不是Person对象，调用的就是Person的完美转发函数而不是默认的复制和移动构造函数。我们可以使用std::is_base_of::value解决问题，它会在T2是T1的派生类时为真。对于我们上面的Person的模板构造函数，我们希望是当T为T的派生类的时候不使用模板构造函数。因此我们可以这样补充上面的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">template</span>&lt;</span><br><span class="line">			<span class="keyword">typename</span> T,</span><br><span class="line">			<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">				!std::is_base_of&lt;</span><br><span class="line">					Person,</span><br><span class="line">					<span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">				&gt;</span><br><span class="line">			&gt;::type</span><br><span class="line">		&gt; <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
现在我们完成了C++11风格的代码，如果想要使用C++14的代码，我们可以用这样的代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">template</span>&lt;</span><br><span class="line">			<span class="keyword">typename</span> T,</span><br><span class="line">			<span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;</span><br><span class="line">				!std::is_base_of&lt;</span><br><span class="line">					Person,</span><br><span class="line">					std::<span class="type">decay_t</span>&lt;T&gt;</span><br><span class="line">				&gt;::value</span><br><span class="line">			&gt;</span><br><span class="line">		&gt; <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
上面的代码对于Person的复制和移动已经完美了。但是如果我们这时引入了int为参数的构造函数，我们怎么修改？其实很类似了:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">template</span>&lt;</span><br><span class="line">			<span class="keyword">typename</span> T,</span><br><span class="line">			<span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;</span><br><span class="line">				!std::is_base_of&lt;</span><br><span class="line">					Person,</span><br><span class="line">					std::<span class="type">decay_t</span>&lt;T&gt;</span><br><span class="line">				&gt;::value</span><br><span class="line">				&amp;&amp; !std::is_integral&lt;std::remove_reference&lt;T&gt;&gt;::value</span><br><span class="line">			&gt;</span><br><span class="line">		&gt; <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
好了代码非常漂亮，也非常有非常高的效率。这种方法可以应用到重载无法避免的情况下。</p>
<h1 id="权衡">权衡</h1>
<p>前三种方法都是使用指定参数类型的函数，后两种方法使用了完美转发，因此可以不指定参数类型。
因为完美转发避免了用于转换到指定的参数类型的临时变量，所以它使程序更高效。比如在上面Person类的构造函数中，我们使用了完美转移使得字面的“Nancy”直到构造新对象的std::string时才构造一个std::string。</p>
<p>但是完美转发有它的不足。第一，有一些参数不可以使用完美转发，即使它们可以被传递到指定类型的函数中；第二，在错误信息的可理解度上。当传过去一个不可用的参数时，编译器可能生成一个很难理解的错误信息。我们可以static_assert来自定义错误信息，当然还是要结合std::is_constructible。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">template</span>&lt;</span><br><span class="line">			<span class="keyword">typename</span> T,</span><br><span class="line">			<span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;</span><br><span class="line">				!std::is_base_of&lt;Person, std::<span class="type">decay_t</span>&lt;T&gt; &gt;::value</span><br><span class="line">				&amp;&amp; !std::is_integral&lt;std::remove_reference&lt;T&gt;&gt;::value</span><br><span class="line">			&gt;</span><br><span class="line">		&gt; <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n) : <span class="built_in">name</span>(std::forward&lt;T&gt;(n))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">static_assert</span>(</span><br><span class="line">				std::is_constructible&lt;std::string, T&gt;::value,</span><br><span class="line">				<span class="string">&quot;Parameter n cannot be used to construct a std::string&quot;</span></span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">u&quot;Jackson&quot;</span>)</span></span>; <span class="comment">// char16_t</span></span><br></pre></td></tr></table></figure>
static_assert在发现T类型不可以作为参数构造std::string时，会显示阅读良好的消息。不过上面的构造函数会因为初始化列表中name的初始化导致错误，也就是会导致static_assert的错误出现在大量的原本的错误之后。</p>
<h1 id="总结">总结</h1>
<ul>
<li>避免全体引用和其重载结合的方法包括使用不同的函数名、传递const类型的左值引用、传递值和使用转发标记方法。</li>
<li>通过std::enable_if限制模板时，可以同时使用全体引用和其重载。但是这个方法控制了编译器使用选择引用重载函数的条件。</li>
<li>全体引用参数通常有更高效的好处，但是通常在可使用性上有劣势。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11标准的模板类型推测</title>
    <url>/2018/09/14/C++11%E6%A0%87%E5%87%86%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%B5%8B/</url>
    <content><![CDATA[<p>C++11标准中新添加的重要功能之一就是引入了&amp;&amp;，也就是称为右值(rvalue)的东西。右值的概念不再赘述，自行参考它处。
而在C++11的模板中，&amp;&amp;符号有不同的意思，因为它可能代表的不是右值。
<span id="more"></span> 有如下四种模板函数： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(<span class="type">const</span> T param)</span></span>;</span><br></pre></td></tr></table></figure>
模板类型推测就是推测不同类型的param在上面函数中作为参数时的类型推测的结果。书中将param分为：
1. param为指针或者引用的，但不是全体引用(Universal Reference)。 2.
param为引用，并且为全体引用，也就是“&amp;&amp;”。 3.
param既不是指针也不是引用。
关于全体引用就是说它可以是左值引用，也可以是右值引用。这个是根据实际调用的传进来的参数决定的。它的表现形式是使用“&amp;&amp;”来表示的，它在template中不表示右值引用。具体的全体引用部分可以参看：<a
href="../区别全体引用和右值引用">区别全体引用和右值引用</a></p>
<p>接下来就来讨论这三种情况在实参类型不同时的类型推测，也就是T代表什么类型，param是什么类型。</p>
<p>我们可以利用编译器的错误提示来查看类型推测的结果: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; rx = cx;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">f1</span>(x); <span class="comment">// T is int, param is int&amp;;</span></span><br><span class="line">	<span class="built_in">f1</span>(cx); <span class="comment">// T is const int, param is const int&amp;</span></span><br><span class="line">	<span class="built_in">f1</span>(rx); <span class="comment">// T is const int, param is const int&amp;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">f2</span>(x); <span class="comment">// T is int&amp;, param is int&amp;</span></span><br><span class="line">	<span class="built_in">f2</span>(cx); <span class="comment">// T is const int&amp;, param is const int&amp;</span></span><br><span class="line">	<span class="built_in">f2</span>(rx); <span class="comment">// T is const int&amp;, param is const int&amp;</span></span><br><span class="line">	<span class="built_in">f2</span>(<span class="number">10</span>); <span class="comment">// T is int, param is int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">f3</span>(x); <span class="comment">// T is int, param is int</span></span><br><span class="line">	<span class="built_in">f3</span>(cx); <span class="comment">// T is int, param is int</span></span><br><span class="line">	<span class="built_in">f3</span>(rx); <span class="comment">// T is int, param is int</span></span><br><span class="line">	<span class="built_in">f3</span>(<span class="number">10</span>); <span class="comment">// T is int, param is int</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">f4</span>(x); <span class="comment">// T is int, param is int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面的代码编译后错误告诉了我们推测的类型结果，我把结论写在注释里了。</p>
<p>对于T的类型推测有明确的规律： +
param是一个指针或者引用，并且不是全体引用时： +
如果实参是一个引用，忽略实参的引用部分。然后根据实参类型和形参类型来决定T的类型，再根据T的类型决定param的类型。例如形参为T&amp;，实参为const
int时，T是const int类型，param就是const
int&amp;类型，这样带入也是符合C++的函数调用规律。 +
param是一个全体引用时： +
如果实参是左值，T和param类型都为左值引用类型。这也是template中唯一推断类型为引用的情况。其次根据上面全体引用的介绍，也可以知道，这里的推断出param的类型不一定是右值引用，也有可能是左值引用，因为这里的&amp;&amp;不是右值引用的意思，而是全体引用！
+ 如果实参是一个右值，那么就推导T为右值类型，这个按照常理来。 +
param不是引用或者指针时： + 如果实参是一个引用，忽略实参的引用部分。 +
如果实参类型是const或者volatile的，忽略这两种关键字。 +
如果实参是数组名，那么就会把T推断为指向数组第0位的指针。如果想让T推断为一个数组时，可以设置param的类型为T&amp;。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> name[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">f</span>(name);</span><br></pre></td></tr></table></figure> 如上编写代码，T就为const char[12]，param为const char
(&amp;) [12]。对于函数作为形参的情况也类似。</p>
<p>最后进行总结： 推断T时， *
当param是全体引用，而实参为左值时，T为左值引用类型。 *
当param中没有"&amp;"或者"<em>"时，为传值传参，实参的const和voliate特性不保留
</em>
当实参为数组名或者函数名时，T类型会退变成指针类型，指向数组或者函数的开头地址。除非param的类型为引用类型。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Effective Modern C++</category>
      </categories>
  </entry>
  <entry>
    <title>A*算法</title>
    <url>/2018/08/10/A-star%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>poj有一道非常经典的题目:Knight
Moves。大意是说每次移动“日”字型，最少移动多少次能达到目的地。学过算法的人都知道这是一题非常简单的bfs题。</p>
<p>今天我接触到了在hduoj上接触到了1560题。大意是要求一个最短序列，这个序列的子序列包含了给定的几个序列。</p>
<p>一开始我是想用暴力搜索结合剪枝的。题目中给定的子序列个数最多8个，每个序列最大长度为5，字符串由4中字符组成。这样所求的序列最长为40，如果用暴力搜索可能会达到<span
class="math display">\[4^{40}\]</span>次，这个预期太可怕了（虽然剪枝会减少这一数字）。后来discuss中提示，使用A*算法。
A*算法在以前的接触当中更多的是用在路径搜索上，例如上面的poj的那道题。没有想到A*算法是可以用在这道hduoj题上的。</p>
<span id="more"></span>
<h1 id="概念">概念</h1>
<p>首先我们来回顾一下A*算法。为了相对准确表述，我对维基百科相关词条进行翻译，词条地址：A*
search algorithm</p>
<p>A*算法又被称作为最好优先算法(best-first
search)，这意味着这个算法通过在所有路径中寻找最少消耗的路径来解决问题，这个最少消耗可能是最短的路径、最少的时间等等。它最先考虑可能是最少消耗路径的路径，这是使用权重图(weighted
graph)的数据结构计算得出的，大概的算法步骤：从图的某一个指定节点出发，根据下一步能走的节点构建一个路径树，然后下一步选择其中预计最优的节点走下去，重复构建这种路径树，直到其中某条路径能走到预先设定好的那个目标节点。</p>
<p>在每次的主循环迭代中，A*算法需要决定下一步走到哪个节点。这个在bfs(广度优先)算法中是不存在的。广度优先算法对于所有可以走的节点是一视同仁，而A*算法则是要考虑可能是最好路径一部分的那条路径。</p>
<p>A*算法的可能最优路径是通过如下公式得出的： <span
class="math display">\[f(n) = g(n) + h(n)\]</span></p>
<p>n是图中的某一个节点坐标；g(n)是从起始节点到n节点的最少花费；h(n)是一个启发式值，估计了n到目标节点的最少花费。这个启发式函数是根据问题决定的，当问题是求最短路径时，启发函数必须是可接受的，这也就是说这个函数永远不会高估实际到目标节点的最小花费。</p>
<h1 id="举例">举例</h1>
<p>可能上面概念性的表述有一些难以理解，下面通过一个实例讲述A*算法。</p>
<p>求起点到终点的最短距离。</p>
<p>下面例子中，❤️表示终点，红色方框表示已经走过的节点（bfs中，已经走过的节点就不要再走了，这里的道理和bfs中的一样，走过就不用再走了），绿色方框表示可以走的节点，黑色是障碍物。方框中三个数，第一个数是f(n)，第二个是g(n)，第三个是h(n)。h(n)采用的启发函数是到目标节点的曼哈顿距离，因为到目标节点的花费肯定大于等于曼哈顿距离。</p>
<p>起点是第四行第二列的节点。 <img
src="/images/A-Star算法/A-Star1.png" /></p>
<p>因为起点右边的节点F(h)最小，也就意味着起点到这个节点的花费和预计到终点的花费之和最小，也就是预计走这个节点的路径花费最小，所以优先考虑这个节点。而实际上一眼可以看出最短路径不可能经过这个节点。
<img src="/images/A-Star算法/A-Star2.png" /></p>
<p>按照算法继续走下去，应该是这样的。 <img
src="/images/A-Star算法/A-Star3.png" /> <img
src="/images/A-Star算法/A-Star4.png" /></p>
<p>在上面一张图的状态下，f(n)最小的未走过的节点是第三行第一列的那个节点，所以算法选择其继续走下去。
<img src="/images/A-Star算法/A-Star5.png" /></p>
<p>通过走回路，可以确定一条最短路径。 <img
src="/images/A-Star算法/A-Star6.png" /></p>
<h1 id="总结">总结</h1>
<p>附上一张维基百科的gif用以帮助理解。 <img
src="/images/A-Star算法/Astar_progress_animation.gif" /></p>
<p>从图上可以看出A*算法在后期不太会向左上角（偏离目标节点的方向）进行搜索，这还是因为左上角方向会增大启发函数的值，导致算法不会偏向这边，而是选择右上角。</p>
<p>但是也可以看出这套算法的弱点，就是如果启发函数值，也就是h(n)和实际值偏差很大，甚至出现h(n)越小，实际到终点需要的花费越大的情况，会导致A*算法的效率低下的问题，这也是bfs算法在竞赛中仍被使用的原因，要根据情景合理使用。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>()和{}创建对象的差异</title>
    <url>/2018/09/24/()%E5%92%8C%7B%7D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<p>在C++11中，引入了一种新的创建对象方式，{}方法，也就是initializer_list的方式创建对象。这种方法和传统的C++创建对象的方式--()方法有不同之处。<span id="more"></span></p>
<h1 id="的方便之处">{}的方便之处</h1>
<p>诚然，这两种方式都是可以接受的，没有明显的优劣之分。但我们在创建对象的时候，使用initializer_list是较方便的。为什么这么说，请看下面的代码：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">private</span>: </span><br><span class="line">		<span class="type">int</span> x&#123;<span class="number">0</span>&#125;; <span class="comment">// ok </span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// error! </span></span><br><span class="line">		<span class="type">int</span> z = <span class="number">0</span>; <span class="comment">// ok </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
也就是说在对成员变量初始化中，使用()初始化是不可行的，但是使用=和{}是可行的。
另外： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		<span class="built_in">Widget</span>(<span class="type">int</span> x): <span class="built_in">x</span>(x)&#123;&#125;;</span><br><span class="line">		<span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; cw) = <span class="keyword">delete</span>; <span class="comment">// Widget is not a copyable class</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>: </span><br><span class="line">		<span class="type">int</span> x; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// ok </span></span><br><span class="line">	Widget w2&#123;<span class="number">0</span>&#125;; <span class="comment">// ok</span></span><br><span class="line">	Widget w3 = <span class="number">0</span>; <span class="comment">// error!</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
对于不可拷贝类对象，使用=进行拷贝构造是不可行的。</p>
<p>综合上面两种情况，只有{}构造方法可以“一劳永逸”，两边都可以使用。</p>
<h1 id="的特殊之处">{}的特殊之处</h1>
<h2 id="不支持变窄方向的初始化">不支持“变窄”方向的初始化</h2>
<p><strong>{}构造的函数，不支持类型向“变窄(narrowing)”的方向自动转换。</strong>
这个“变窄”可以理解为使数据丢失的方向，比如：double向int类型，double的小数位在转向int的时候会数据丢失。
例如下面的代码就会报错： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line"><span class="type">int</span> sum&#123;x + y + z&#125;;</span><br></pre></td></tr></table></figure>
x+y+z为double，{}的初始化不支持变窄方向的初始化，所以这个int无法初始化。
而()的初始化就支持这种“变窄”的初始化： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> x, y, z;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(x + y + z)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="空的初始化">空{}的初始化</h2>
<p><strong>当初始化使用不带参数的{}时，对象的初始化将会使用无参数的构造函数。</strong>如果想使用空的initializer_list初始化时，使用如下代码:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// both are ok</span></span><br><span class="line"><span class="function">Widget <span class="title">w</span><span class="params">(&#123;&#125;)</span></span>;</span><br><span class="line">Widget w&#123;&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<h2
id="构造函数不存在时将会调用的构造函数">{}构造函数不存在时将会调用()的构造函数</h2>
<p>例如下面代码中: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		<span class="built_in">Widget</span>(<span class="type">int</span> x, <span class="type">double</span> d) &#123;cout&lt;&lt; <span class="string">&quot;double&quot;</span> &lt;&lt; endl;&#125;; </span><br><span class="line">		<span class="built_in">Widget</span>(<span class="type">int</span> x, <span class="type">bool</span> b) &#123;cout&lt;&lt; <span class="string">&quot;boolean&quot;</span> &lt;&lt; endl;&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">1</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// boolean </span></span><br><span class="line">	Widget w2&#123;<span class="number">1</span>, <span class="literal">true</span>&#125;; <span class="comment">// boolean</span></span><br><span class="line">	<span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">1</span>, <span class="number">5.0</span>)</span></span>;  <span class="comment">// double </span></span><br><span class="line">	Widget w4&#123;<span class="number">1</span>, <span class="number">5.0</span>&#125;;  <span class="comment">// double</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
根据输出结果，我们发现w2选择的构造函数和w1一致，w3和w4一致。所以在不存在{}的构造方法时，{}的构造方法的选择和()一致。</p>
<h2 id="使用构造优先于使用构造">使用{}构造优先于使用()构造</h2>
<p>上面讨论的是仅存在()的构造方法时。<strong>当{}和()都存在时且排除会“变窄”的构造函数，编译器将会优先选择{}构造方法。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Widget</span>(<span class="type">int</span> x, <span class="type">double</span> d) &#123;cout&lt;&lt; <span class="string">&quot;double&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">		<span class="built_in">Widget</span>(<span class="type">int</span> x, <span class="type">bool</span> b) &#123;cout&lt;&lt; <span class="string">&quot;boolean&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">		<span class="built_in">Widget</span>(std::initializer_list&lt;<span class="type">long</span> <span class="type">double</span>&gt; il) &#123;cout&lt;&lt; <span class="string">&quot;initializer_list&lt;long double&gt;&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">1</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// boolean</span></span><br><span class="line">	Widget w2&#123;<span class="number">1</span>, <span class="literal">true</span>&#125;; <span class="comment">// initializer_list&lt;long double&gt;</span></span><br><span class="line">	<span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">1</span>, <span class="number">5.0</span>)</span></span>;  <span class="comment">// double</span></span><br><span class="line">	Widget w4&#123;<span class="number">1</span>, <span class="number">5.0</span>&#125;;  <span class="comment">// initializer_list&lt;long double&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>即使w2的最佳构造方法不是{}，w2、w4还是使用了优先调用了{}的构造方法。当然前提是boolean到long
double和double到long double不是“变窄”方向。</p>
<p>最后，<strong>当{}的构造函数都不能满足实参时，编译器就会“委曲求全”，使用()方法。</strong>例如:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Widget</span>(<span class="type">int</span> x, <span class="type">double</span> d)&#123;cout &lt;&lt; <span class="string">&quot;double&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">	<span class="built_in">Widget</span>(<span class="type">int</span> x, <span class="type">bool</span> b)&#123;cout &lt;&lt; <span class="string">&quot;boolean&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">	<span class="built_in">Widget</span>(std::initializer_list&lt;std::string&gt; str) &#123;cout&lt;&lt; <span class="string">&quot;initializer_list&lt;std::string&gt;&quot;</span> &lt;&lt; endl;&#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">1</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// boolean</span></span><br><span class="line">	Widget w2&#123;<span class="number">1</span>, <span class="literal">true</span>&#125;; <span class="comment">// boolean</span></span><br><span class="line">	<span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">1</span>, <span class="number">5.0</span>)</span></span>;  <span class="comment">// double</span></span><br><span class="line">	Widget w4&#123;<span class="number">1</span>, <span class="number">5.0</span>&#125;;  <span class="comment">// double</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> w2和w4并没有强行使用{}的构造函数。</p>
<h1 id="三.注意事项">三.注意事项</h1>
<p>两种初始化方法的结果可能完全不一样，如下代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector中&#123;&#125;与()功能不一样</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomeWork</span><span class="params">(Ts&amp;&amp;... params)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T vec1&#123;std::forward&lt;Ts&gt;(params)...&#125;; <span class="comment">// use &#123;&#125;</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;&#123;&#125; constructor : &quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)vec1.<span class="built_in">size</span>(); ++i) </span><br><span class="line">	&#123; </span><br><span class="line">		std::cout &lt;&lt; vec1[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">vec2</span><span class="params">(std::forward&lt;Ts&gt;(params)...)</span></span>; <span class="comment">// use () </span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;() constructor : &quot;</span> &lt;&lt; std::endl; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)vec2.<span class="built_in">size</span>(); ++i) </span><br><span class="line">	&#123; </span><br><span class="line">		std::cout &lt;&lt; vec2\[i\] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	std::cout &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	doSomeWork&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h1 id="四.总结">四.总结</h1>
<ul>
<li>使用{}的初始化方法是最被广为接受的格式，而且它可以防止初始化参数的“变窄”转换。</li>
<li>{}初始化方法尽可能使用initializer_list的初始化方法，如果实在没有可以使用的{}初始化方法，才去考虑()初始化方法。即使()构造方法的参数和实参很符合，它也不优先考虑。</li>
<li>{}初始化方法和()初始化方法会导致两个对象结果不一致。例如:std::vector<int>的两个初始化方法意义完全不一样。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
</search>
